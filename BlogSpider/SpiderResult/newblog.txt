blog地址：http://blog.zhaojie.me

[
    {
        "Title": "你的字典里有多少元素？",
        "Link": "/2014/07/how-many-elements-in-your-dictionary.html",
        "BriefIntro": "“字典”或者说“哈希表”大家都会用，这真是一个好东西，只要创建了之后就可以不断的丢东西进去，添加删除都是O(1)操作，那叫一个快字了得。不过这里我要再次引用Alan Perlis的名言：“Lisp programmers know the value of everything but the cost of nothing.”，目的是想提醒做事“不要忘记背后的代价”。那么它的代价是什么呢？这里的代价主要是其内存开销。 "
    },
    {
        "Title": "逆泛型执行器",
        "Link": "/2014/05/zrx-quiz-1-answer.html",
        "BriefIntro": "话说微信公众账号上的第一期有奖征答活动发布至今已有两周时间，不过参与人数寥寥，是太难，还是奖品不够吸引人？大家要多参与，我们才能长期互动嘛。现在我就对第一期的题目“逆泛型执行器”进行简单讲解吧，其实这题很简单，以后类似难度的题目可能会放在“快速问答”环节中。话说第一期的快速问答还在进行之中，大家加油。 "
    },
    {
        "Title": ".NET程序性能的基本要领",
        "Link": "/2014/05/essential-dotnet-perf-truths-tips.html",
        "BriefIntro": "说起Roslyn大家肯定都已经有所耳闻了，这是下一代C#和VB.NET的编译器实现。Roslyn使用纯托管代码开发，但性能超过之前使用C++编写的原生实现。Bill Chiles是Roslyn的PM（程序经理，Program Manager），他最近写了一篇文章叫做《Essential Performance Facts and .NET Framework Tips》，其中总结了几条经验。 "
    },
    {
        "Title": "在香港生活的初步感受",
        "Link": "/2013/09/hongkong-life-first-impression.html",
        "BriefIntro": "好久没有更新博客了，主要是生活产生了一些变化。我这人比较没出息，生活稳定的时候，不论是工作和学习都会有条不紊，但一旦有所动荡，则就会心神不宁，啥事都做不进去，效率也一落千丈，比如Coursera上的基本课程也拉下了。相信不少同学都知道我当年去IBM深圳的主要原因之一，就是看重这是个和JPMC的合作项目，两年后有机会可以去香港。现在已经在香港租好了房子，离完全布置好还有一段距离，先记录一下最近在香港生活的一些感受吧。 "
    },
    {
        "Title": "比较下中国大陆和香港之间的个税差异",
        "Link": "/2013/07/china-hongkong-taxing-comparison.html",
        "BriefIntro": "一直听说中国大陆个税税率之高，但一直没有跟哪儿作过比较。最近听说香港的税率很低，因此也想具体比较一下到底会差多少。单从数字上看，两者简直天差地远。例如，同样是累进税率，大陆从月入8K开始的部分就要缴纳20%的税率，超过38.5K则是30%，而香港最高也就只有17%。当然，比如香港租房之贵也遥遥领先于大陆一线城市，但房租亦可作为征税前的减免。正因为如此复杂，我们还是需要进行详细的计算才能有直观的概念，这里我就来尝试一下。这里以一对夫妻为例，但只计算其中一人的薪资，以传说中阿里P8级别的上限：月入5w人民币（年入60w），即月入6.25w港币（年入75w）为标准。当然，这只是对我比较有参考意义的数字，您也可以根据自己的标准来重新计算。 "
    },
    {
        "Title": "抓取InfoQ内容的calibre脚本",
        "Link": "/2013/06/calibre-recipe-infoq.html",
        "BriefIntro": "两个礼拜前我公开了一个抓取今年MSDN Magazine内容的calibre脚本，这次则是针对InfoQ的。最近用Kindle Paperwhite看书一发不可收拾，自然想要更好地利用这个设备。InfoQ是一个难得的高质量站点，可惜它的RSS只输出摘要，甚至只有前十条内容，让人感到十分不方便。但这显然难不住calibre这个电子书管理神器和伟大的程序员，于是我这段时间又断断续续地编写了InfoQ站点内容的抓取脚本，各个方面细节感觉修饰地都还算不错，特此公布。至于这个脚本该怎么用，就请自行看下calibre的帮助吧。 "
    },
    {
        "Title": "使用calibre抓取2013年的MSDN Magazine",
        "Link": "/2013/06/calibre-recipe-for-msdn-magazine-2013.html",
        "BriefIntro": "前段时间入手Kindle Paperwhite，这已经是我第三个Kindle设备了。想当年我花了四五千块钱，在亚马逊美国站上跟着老美预定，可谓是全世界第一批Kindle DX（大屏幕的那款阅读器）用户，不过用着用着后来还是去玩平板了。这次Kindle Paperwhite出了国行设备，才849元，顿觉实在是太便宜了，立即下单，第二天就拿到了这台设备。有了设备自然要用，除了官方书店里买的书以外，第三方的内容自然也必不可少，毕竟目前国内的Kindle电子书还太少（尤其是计算机方面的），还好之前也从国外买了不少mobi电子书，可以直接看。更重要的是，我发现可以使用calibre这个电子书管理神器来抓取网络上的内容，生成一本电子期刊，甚至可以利用亚马逊提供的邮箱推送服务来传送到Kindle设备上。第一个尝试的目标便是MSDN Magazine。 "
    },
    {
        "Title": "防止装箱落实到底，只做一半也是失败",
        "Link": "/2013/04/dont-go-half-way-of-preventing-boxing.html",
        "BriefIntro": ".NET提供struct类型，正确使用可以减少对象数量，从而降低GC压力，提高性能。不过有时候我会发现，某些同学有这方面的意识，但是有时候一疏忽一偷懒，就没有得到相应的效果了。这里举一个真实的例子：假设我们要将一对int作为字典的键，用于映射到某些数据，那么你会怎么做？当然我们可以直接使用Tuple<int, int>，但这样就可能产生大量的对象。于是我们打算使用自定义的值类型，但简单这么做其实并不一定能满足我们的要求。 "
    },
    {
        "Title": "为什么我不喜欢Go语言式的接口（即Structural Typing）",
        "Link": "/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html",
        "BriefIntro": "所谓Go语言式的接口，就是不用显示声明类型T实现了接口I，只要类型T的公开方法完全满足接口I的要求，就可以把类型T的对象用在需要接口I的地方。这种做法的学名叫做Structural Typing，有人也把它看作是一种静态的Duck Typing。除了Go的接口以外，类似的东西也有比如Scala里的Traits等等。有人觉得这个特性很好，但我个人并不喜欢这种做法，所以在这里谈谈它的缺点。当然这跟动态语言静态语言的讨论类似，不能简单粗暴的下一个“好”或“不好”的结论。 "
    },
    {
        "Title": "为什么我认为goroutine和channel是把别的平台上类库的功能内置在语言里",
        "Link": "/2013/04/why-channel-and-goroutine-in-golang-are-buildin-libraries-for-other-platforms.html",
        "BriefIntro": "这几天看了《Go语言编程》这本书，感觉一般，具体可见发表在图灵社区里的书评。书评里面我提到“Go语言的goroutine和channel其实是把别的语言/平台上类库的功能内置到语言里”，这句话当然单单这么说出来是没什么价值的，于是我也就趁热把它说得再详细一些。我的看法简而言之是：由goroutine和channel所带来的主要编程范式、设计思路等等，其实基本都可以在其他一些平台中配合特定的类库来实现。 "
    },
    {
        "Title": "如何在不装箱的前提下调用“显式”实现的接口方法？（答案）",
        "Link": "/2013/04/how-to-call-explicitly-implemented-interface-method-without-boxing-answer.html",
        "BriefIntro": "其实已经有不少同学抓住了关键，那就是使用泛型，不过有些同学提出Dispose<T>(T obj) where T : IDisposable这样的做法。我们没有进行类型转化，只是让运行时可以“认识到”类型T实现了IDisposable接口，这自然可以在不装箱的情况下调用其成员。可惜的是，这种做法的“意识”到位了，却是错误的，原因在于忽视了值类型传参的特点：复制所有内容。换句话说，这个辅助方法内部所使用的obj其实是一个副本，而不是原来的参数对象。假如被调用的成员会修改自身状态――尽管这对于值类型来说是一种极差的设计――这便会产生问题，所以正确的方法应该使用ref关键字来修饰参数。 "
    },
    {
        "Title": "如何在不装箱的前提下调用“显式实现”的接口方法？",
        "Link": "/2013/03/how-to-call-explicitly-implemented-interface-method-without-boxing.html",
        "BriefIntro": "上篇文章谈了针对一个struct对象使用using语句的时候是否会装箱的问题，结论是“不会”。尽管using语句是针对IDisposable接口的，但我们在调用的时候其实已经明确了目标方法，因此根本不需要装箱（或查找虚函数表）了。后来有同学在微博上提出，这点在《CLR via C#》这本书里提到过，于是我去翻了翻，表示这跟前一篇谈的内容其实并没有太多联系。不过这也引出了一个问题，假如一个struct类型显式实现了一个接口，您有什么办法在C#里调用这个接口方法呢？当然，调用时不能在堆上产生任何对象。 "
    },
    {
        "Title": "针对struct对象使用using关键字是否会引起装箱？",
        "Link": "/2013/03/using-on-disposable-struct-will-box-or-not.html",
        "BriefIntro": "说起来这是个很简单的问题，我以前肯定可以给出确切地答复，但是前几天想到这点的时候突然楞住了。把这个问题发到微博上去之后，很多人说是“会”，但要么是猜的，或是给出的原因明显不靠谱。最后我只能自己简单研究一下了，最后得到的结果是“不会”装箱。请注意，这个问题是指，对于一个实现了IDisposable接口的值类型对象使用using语句，而不是将它直接复制给一个IDisposable引用――后者显然是会装箱的，会对性能产生一定负面影响。 "
    },
    {
        "Title": "串与绳（1）：.NET与Java里的String类型",
        "Link": "/2013/03/string-and-rope-1-string-in-dotnet-and-java.html",
        "BriefIntro": "话说“字符串”是我们平时最常用的数据类型之一，它表示一个字符序列。在大部分的语言中，字符串还是一个不可变（Immutable）的数据类型。“不可变”意味着要改变则只能生成新的字符串，无论是连接两个字符串，获取或是替换字符串的一部分，这对于内存和CPU都是不可避免的开销。在一般情况下，只要使用合理这些开销都不会构成大问题。不过对于某些类型的应用，例如我前段时间在工作中涉及到的编辑器（IDE那种），就会带来较多麻烦，于是便用到了一个名为Rope的数据结构。Rope其实是一种很简单，很符合直觉的树状数据结构，也常用于表达一个字符序列，不过更适合需要大量修改的场景。不过，我们还是先来回顾一下.NET与Java中的String类型吧。 "
    },
    {
        "Title": "Everpage：将Evernote的笔记展现在页面上",
        "Link": "/2013/03/everpage-load-and-display-notes-from-evernote-on-the-page.html",
        "BriefIntro": "我这人尤其强调阅读体验，无论是作为文章的读者还是作者。假如遇到一篇格式糟糕的文章，我会完全没有耐心读完它。因此对于阅读工具的展现格式也是各种挑剔，例如字不能太小，内容不能太宽或太窄，段落间距必须大过行间距等等，例如OS X上著名的RSS阅读器Reeder无法自定义样式，我甚至钻进其App内部修改其CSS文件。Evernote也是一样，无论是其网页版还是客户端，其阅读体验在我看来都比较糟糕，于是我在愤而花了差不多半天的时间打造了Everpage这个小玩意儿。简单来说，就是把一篇Evernote笔记显示在页面上。 "
    },
    {
        "Title": "真是O(1)吗？想清楚了没？",
        "Link": "/2013/01/think-in-detail-why-its-o-1.html",
        "BriefIntro": "话说写程序的时候我们会用到各种数据结构，但十有八九不会由我们自己从头写起，都会直接拿来用。于是很多人就会记住，譬如HashMap或Dictionary的存取是O(1)的操作，二分查找什么的则是O(log(N))。不过，我们在实践中直接把这些类拿来用的时候，最好也留个心眼，知道这些类内部到底做了些什么，为什么它们能够达到O(1)之类的时间复杂度。我们在了解“理论”的同时也需要注意实践上的细节，例如，其实在实践中O(log(N))其实也是个不比O(1)大多少的时间复杂度，此时可能也需要考虑下“常数”会对性能造成多大影响。 "
    },
    {
        "Title": "一个最基本的HashedLinkedList",
        "Link": "/2013/01/a-basic-hashed-linked-list.html",
        "BriefIntro": "Tmc的初衷是补充一些常用的数据结构，例如对null作为字典键的支持，以及带有一个额外Remove方法的HashDictionary。但是，其实我创建Tmc项目的“初衷”却是HashedLinkedList。.NET BCL中已经有一个LinkedList，这是一个双向链表。说起来，我之前在面试中经常会提出一系列数据结构的基础问题，其中便包含LinkedList，我会问各个操作的时间复杂度，以及如何改进它们。例如，如何将它的Remove操作优化成O(1)的时间复杂度？最容易想到的做法便是使用一个字典来记录元素到特定LinkedListNode的映射关系。这种模式实在过于常见，所以便有了个特别的名称，叫做HashedLinkedList。 "
    },
    {
        "Title": "阅读.NET源代码那些事",
        "Link": "/2013/01/reading-dotnet-source-code.html",
        "BriefIntro": "谁都知道.NET（的大部分组件）是不开源的，但是我不止在一个场合不止一次地强调过，“不开源”不代表你没法看代码，不代表你没法知道里面发生了什么。这里我不是在说.NET Reflector或是ILSpy这类反编译工具，当然它们在平时开发中也起到了很大的作用，不过很多时候更直接的方式便是阅读代码本身，尤其是当你像我一样时不时要“抄”点代码的时候。由于最近我在Tmc中“大张旗鼓”地使用.NET中BCL的代码，因此也再次强调一下这部分经验。 "
    },
    {
        "Title": "NullableKey：解决Dictionary中键不能为null的问题",
        "Link": "/2012/12/nullablekey-nullable-key-in-dictionary.html",
        "BriefIntro": "众所周知，.NET中Dictionary的键不能为null，否则会抛出NullReferenceException，这在某些时候会显的很麻烦。与此相对的是Java中的HashMap支持以null为键，则方便许多。尽管null的确不是个好东西，但它既然已经存在，既然给我们造成了麻烦，我们就要想办法去解决它。实现一个自己的字典类自然可行，但要精心实现一个高效的字典并不是件容易的事情，例如BCL中的Dictionary.cs就有超过2000行代码。此外另一个容易想到的方法便是实现IDictionary接口，将大部分实现委托给现成的Dictionary类来完成。不过，这相比我在这里要提出的方法还是显得太复杂了。 "
    },
    {
        "Title": "不同泛型参数区分的独立类型",
        "Link": "/2012/12/isolated-types-by-different-generic-type-arguments.html",
        "BriefIntro": "相对于的Java的“类型擦除”来说，.NET中的泛型可谓是真正的泛型，这让我们可以有能力区分运行时所使用的不同的具体类型，大大增强了程序设计的性能和表现能力。谁会希望如Java一样，在找出符合条件的一万个int数值的时候，必须额外创建一万个Integer对象，导致堆上增加几百上千K的空间，还有一万个对象带来的GC压力？在运行过程中，.NET运行时会（在第一次使用时）为不同的值类型创建一份不同的代码，而让所有的引用类型共享同一份代码。不过无论执行的代码是否共享，不同具体类型参数的类型都是各自独立的，它们各有各的元数据，各有各的需方法表等等，因此它们的静态成员也是各自独立的。 "
    },
    {
        "Title": "如何生成一段Typoglycemia文本（解答）",
        "Link": "/2012/11/how-to-generate-typoglycemia-text-result.html",
        "BriefIntro": "关于“生成Tygolycemia文本”这个问题，已经有许多同学给了答案。不过，似乎大部分同学都只是以“完成”作为目标，并没有在解法的效率和内存占用上做过多考虑。其实对于这种非常简单的问题，给出一个解法并没有太大意义，而是要从中获取一些经验，否则就算反复解决这类简单的问题，得到的进步依然十分有限。事实上，这样一个高效的实现也可以十分清晰而简单，可以说并没有因为追求效率而引入任何复杂度。 "
    },
    {
        "Title": "如何生成一段Typoglycemia文本？",
        "Link": "/2012/11/how-to-generate-typoglycemia-text.html",
        "BriefIntro": "Typoglycemia是个新词，描述的是人们识别一段文本时的一个有趣的现象：只要每个单词的首尾字母正确，中间的字母顺序完全打乱也没有关系，照样可以正常理解。要不您来试下，如何从一段正确的文本生成一段Typoglycemia文本呢？其实这题还有后续，那就是把目标反一反：从一个前后确定中间乱序的单词，找到其原始的，正确的单词。自然，我们会得到一个长长的单词列表，十万个单词吧，并保证没有两个单词仅仅是中间几个字符的顺序不同。那么，您会如何设计一个数据结构，让我们可以快速的从一个乱序后的单词找到其正确形式呢？ "
    },
    {
        "Title": "如何让您的事件支持逆变",
        "Link": "/2012/11/how-to-make-your-event-support-contravariance.html",
        "BriefIntro": "在.NET里定义一个事件会需要一个委托类型，一般来说我们会使用.NET里自带的EventHandler类型，但它的定义其实有稍许缺陷。例如，如果您在自己的项目中编写了这样的代码，Resharper这样的工具便会提醒您“TEventArgs可以设为逆变”。让一个委托类型支持逆变只需要加上in关键字，但如果我们还是让C#编译器帮我们生成事件，则会由于Delegate.Combine方法并不支持逆变而导致失败。我们可以构造一个MulticastDelegateManager来解决这个问题，要不您也来试试看？不过请不要仅仅给出“思路”，千万要写下代码来，否则您的思路不说也罢。 "
    },
    {
        "Title": "为List<T>内部添加一个“删除多个元素”的方法",
        "Link": "/2012/11/add-a-remove-multiple-method-for-list.html",
        "BriefIntro": "不久前我在微博上提出一个问题：众所周知，.NET中自带的List<T>集合类型没有“删除多个元素”的方法，那么假如我们是.NET类库中List<T>的实现者，我们该如何为添加这么一个方法？请注意这里我们是“内部实现者”，因此肯定就是要提供一个高效的，并且尽可能通用的实现。其实这道题目没有标准答案，但是很容易判断出某一个实现好不好，对不对，有哪些缺陷等等。这题的确十分简单，但是会有不少细节方面值得考虑，所以我反复强调，光有思路是不够的，一定要写出代码来。 "
    },
    {
        "Title": "图灵访谈之三十六：以“玩”之名――赵拢老赵）专访",
        "Link": "/2012/10/interview-by-turing.html",
        "BriefIntro": "最近一个多月工作很忙，再加上之前参加许多活动，搞得身心俱疲，于是这段时间一直在休整，以看书和思考为主，连Wind.js也碰的不多，更别说博客了。接下来又要开始努力了，包括写博客，于是就从转帖这个访谈开始吧，也可以顺便继续修订一下。这是两个月前在图灵公司接受的采访，从一大早到下午，原本还担心无甚可讲，但最后只感觉时间不太够用。这篇采访中所有的内容都是我的真实想法，但后果就是又有更多人往我一举一动上贴“微软”标签了，很无趣，所以这年头说真话还不如跟着分析师评论员们说套话来的好。不过想贴标签就贴罢，爱咋咋滴，就像访谈里说的，大家都是聪明人，爱帖标签的人就算没标签也可以找出其他说法来。 "
    },
    {
        "Title": "讨论：一则并行聚合计算方案的设计",
        "Link": "/2012/09/discussion-design-of-a-parallel-aggregation-case.html",
        "BriefIntro": "最近的工作让我想到了一个对集合的元素进行并行聚合的案例，尽管这个需求还不存在，但最近却一直在我的脑海里挥之不去，尚未得出令人满意的结果。今天下班前我将这个问题辛苦地缩减为140字内的描述发到了微博上，得到了许多同学的回复，但可能是由于描述过于简单，得到的建议似乎都不能满足我的需求。于是在此我通过博客详细描述下这个问题的需求，还有我之前做过的尝试，这样讨论起来也可以更加有针对性一些。 "
    },
    {
        "Title": "我看面试时出（纯）算法题",
        "Link": "/2012/08/my-opinion-of-algorithm-interview.html",
        "BriefIntro": "今天早上一边出门一边在平板上读了左耳朵耗子的新文章《为什么我反对纯算法面试题》，略有想法。正逢外面暴雨如注，我就又回屋打开笔记本发了一些回复，特此整理一下。为了避免有人扭曲我的看法，我先声明我并不是反对这篇文章，相反我是基本同意其中的观点，只不过会加以一些补充，把其中一些我认为有些过头的地方按一按。您也可以认为我的观点是提交一些补丁，发了一些Pull Request（当然不是这种Pull Request）就行了。我当时吐的第一个槽，是说文章太鄙视搞学术研究的人，说他们是书呆子，不关心业务需求，认为那是应试教育不会思考的产物。这个么其实不是重点，只不过触到了我的学术研究情结罢了，接下来的才是我真正想说的。 "
    },
    {
        "Title": "由eval生成的代码效率真的很差吗？",
        "Link": "/2012/08/js-code-from-eval-benchmark.html",
        "BriefIntro": "昨晚跟一位Node.js专家讲解了我的Wind.js类库。之前那位仁兄对Jscex（Wind.js的前身）的看法是“就是不喜欢”，也在微博上对Jscex冷嘲热讽，于是我私信他说建议看一下文档了解一下Jscex。昨天我们的争论主要围绕在eval的使用上，他认为更好的做法是像CoffeeScript那样使用一个额外的进程监听改变，这样更方便。我说CoffeeScript这么做是因为它没有像Wind.js那样借助eval实现完全动态的运行时转化，且生产环境中不会出现eval。最后他坚持认为“eval就是有性能问题”，因此开发时也不应该使用，否则Wind.js为什么要提供预编译器？虽然最后不欢而散，不过我忽然也打算验证一下eval生成的代码效率到底会差到什么样的地步，于是便有了这次实验。 "
    },
    {
        "Title": "我对“语言之争”的看法：别随便拉我入场",
        "Link": "/2012/08/programming-languages-arguments-dont-pull-me-in.html",
        "BriefIntro": "最近又有语言之争了，不过没我什么事情。事情起因可以在酷壳最新一篇文章里看到，简单地说是关于C++的复杂度问题的。我对文章内容其实没有什么看法，但对这句话深有感触：“我对C++的感情有三个过程，先是喜欢地要死，然后是恨地要死，现在的又爱又恨，爱的是这个语言，恨的是很多不合格的人在滥用和凌辱它。”，我以为我想说，这“现在”的状态，就是我对“语言之争”的看法，“语言之争”被太多不合格人凌辱了。 "
    },
    {
        "Title": "写给《程序员》杂志社：那些你们早该知道的东西",
        "Link": "/2012/07/to-programmer-magazine-something-you-should-have-known-for-a-long-time.html",
        "BriefIntro": "最近我写了一篇文章投给《程序员》杂志社，是关于Jscex的内容，自然十分用心。我是一个对文章阅读体验有极高要求的人，这次既然涉及到我的文章，我自然会加倍小心，也主动配合编辑的工作，提供了高清截图和矢量PDF文件，但最终的结果还是让我十分愤怒，我的文章被毁了。即便编辑对此表示歉意，但于事无补。同时我发现《程序员》杂志社从编辑到排版人员，居然会不了解一些已经被广为接受的知识，甚至可以说是“常识”。为了让今后的文章可以“免遭毒手”，我当时立刻表示要为《程序员》杂志社单独写一篇文章补补课。我不知道国内的媒体在经历那么多年发展之后，为什么连一些基本的东西都做不好。从现在开始，我会努力盯住我所看得到的地方。 "
    },
    {
        "Title": "专访Jscex作者老赵（上）：缘由、思路及发展",
        "Link": "/2012/07/infoq-interview-jscex-author-1.html",
        "BriefIntro": "Jscex是很有特点的一个JavaScript异步编程类库，最近作者不但发布了其眼中的里程碑版（v0.6.5），还在“我们的开源项目”系列活动和阿里技术嘉年华上连续露脸，获得广泛关注。InfoQ专诚对Jscex的作者老赵做了正式的书面采访。在采访的上篇，老赵着重阐述对于Jscex类库设计的思考和心得。注：本文首发于InfoQ，出于阅读体验等方面考虑，现在重新发于博客。 "
    },
    {
        "Title": "Jscex与Promise/A那些事",
        "Link": "/2012/06/promise-support-in-jscex.html",
        "BriefIntro": "任何异步编程的类库要做的第一件事往往便是统一异步编程的模型，例如Jscex的异步模块自带一个类似于.NET中的异步任务模型。围绕统一的模型，开发人员便可以尽情地提供各种扩展，例如Jscex异步增强模块中的whenAll或whenAny一样。换句话说，假如要混用两种异步编程模型，往往需要将其中一种适配至另外一种，因此异步增强模块中也提供了fromCallback及fromStandard辅助，能够轻易地将最简单的（也是Node.js里使用的）两种异步函数接口绑定为异步任务。那么Promise/A呢？它也是种目前运用十分广泛的异步编程模型，Jscex对它有什么特别的支持吗？当然有，但方式有所不同，更为直接。 "
    },
    {
        "Title": "使用Node.js编写Shell脚本，暨Jscex 0.6.5版本发布",
        "Link": "/2012/06/nodejs-shell-jscex-0.6.5.html",
        "BriefIntro": "昨天不得不花时间做了点保护博客阅读体验的事情，但其实这篇才是我真正想写的。上个星期在香港出差，晚上的活动大都是喝酒，回到酒店便借着些许酒劲改进Jscex。如今虽然Jscex的开发工作并没有详细的时间计划，但我正在使用GitHub的Issues页面记录需要制作的任务点，因此每天都是朝着目标逐步前进的。按照计划，Jscex的0.6.5的主要目标是对Jscex的模块机制进行改进，统一辅助方法，并使用Node.js重新编写发布脚本。这些工作的目的都是为接下来的0.7.0版本作准备，它将会是Jscex在项目功能与质量，以及专业性上有重大突破的版本。 "
    },
    {
        "Title": "两年多来第二次更新博客功能",
        "Link": "/2012/06/the-second-blog-feature-during-the-past-two-years.html",
        "BriefIntro": "话说两年多前，我从博客园搬到了这个独立博客，用的是自己写的最简单粗糙的博客程序。这个博客系统十分简单粗糙，连文章编辑都是在文本框里直接显示HTML，甚至没有文章删除的功能――因为我不需要。这就是这个博客系统目的，只为我一个人服务，我够用即可，但也必须能让我够用。自己写的博客系统胜在高度的订制性，我可以把握页面任何一寸角落。直到现在，我的博客程序只增加过两次功能，其他都是对于样式方面的小修小补，可见我这人是多么的不思进取。从某个角度说，这两次更新的目的是相同的，都是为了抵御垃圾回复。这少数的令人恶心的人和事，就能不成比例地占用我的精力。 "
    },
    {
        "Title": "Jscex单元测试：喝着咖啡品着茶",
        "Link": "/2012/06/jscex-unit-tests-with-mocha-chai.html",
        "BriefIntro": "这段时间在香港出差，跟高帅富们一起工作。高帅富的办公室免费供应咖啡，放在壶里随你倒。茶叶也一样，立顿普洱茉莉自取。于是乎我每天也会喝一两杯提提神，尤其是午饭后，感觉还不错。技术人员似乎都挺热衷于这些饮料，也喜欢拿饮料来为项目取名，这方面最让人想到的例子估计就是Java了。这几天我为Jscex整理代码，准备发布其0.6.5版本，并为0.7.0做准备。这方面的主要工作之一便是为Jscex补充尽可能完整的单元测试。写完单元测试之后，我会感到自己是一个非常专业的程序员，突然就有了强烈的码农自豪感和自尊心。 "
    },
    {
        "Title": "Jscex预编译器及其DocPad插件",
        "Link": "/2012/06/jscex-pre-complier-and-docpad-plugin.html",
        "BriefIntro": "需求本身会是最好的动力。上个周末除了忙于构建Jscex主站以外，我还重新整理了Jscex的预编译器――或者说是AOT编译器。Jscex自带一个JIT编译器，配合eval可以在开发时避免额外的编译过程，这也可以说是Jscex的亮点之一。不过对于线上环境，一般都还是建议进行预编译，也就是将Jscex方法定义直接替换为目标代码。这么做的好处主要是为了降低部署时的脚本体积（摆脱对编译器的依赖所有代码加起来不到4KB），或是让异常情况下的错误定位变得容易（主要面向Node.js生产环境）。此外，为了便于编写文档，我还为DocPad开发了一个插件，用于对Jscex脚本进行预编译。 "
    },
    {
        "Title": "Jscex疯狂周末",
        "Link": "/2012/06/jscex-weekend.html",
        "BriefIntro": "这是个Jscex疯狂周末。从周五下班开始直到现在，我可谓一心扑在Jscex上――当然，早茶还是要的，健身房还是去的，买菜做饭拖地也是必不可少，但剩余时间基本都贡献给Jscex了。这段时间里，我研究了一些静态站点生成机制，并最后决定使用DocPad编写Jscex的文档站。然后便是捣鼓各种页面，重新编写快速入门示例等等。自然，还要它部署到GitHub Pages上，并启用jscex.info域名，还因为GoDaddy的域名服务器总是被墙，又把DNS解析交给了DNSPod。现在Jscex主站看上去是不是像样多了？ "
    },
    {
        "Title": "C#的设计缺陷（2）：不能以void作为泛型参数",
        "Link": "/2012/05/csharp-design-flaws-2-cannot-use-void-as-generic-type-parameter.html",
        "BriefIntro": "上一篇文章里我谈了C#中“显示实现接口事件”的限制（不过似乎有点打歪了），这一篇我们换个话题，再来谈泛型方面的限制。相对于Java的假泛型（编译型泛型，类型擦除）来说，真泛型是.NET的一个亮点。Anders Heisenberg多次提到.NET的真泛型有利于编程语言的进一步发展，可以带来更丰富的编程模型。不过.NET支持的泛型是一方面，具体到语言本身则又涉及到编译器的实现，而编译器的实现又收到运行时的限制等等，所以要谈语言的设计缺陷的“原因”就会变得很复杂。不过这里我们就把C#作为一个“成品”来对待，谈下它不允许以void作为泛型参数的“后果”，“原因”则略为一提，不做深究。 "
    },
    {
        "Title": "C#的设计缺陷（1）：显式实现接口内的事件",
        "Link": "/2012/05/csharp-design-flaws-1-explicitly-implement-interface-event.html",
        "BriefIntro": "其实使用C#这么多年，我时不时会遇到一些令人不爽的设计缺陷。这些缺陷大都是些限制，虽说无伤大雅，也很容易避免，但一旦遇到这些情况，总会令人心生不快，毕竟都是些无谓的限制。而且令人遗憾的是，虽说去除这些限制也不会带来什么问题，但我认为C#设计团队也基本不会去修复这些问题了，毕竟它们大都是些细枝末节。作为一名用C#的纯种码农，我突然一时兴起也要把这些设计缺陷记录下，也方便和大伙一起讨论下。那么这次就先从实现接口内的事件说起，当我们需要显式实现一个接口内的事件时，会发现我们必须提供add和remove访问器，这还会稍许影响到事件常用的使用模式。 "
    },
    {
        "Title": "编写一个“绑定友好”的WPF控件",
        "Link": "/2012/05/wpf-binding-friendly-user-control.html",
        "BriefIntro": "最近在搞WPF开发，这对我来说是个陌生的领域。话说回来，可能是缺少耐心的缘故，我现在学习新事物的方式主要是“看一些入门文档”，“看一些示例”，然后“猜测”其实现并摸索着使用。在很多时候这种做法问题不大，但一旦有地方猜错了，但在一段时间里似乎和实践还挺吻合的，则一旦遇到问题就会卡死。上周五我就被一个WPF绑定的问题搞得焦头烂额，虽说基本搞定，但还是想验证下是否会有更好的做法，特此记录一下，欢迎大家指正。 "
    },
    {
        "Title": "HTML Metro开发里的数据绑定（1）：WinJS.Binding.List",
        "Link": "/2012/05/metro-html-binding-1-winjs-binding-list.html",
        "BriefIntro": "前段时间接触了一些WPF开发方面内容，了解如何使用MVVM模式将界面与模型几乎彻底分离开来，只通过其强大的绑定功能连接两者，让人叹为观止。Win8的Metro开发支持使用XAML（配合C#，C++等语言）或是HTML（配合JavaScript），前者的控件和数据的绑定已经相当完备，而后者一直没有一个标准的模型。之前我也简单了解过如Knockout这样的绑定支持与MVVM模式实现，理论上说也完全可以在Metro开发里使用，但其实Metro开发本身也已经提供了一些内置的绑定支持，基本对应于XAML/C#开发里涉及到的ObservableCollection与INotifyPropertyChanged。 "
    },
    {
        "Title": "关于C#中async/await中的异常处理（下）",
        "Link": "/2012/04/exception-handling-in-csharp-async-await-2.html",
        "BriefIntro": "上一篇文章里我们讨论了某些async/await的用法中出现遗漏异常的情况，并且谈到该如何使用WhenAll辅助方法来避免这种情况。WhenAll辅助方法将会汇总一系列的任务对象，一旦其中某个出错，则会抛出“其中一个”异常。那么究竟是哪个异常？如果我们要处理所有的异常怎么办？我们这次就来详细讨论await操作在异常分派时的相关行为。 "
    },
    {
        "Title": "关于C#中async/await中的异常处理（上）",
        "Link": "/2012/04/exception-handling-in-csharp-async-await-1.html",
        "BriefIntro": "在同步编程中，一旦出现错误就会抛出异常，我们可以使用try…catch来捕捉异常，而未被捕获的异常则会不断向上传递，形成一个简单而统一的错误处理机制。不过对于异步编程来说，异常处理一直是件麻烦的事情，这也是C#中async/await或是Jscex等异步编程模型的优势之一。但是，同步的错误处理机制，并不能完全避免异步形式的错误处理方式，这需要一定实践规范来保证，至少我们需要了解async/await到底是如何捕获和分发异常的。在开发Jscex的过程中，我也在C#内部邮件邮件列表中了解了很多关于TPL和C#异步特性的问题，错误处理也是其中之一。在此记录一下吧。 "
    },
    {
        "Title": "使用Jscex改进Node Club（4）：改写首页",
        "Link": "/2012/03/jscexify-nodeclub-4-jscexify-home-page.html",
        "BriefIntro": "上次我们分析了Node Club的首页实现，了解了它的功能以及目前的实现方式。这次我们便来使用尝试使用Jscex来改进首页的逻辑。作为一个面向开发人员的工具，Jscex除了隐藏必要的复杂度之外，还要让目标程序“可控”，无论是串行、并发还是逻辑表达――Jscex使用JavaScript语法，保证了程序逻辑的灵活与可控，尽可能地避免出现Leaky Abstraction。EventProxy的确提供了一种“完全并发”的抽象，但是对于需要“可控并发”，或是“串行执行”的逻辑和场景便显得无能为力了。 "
    },
    {
        "Title": "使用Jscex改进Node Club（3）：分析首页实现",
        "Link": "/2012/02/jscexify-nodeclub-3-home-page-implementation.html",
        "BriefIntro": "上次我们已经将Jscex成功地引入项目，现在便可以正式开始关注Node Club的实现了。Node Club中存在大量基于回调的JavaScript代码，颇有无从下手的感觉。既然如此，我们便随便挑一个，从首页入手吧！首页的目标其实很简单，加载几部分数据组成一个对象，再交给模板引擎生成HTML代码并输出。Node Club使用EventProxy类库来尝试解决大量异步函数的嵌套问题，但是在我看来，在这里使用EventProxy并没有带来太多的益处，从简化编程的角度来说，效果十分有限。 "
    },
    {
        "Title": "使用Jscex改进Node Club（2）：引入Jscex类库",
        "Link": "/2012/02/jscexify-nodeclub-2-import-jscex.html",
        "BriefIntro": "之前我们已经将Node Club在本地运行起来了，接着我们便来引入Jscex类库，为常用异步方法扩展出Jscex版本，并试着编写一些最简单的Jscex代码。在编写Jscex方法中，我们无需操作回调函数，只要在异步点上使用$await进行“等待”即可。我们也无需显式地处理错误，因为一旦出现错误便会抛出异常，异常如果没有被某个try…catch捕获到，则会顺着调用路径一路向上传递，直到被我们的代码或是系统捕获为止。Jscex将简单易用的传统编程模式与实践重新带回异步编程中，做到“同步编写，异步执行”的效果。这就是Jscex诞生的意义。 "
    },
    {
        "Title": "使用Jscex改进Node Club（1）：运行Node Club网站",
        "Link": "/2012/02/jscexify-nodeclub-1-prepare-nodeclub-website.html",
        "BriefIntro": "一直想做个相对完整的项目来演示下Jscex的使用，可惜缺少创意和精力，一直没能实现。前几天看到Node Club将其网站开源了，不禁让我十分欢喜。Node Club网站是个真实案例，复杂度适中，既是Jscex的典型使用场景，又能避开我不擅长的网页样式设计和制作，简直是一个再合适不过的基础样板了。周末我大致看了下代码，也试着将几个部分使用Jscex改进了一下，效果也十分显著，于是打算写作一个系列指引，希望可以对Jscex类库的推广有所帮助。在此第一篇，自然是最基本的环境建设开始说起。 "
    },
    {
        "Title": "增强Jscex目标代码可调试性：已包含输入代码",
        "Link": "/2012/02/jscex-debug-improved-target-code-contains-source-now.html",
        "BriefIntro": "经过了糜烂堕落的春节长假，Jscex的改进和推广又该步入正轨了。尽管使用Monad形式的目标代码已经比状态机展开要易读许多，甚至可以直接翻译回原始代码，但总还是有朋友被“编译”两个字和略显复杂的代码吓退。因此我最近一直在修改Jscex的代码生成器，即将发布的0.6.0版本的编译器会在目标代码已经包含了原始的输入代码，并且和目标代码行行对应。如今在调试Jscex的代码时已经可以把注意力更多放在原始代码上，而不用肉眼去识别相对复杂的Monad代码了。 "
    },
    {
        "Title": "一份用于学习单元测试的案例需求（实现）",
        "Link": "/2012/02/a-case-requirement-to-practice-unit-testing-or-tdd-implementation.html",
        "BriefIntro": "终于把这份实现写完了，比想象中要花时间，尤其是为了可测试性而增加的代码结构。我并没有使用TDD来开发这个类库，依然是先写代码，再写单元测试，测试代码也只关注了代码主体，没有刻意去测试边界情况。一部分原因是其中都是内部实现，可以把握住输入，令一部分原因是这段实现主要是各种交互，而没有复杂的业务逻辑。我个人满足于单元测试而不是测试驱动开发，但如果您是使用测试驱动开发（TDD）甚至传说中的BDD来实现这个方案，那就更好不过了。 "
    },
    {
        "Title": "使用Mono.Cecil解决无法Mock非虚方法和密闭类的问题",
        "Link": "/2012/01/make-things-mockable-with-mono-cecil.html",
        "BriefIntro": "之前我在微博上抱怨单元测试会让代码中的接口数量激增，有些同学回复说，这是因为在C#里只能Mock接口，如果是Java的话便可以Mock普通类。不过其实在Mock实现方面，C#和Java没有任何区别，只不过C#的成员默认“非虚”而已，因此无法使用继承后重载的方式实现Mock行为。我不喜欢默认的虚方法，但我也十分不愿意为了“单元测试”这个与具体功能无关的角度而破坏设计本意。幸好，我们可以用Mono.Cecil在单元测试执行之前，将目标程序集里的所有方法修改为虚方法，并去除所有密闭标记，这样遍可以轻而易举的解决无法Mock的问题了。 "
    },
    {
        "Title": "求助：一份用于学习单元测试的案例需求",
        "Link": "/2012/01/a-case-requirement-to-practice-unit-testing-or-tdd.html",
        "BriefIntro": "一直熟知单元测试的重要性，也算是了看了几本这方面的经典书籍，但是真开始上手的时候总会遇到各种各样的坎。例如，为什么总感觉自己的单元测试之间有较多的重合，为什么每个单元测试都要准备那么多依赖？有的说法是，这意味着代码设计不够好，单元测试也有问题，或者说没有使用TDD的缘故，等等。但是，现实开发过程中在这方面也颇感无力。前段时间在微博上咨询了几个问题，感觉收获不大，这次干脆整理一份需求，仔细认真向高手学习一下代码设计，单元测试，甚至测试驱动开发的方式吧。我也会准备一些礼物来感谢一部分同学的帮助。 "
    },
    {
        "Title": "Node.js中相同模块是否会被加载多次？",
        "Link": "/2011/12/same-node-module-load-multiple-times.html",
        "BriefIntro": "JavaScript的包管理一直是个软肋，但既然它流行了，既然人们想要用它做大事了，就要开始为它制定一些模块的约定。Node.js使用了CommonJS模块机制，最近在InfoQ上也有一篇文章讨论了这方面的问题。这篇文章提到Node.js在载入模块时，如果之前该模块已经加载过则不会有重复开销，因为模块加载有缓存机制。这篇文章是我初审的，当时也正好在思考Jscex在Node.js使用时的模块化问题，但研究了它的规则之后，我发现在某些情况下还是可能加载多次。现在我们便来分析这个问题。 "
    },
    {
        "Title": "受禁锢的异步编程思维",
        "Link": "/2011/12/the-stuck-mind-of-asynchronous-programming.html",
        "BriefIntro": "最近一直在努力推广，补充了很多中文文档和示例，因此博客上都已经有两篇文章有了“上”而没有“下”，即使最复杂的图示也已经绘制完毕。在推广Jscex的过程中，我发现有个比较明显的问题是，许多使用JavaScript的程序员已经习惯旧有的操作方式，甚至推崇一些据说很漂亮“模式”。但其实跟许多GoF模式是在修补OO语言的不足类似，很多异步模式都只是因为JavaScript语言特性不足而设计出来的“权宜之计”。我们在传统JavaScript编程环境下并没有其他选择，单纯地认为这是“美”，说实话只不过是一种安慰罢了。 "
    },
    {
        "Title": "Jscex正式发布至npm",
        "Link": "/2011/12/jscex-officially-released-to-npm.html",
        "BriefIntro": "之前一直不敢将Jscex发布至npm上，因为有些问题还没有完全拿定主意，例如“取消”任务的模型。一个异步任务一定是需要取消功能，尽管这个模型不一定需要直接定义在Jscex里。但是我还是为Jscex提供了一个统一的标准化的取消模型，一是易于使用，二是提供模型这个之后，API在设计时可以有更多表现力（例如，现在的task的status可能是canceled了）。上周末我实现这个模型（其实也就十几二十行代码），昨天我又修改了模块的加载方式，使其支持CommonJS规范。在发布到npm之后，现在可以说Jscex已经正式对外公开了！ "
    },
    {
        "Title": "尾递归对时间与空间复杂度的影响（上）",
        "Link": "/2011/11/does-tail-recursion-improve-time-and-space-complexities-1.html",
        "BriefIntro": "以前我也在博客上简单谈过“尾递归”及其优化方式方面的话题。前几天有同学在写邮件向我提问，说是否所有的递归算法都能改写为尾递归，改写成尾递归之后，是否在时间和空间复杂度方面都能有所提高？他以斐波那契数列为例，似乎的确是这样的情况。我当时的回答有些简单，后来细想之后似乎感觉有点问题，而在仔细操作之后发现事情并没有理论上那么简单，因此还是计划写篇文章来讨论下这方面的问题。 "
    },
    {
        "Title": "挖坟鞭尸：当年Sun公司的白皮书《About Microsoft “Delegates”》",
        "Link": "/2011/11/sun-whitepaper-about-microsoft-delegates.html",
        "BriefIntro": "这是一桩当年的Sun公司与Java的旧事，还要追溯到C#还没出现，微软还在搞J++的时代。这篇著名的白皮书便是《About Microsoft “Delegates”》，其中列出了Sun眼中的Delegate的多个缺点。最后，在白皮书里信誓旦旦地写到：“Bound Method Reference并不是语言发展的正确道路”。我的感觉是：不谈Java语言设计者的水平如何，至少这篇白皮书的作者，在语言设计的能力或品味上几乎落后了Anders Hejlsberg十年。从我之前翻译过的一篇文章来看，Anders一直扮演着指引语言发展方向的作用，这也是为什么C#在这十年的发展能比Java要健康得多的主要原因之一。 "
    },
    {
        "Title": "老赵书托（4）：浪潮之巅（内含牢骚，不喜勿入）",
        "Link": "/2011/11/recommended-reading-4-langchaozhidian.html",
        "BriefIntro": "我是一个码农，一个很彻底，很标准的码农，自认为比我遇到过的绝大部分技术人员要码农得多。我喜欢搞技术，玩技术，不喜欢搞管理，搞人，或是搞产品等等。我是死脑筋，凡事都要想很多遍，想个明白，想不明白就不表态。我不喜欢猜测，不喜欢无法验证的事物，因此我成不了那种常见的，著名的，经常指点江山的分析师。每次有人问我对某某事物未来的看法，十有八九我只会婉言谢绝。其实照我的个人口味，我是不太会对《浪潮之巅》这中类型的书感兴趣的，但之前在网上看过谷歌黑板报上的连载，感觉不错，因此也去“搞”来一本品读一番。 "
    },
    {
        "Title": "使用Mono.Cecil辅助ASP.NET MVC使用dynamic类型Model",
        "Link": "/2011/09/aspnet-mvc-dynamic-model-mono-cecil.html",
        "BriefIntro": "这也是之前在珠三角技术沙龙上的示例之一，解决的是在ASP.NET MVC使用dynamic类型Model时遇到的一个真实问题。C# 4编译器支持dynamic类型，因此在编写页面模板的时候自然就可以把它作为视图的Model类型。表现层的需求很容易改变，因此dynamic类型的Model可以减少我们反复修改强类型Model的麻烦，再配合匿名类型的使用，可谓是动静相宜，如鱼得水。不过，如果把一个匿名类型直接作为Model交给视图去使用，在默认情况下会抛出异常。我们可以用Mono.Cecil来改变这一情况。 "
    },
    {
        "Title": "在.NET平台下使用C#交互式控制台（上）：简介",
        "Link": "/2011/09/port-csharp-repl-from-mono-1-introduction.html",
        "BriefIntro": "上周日在广州的珠三角技术沙龙上，我的演讲题目是“Mono之于.NET程序员”。Mono一直是我十分喜爱的产品，我也一直关注它的发展，总有很多人用各种方式对它进行FUD，甚至是.NET程序员自己。这其实跟程序员使用盗版一样，自掘坟墓，是种无比愚蠢的行为。在演讲中，我提到.NET程序员可以如何从Mono项目中得到帮助，现在便以C#交互式控制台为例，演示下在.NET平台下使用Mono项目的常见方式。 "
    },
    {
        "Title": "谈谈年度最佳代码“不管你们信不信，反正我信了”",
        "Link": "/2011/08/from-the-code-of-no-matter-you-believe-it-or-not.html",
        "BriefIntro": "最近有段十分流行的代码，是从江湖传闻“身怀八蛋”的铁道部发言人王勇平同志的一句名言：“不管你们信不信，反正我信了……这是生命的奇迹……它就是发生了”所引申出来的。这段代码虽然只是在调侃，但是围绕这段代码也产生了一些讨论（如代码风格，编程规范等等），在此顺手记录一下，就当无聊罢。 "
    },
    {
        "Title": "基于Node.js、Express和Jscex开发的ToDo网站示例",
        "Link": "/2011/07/nodejs-express-jscex-demo-website-todo.html",
        "BriefIntro": "Jscex的主要使用场景是“JavaScript异步编程”，并不限制是跑在浏览器还是服务器端。最近Node.js很火热，也刚发布了原生的Windows版，不少同学也用它来做一些网站这样的小程序。目前用Node.js开发网站最著名的框架是Express，使用起来也是比较容易的。前段时间看到CNodeJS社区的一篇文章，某同学将一个Python写的ToDo列表网站移植到了Node.js上，我为了推广Jscex，就fork了这个项目，将其修改为基于Jscex的版本，大伙儿可以来比较一下。当然这个网站过于简单，我也正在寻找更合适的项目。 "
    },
    {
        "Title": "从今开始远离纸版图书",
        "Link": "/2011/07/get-away-from-paper-books.html",
        "BriefIntro": "纸版图书的历史实在太长了，似乎也已经看得到它被淘汰的那一天。这几天在为去深圳做准备，手边许多技术图书都成了大问题。搬去深圳会大动干戈，况且这些书基本也都只是偶尔翻阅一下，不太可能再认真读起。但如果把它们留在上海，那跟空置也没什么区别。以前我有个习惯，看到经典的书，在看完电子版或国内引进版之后都会买本英文原版的来“收藏”，现在已经“幡然醒悟”，之前也已经转让了一部分。现在除了一部分书，都打算出手了。这里开了个书单，感兴趣的同学可以各取所需。 "
    },
    {
        "Title": "IBM面试记",
        "Link": "/2011/07/ibm-interview.html",
        "BriefIntro": "话说其实我很久没有被正经面试过了。一开始去微软实习自然经过了经典的笔试和几轮面试，然后去了朋友的创业公司并立即被激动集团收编――没有面试，接着从激动集团去合伙创业――没有面试，然后被朋友推荐去盛大创新院――面试更像是讨论及聊天。由于长久缺乏职场磨练，我虽然对自己能力有一定能力，但也怀疑自己如果通过“正经渠道”去面试的话能有多少机会成功。这次面试IBM终于算是过足了面试瘾，记录一下。 "
    },
    {
        "Title": "两则.NET高级技术人员的招聘信息",
        "Link": "/2011/06/two-job-descriptions.html",
        "BriefIntro": "几小时前我在微博上发布了一条消息，表示我即将加入一家外企，而且完全是大家耳熟能详的IT公司之一，而且这个公司会让大家感到“意外”。于是大伙有猜微软的，也有猜Google，Apple，Oracle，HP等等，当然也有猜对的童鞋。在此公布答案，它便是传说中的IBM公司，我将在那里继续我的.NET程序员之旅。同时，我也希望可以找到一位同学可以帮助我目前在盛大创新院的项目继续良好地发展下去。 "
    },
    {
        "Title": "匿名类型的硬伤：围绕this的成员捕获策略",
        "Link": "/2011/06/java-anonymous-method-closure-scope-this.html",
        "BriefIntro": "时不时听到一些C#程序员说，希望在C#里出现像Java匿名类一样的特性。以前我也觉得Java里的匿名类是个不错的特性，C#应该吸取进来。不过前段时间我仔细地理解了Java语言规范中关于内部类、匿名类的部分之后，一下子就被恶心到了。恶心过后，我忽然也意识到有些问题的确也是硬伤，也不能指责Java设计者的“品位”。例如，现在我想要谈的关于匿名类中this使用的问题――如果C#没法漂亮地实现这个特性，我宁愿它继续保持现状。 "
    },
    {
        "Title": "JavaScript：假如default不是switch的最后一项",
        "Link": "/2011/05/javascript-when-break-is-not-the-last-choice-of-switch.html",
        "BriefIntro": "话说大家对于switch语句应该再熟悉不过了，各种类C语言都不例外，JavaScript自然也是如此。switch的逻辑很简单，根据switch内容的值执行对应的case项，否则执行default项即可。但是不同的语言在具体一些细节上面的处理却是不同的。例如在JavaScript里，每个case项都可以没有break，于是语句便会顺延到下个case或是default里面去――但某些语言设计者认为这种特性容易造成代码理解上的偏差，因此比如在C#里便要求每个非空的case都要有个break。那么再来一个细节问题：如果default之后还有case，那么会出现什么样的情况？如果default里没有break呢？ "
    },
    {
        "Title": "上周末Jscex项目介绍的幻灯片",
        "Link": "/2011/05/jscex-write-sexy-javascript-slide.html",
        "BriefIntro": "上周末，在风景秀丽的浙江大学校园内，举行了NodeParty杭州站的活动。我在活动上结合Node.js项目对Jscex进行了简单介绍，包括其设计目的，设计原则，使用方式，高级模式，组成部分等等。在场的许多朋友也提出了不少问题，我也一一作了解答或是演示。总体感觉还算不错，毕竟是亲手编写的项目，对其各方面还是了然于胸的。在此发布演讲用的幻灯片，希望能给不在现场的同学带来一些帮助。 "
    },
    {
        "Title": "浅谈Jscex的$await语义及异步任务模型",
        "Link": "/2011/05/jscex-async-task-model-and-await-semantic.html",
        "BriefIntro": "从某些程度上说，Jscex的是提供了“新语言”，只不过这种新语言和JavaScript长的一模一样，最多添加了一个$await操作这个语义而已。其他方面，JavaScript的各种语法都可以让Jscex编译，所以它基本可以说是个完备的方案。之前有朋友提出疑问，说$await只能执行单个任务，那么岂不是多个任务之间就出现了先后依赖关系？假如有三个任务：A和B可以并行，但C依赖前两者，ABC如果串行的话，系统的总耗时便不够理想了。其实Jscex并没有这种限制，因为它的任务模型和$await语义简单且具有深厚的理论基础，灵活、丰富而统一。 "
    },
    {
        "Title": "浅谈Jscex编译结果的优化",
        "Link": "/2011/05/jscex-compiled-code-optimization.html",
        "BriefIntro": "Jscex的核心是一个JavaScript语言到Monadic形式的编译器。从理论上说，这种编译规则十分简单，要写一个能够“正常运行”的编译器很容易。但是“正常运行”不代表足够优化。优化不当，会导致生成的结果中产生太多函数及闭包，对性能产生负面影响。在Jscex的早期原型中，从AST生成最终代码的逻辑比较简单，只做了一些基础优化。后来重构了编译器，减少了不必要的代码。而上周我提交了更新，实现了更复杂而有效的优化策略。如今的Jscex编译器部分应该已经足够稳定，剩下的便是类库方便的发展了。 "
    },
    {
        "Title": "Jscex编译器更新：已支持嵌套Jscex函数",
        "Link": "/2011/04/jscex-compiler-update-support-nested-jscex-function.html",
        "BriefIntro": "Jscex编译器更新了。之前的编译器并不会将一个Jscex函数内部的其他Jscex函数代码一并展开，这导致内嵌的Jscex函数会在外部函数调用时反复编译，性能开销较大；不过更重要问题，可能是AOT编译后的代码无法彻底解除与编译器的依赖。嵌套Jscex函数是否合理是一回事儿，使用者可以不去这么做，但是编译器本身还是该支持的。这也是Jscex编译器改进计划中的重要一步。 "
    },
    {
        "Title": "SNDACode及Jscex项目中文站",
        "Link": "/2011/04/jscex-chinese-repository-sndacode.html",
        "BriefIntro": "之前有朋友问我，为什么Jscex只有英文站却没有中文的。其实原因很简单：国际化的项目势必更容易推广，而且国内看的懂英文的同学肯定比懂中文的外国人多嘛。而且我也不希望在一个源码库里维护两种语言的说明，这样对于浏览者也会造成误解――但更不希望维护两个源码库。因此我理想中的情况便是：某个站点可以完整地同步我的源码库，并提供一个供我放置文档的地方。最近我的同事搞了一个SNDACode站点，公开了部分盛大员工的开源项目。虽然远不如GitHub等类似站点来的完备，但恰好能满足我的需求，我自然很乐意将它作为Jscex的中文站点。 "
    },
    {
        "Title": "Jscex使用BSD授权协议正式发布",
        "Link": "/2011/04/jscex-released-under-bsd-license.html",
        "BriefIntro": "这次打算把Jscex好好搞一下了，其实很少会有技术方面的障碍能“轮到”我们去突破，但我觉得Jscex的确有机会，HTML 5、Node.js各个都是红火的玩意儿。前几天我花了两个晚上用半生不熟的中式英语写了一篇自认为比较完整的说明文字放到了Github上的项目首页上，没想到几个小时后便收到了StratifiedJS（一个与Jscex目标有些类似的项目）作者的邮件，提到了一些关于StratifiedJS的事情。我向他咨询了StratifiedJS的某些细节问题，也向他简单介绍了Jscex的实现原理。如今Jscex已经使用BSD授权协议正式发布（中文站也会在近期推出），再进行一些细节上的优化便要开始作推广了。 "
    },
    {
        "Title": "Jscex项目现状：UglifyJS解析器及AOT编译器",
        "Link": "/2011/04/jscex-status-uglifyjs-parser-and-aot-compiler.html",
        "BriefIntro": "Jscex项目是我为了简化JavaScript异步的一个类库，支持任意JavaScript（ECMASCript 3）引擎。Jscex小巧而强大，可以极大地改善前端的AJAX及动画等场景的编程体验，同样也可以用在node.js进行服务器开发。从产生Jscex的想法到现在也有几个月的时间了，也一直想设法进行推广。在思考过程也发现了它在实际生产中可能会遇到的问题，于是前两个星期的主要工作，便是针对这些问题进行优化。首先我将Jscex的JavaScript分析器从Narcissus换成了UglifyJS，并基于node.js开发了一个简单的AOT编译器。接下来我也打算写个稍微详细一点的介绍，然后在国外社区看看反响如何。 "
    },
    {
        "Title": "通过定义常量控制Closure Compiler的行为",
        "Link": "/2011/04/use-define-annotation-in-closure-compiler.html",
        "BriefIntro": "上一篇文章里我提到，在进行Closure Compiler压缩之前可以对代码进行一些预处理，这样可以得到更好的效果。在回复中有朋友提到可以使用一些Annotation（标记），例如加上@export，然后使用--generate_export，便可以保留需要的那些变量名。不过经过实验还是没有得到预期的效果，所以使用标记来“指导”高级压缩行为依旧是一个不太可行的做法。不过有个标记与我的设想一直，那就是使用@define来“定义一个常量”，然后在编译（压缩）时对其进行覆盖。这为一些压缩需求提供一种更直接的控制方式。 "
    },
    {
        "Title": "使用Google Closure Compiler全力压缩代码",
        "Link": "/2011/04/compress-javascript-with-google-closure-compiler-in-advance-mode.html",
        "BriefIntro": "JavaScript压缩代码的重要性不言而喻，如今的压缩工具也有不少，例如YUI Compressor，Google Closure Compiler，以及现在比较红火的UglifyJS。UglifyJS的出名是由于它代替Closure Compiler成为jQuery项目的压缩工具。根据我的实测，jQuery Core的代码使用UglifyJS压缩后（节省62.5%）的确要比Closure Compiler压缩后（节省57.53%）更小一些。很显然，这是因为UglifyJS的压缩策略比Closure Compiler更“聪明”一些。我这里用了“聪明”而不是“激进”，是因为“激进”带上了一丝负面的意味――就好比Closure Compiler的“高级”优化方式。之前与UglifyJS相比的是Closure Compiler的“简单”优化方式，它们都是“安全”的，而Closure Compiler的“高级”优化几乎100%会破坏您的代码，因此它提出了各种“激进”的手段去“破坏”您的代码，以此达到压缩的目的。这种手段是把双刃剑，如果您能掌控它的压缩规则，则代码便可以压缩至极小。 "
    },
    {
        "Title": "UglifyJS有个不错的JavaScript解析器",
        "Link": "/2011/04/uglifyjs-has-a-good-javascript-parser.html",
        "BriefIntro": "我一直在为Jscex寻找好用的JavaScript解析器，之前我用的是Narcissus，也写过相关文章。不过可惜的是，Narcissus使用了SpiderMonkey的扩展，因此它并不是用ECMAScript 3实现的，无法在IE 8等浏览器中使用。目前Jscex使用的是NarrativeJS中旧版的Narcissus，但是我并不喜欢它输出的AST结构，使用中也发现高级功能里的一些bug，有些食之无味弃之可惜的感觉，而改写新版Narcissus又必须大动干戈。最近我接触到了UglifyJS，发现它的解析器相当不错，性能也比Narcissus高出许多，在此介绍给大家。 "
    },
    {
        "Title": "模拟HTML表单上传文件（RFC 1867）",
        "Link": "/2011/03/html-form-file-uploading-programming.html",
        "BriefIntro": "如今使用HTTP协议定制API已经是十分常见的事情，在普通的GET和POST请求中传递些参数估计人人都会，但是如果我们需要上传文件呢？如果只是传递单个文件，那么将数据流POST给服务器端即可。但如果需要上传多个文件，或是在文件之外需要附带一些信息，那么又该怎么做呢？之前我遇到过一些朋友是这么打算的，他们说，不如就把文件流转化为文本，然后把它当作一个普通的字段传递。这么做自然可以“实现功能”，但缺点也很多。首先，将二进制流转化为文本会增大体积（例如最常见的BASE64编码会增大1/3的数据量）；其次，既然互联网上存在相关的协议，又为何要自定义一套规则呢？其实这便是《RFC 1867 - Form-based File Upload in HTML》，它是我们用HTML表单上传文件时使用的传输协议，虽然十分常用，但似乎了解它的人并不多。 "
    },
    {
        "Title": "道理人人有，就看怎么说",
        "Link": "/2011/03/mac-windows-valuable-arguments.html",
        "BriefIntro": "前几天猛鸟兄作为在使用Mac OS X时跌了个跟头，他之前是长期的Ubuntu用户，最近也买了台Mac。情况是这样的：OS X在文件夹复制（包括移动）的时候，如果目标地方也出现了同名文件夹，则OS X的策略是“替换（Replace）”，而Windows和*nix下cp命令的策略则是“合并（Merge）”。前者相当于完全删除了重名文件夹，而后者则是把其中的文件合并。对于习惯了后者的人来说，一没看清楚前者的提示，于是就丢失文件了。我当时也遇到过这情况，不过估计猛鸟兄不如我能忍，于是在吐槽推里fuck了乔教主，果不其然引发了各方争论。今天丁宇同学将他的观点整理为一篇文章，表示OS X的做法更合理，对于这个说法我不敢苟同。现在先提一下这个问题，再引出真正想说的内容。 "
    },
    {
        "Title": "使用Jscex实现排序算法动画",
        "Link": "/2011/03/sorting-animations-with-jscex.html",
        "BriefIntro": "用动画来观察排序算法是一件很酷的事情，例如有人便为各种排序算法提供了动画效果。只可惜这些效果都是实现准备好的gif图片，并非由代码写成。在大部分平台上编写这样的程序并没有太大困难，只要在绘制出图形之后短暂地阻塞线程就行了。可惜，在JavaScript中我们只能“一蹴而就”，要暂停的话，只能使用setTimeout进行回调了。不过，这也正是Jscex的用武之地，用Jscex编写的代码需要“暂停”，只需要简单地调用sleep异步方法，一切都很直接。 "
    },
    {
        "Title": "我在面试.NET/C#程序员时会提出的问题",
        "Link": "/2011/03/my-interview-questions-for-dotnet-programmers.html",
        "BriefIntro": "说起来我也面试过相当数量的.NET（包括C#，后文不重复）程序员了，有的通过电话，有的面谈。后来发现，其实提的问题来来回回也就那么几个。这些问题有的已经有十年历史了，至少也有三年。我想对于一个“不错”的.NET程序员来说，在简单的提示下绝大部分问题应该可以“对答如流”。可能您也会觉得这些太细节，真要追究起来似乎也大都不是必须的，无视这些照样可以写程序，做网站，赚工资，但是我不会满足于成为（包括招聘）这样的程序员，暂时也懒得解释掌握这些东西的益处和重要性。 每个人都有自己的看法， 一切就看您自己的选择了。 "
    },
    {
        "Title": "既要马儿跑的快，又要马儿不吃草",
        "Link": "/2011/02/there-is-always-a-trade-off.html",
        "BriefIntro": "这年头技术社区里的一些观点让我很看不惯，例如动辄就说什么什么要被淘汰，什么什么要被替换。比如微软出个F#，就以为它要淘汰C#了，但C#和VB.NET不都已经共存很多年了吗？在我看来，明明是“多了一个选择”，绝对是好事情，又没逼你学，也没人说不学就落伍（不学VB.NET您就不觉得落伍吗？）。ASP.NET MVC也是如此，但非要有人说ASP.NET WebForms要被淘汰了，却“选择性忽视”至今WebForms还在不断成长的事实。MVC和WebForms都是好东西，各有千秋，两种选择罢了，仅此而以。既然想说WebForms一无是处，就老老实实用MVC模型写程序。 "
    },
    {
        "Title": "在MongoDB中实现乐观并发控制",
        "Link": "/2011/02/optimistic-concurrency-control-in-mongodb.html",
        "BriefIntro": "说起来，自从接触了MongoDB以后，我在大小项目中就再也没有接触过关系型数据库了。性能倒不是什么主要问题，主要是方便，例如我可以在MongoDB中直接保存数组，然后把其中的元素当作查询条件，而在关系型数据库中，则需要使用额外的表格，然后再JOIN等等。当然，在MongoDB中很难进行JOIN，于是对于某些场景下会略显麻烦，但在记忆中我似乎真没什么束手束脚的情况。这方面我还没有仔细分析，可能MongoDB支持保存复杂对象会有所帮助吧。以上都是废话，这里我简单谈一下如何在MongoDB中实现乐观并发控制。当然加入您对MongoDB的功能都有所了解，那么这种做法也是十分显而易见的。 "
    },
    {
        "Title": "我们不是牛人，所以还是老老实实跟着兴趣走吧",
        "Link": "/2011/02/piano-life-and-interests-driven-practice.html",
        "BriefIntro": "前几天周筠老师写了篇博客，她认为兴趣十分重要，没有兴趣很难做成事情。我对此十分同意，有亲身经历为证。更值得一提的是，这个亲身经历和技术或是职业方面的关系真不大，我对许多技术都感兴趣，一时还真难找出对比反差明显的东西。这次来说说我近几个月找到――或者说“找回”的兴趣，弹钢琴。在看来，这对我来说实在是“兴趣”的最佳例证了。 "
    },
    {
        "Title": "分清“语言/规范”以及“平台/实现”，以及跨平台.NET开发",
        "Link": "/2011/01/be-clear-with-language-spec-and-platform-implementation-dotnet-cross-platform.html",
        "BriefIntro": "在许多年前，“语言”就等同于“平台”，例如C，C++以及最早的Ruby和Python等等。但是随着技术发展，出现了一些通用的平台，例如.NET和Java，逐渐这些平台上的语言也越来越多。再后来，某些语言在不同平台上的实现也越来越多，事情也变得有些复杂。技术在发展，但是从目前社区的讨论中，我发现许多朋友的观念还没有跟上。简单地说，如今的观念，一定要从“语言即平台”切换成“语言及平台”，当分清“语言”和“平台”这两个不同事物之后，许多问题才能讨论地清楚。而且，这点对于.NET程序员来说尤为重要，因为C#语言可以说是目前“平台”、“实现”最为广泛的“语言”之一了。 "
    },
    {
        "Title": "“花钱”购买App Hub Membership终于成功了",
        "Link": "/2011/01/paid-for-app-hub-membership.html",
        "BriefIntro": "作为一个身在天朝的开发人员，要及早使用国外的服务总是一件杯具的事情，注册Windows Phone 7的App Hub Membership也不例外。不幸中的万幸，我工作于盛大创新院，这也是个奇妙的地方，身边的同事就有美国人，在他的帮助下，从提及注册信息到审核成功也只用了6、7个小时。说起来美国人在这方面的确占有十分重大的优势，不光是审核速度快（其他国家用户还需要等待GeoTrust主动联系，并提交更多信息，多花上2、3个工作日十分正常），连价格也便宜（年费只需99美金，前两天让荷兰的朋友帮忙注册需要99欧元），不得不长叹一声。 "
    },
    {
        "Title": "HTC 7 Mozart T8698（Windows Phone 7）初体验",
        "Link": "/2011/01/htc-7-mozart-t8698-windows-phone-7-review-and-xbox-kinect.html",
        "BriefIntro": "上个星期去香港旅游，对于我等IT从业人员来说，数码产品卖场自然是必逛的地方之一。香港的衣食住行都很贵，但是数码产品却十分便宜。看着手中使用了3个月滚珠就已失灵的奥巴马御用机型，决定就在香港采购一台吧。鉴于Android和iPhone 4都已经是烂大街的机器，我打算着重关注一下Windows Phone 7的机器。当时在香港到处可以看到HTC HD 7以及LG Optimus 7 E900，不过都是接近5000港币的价格，再加上实在不是很喜欢它们的外观，于是迟迟不愿下手。后来在百老汇发现新上市的HTC 7 Mozart T8698，据说是加强了多媒体能力的机型，外形和手感都不错，价格也相对较低（4200元港币，约合人民币约3600元），于是便选中了这台。把玩了几天，记录一下感受。 "
    },
    {
        "Title": "第三届nBazaar技术交流会开始报名",
        "Link": "/2010/12/3rd-nbazaar-meeting-sign-up.html",
        "BriefIntro": "为了错开年底密集的技术会议，第三届nBazaar技术交流会（即前“盛大创新院赞助的.NET技术交流会”）将于2011年1月15日举行。第三届的交流会将继续以往四场高质量的演讲，这也是确定nBazaar名称之后的第一次活动，希望nBazaar能够真正成为“集市”般热闹的社区活动。从现在开始，nBazaar技术沙龙的相关信息将逐渐集中至独立域名中，欢迎关注。 "
    },
    {
        "Title": "基于Jscex.Async的JavaScript动画/游戏",
        "Link": "/2010/12/animations-and-games-based-on-jscex-async.html",
        "BriefIntro": "首先和大家宣布一个消息，Jscex的代码已经提交至Github上了，感兴趣的朋友下载来Dog Fooding一把，并欢迎提出反馈意见。Jscex受到F#计算表达式的启发，是一个面向JavaScript语言的monadic扩展，最常见的用途便是编写异步程序，尤其是逻辑复杂的异步程序。不过除此之外，使用这套异步库来编写动画或是游戏也是十分容易的事情。例如，一个人物的走动或是爆炸效果，其实可以视为一个贴图随时间不断变化的过程。这个变化的过程是异步的，但是有了Jscex.Async，我们只需使用最直接的同步形式编写代码就行了。 "
    },
    {
        "Title": "抗拒“组合”的UITabBarController",
        "Link": "/2010/12/iphone-composition-resistant-uitabbarcontroller.html",
        "BriefIntro": "最近在写一个iPhone应用程序，基于MonoTouch，所以在开发方面的问题，基本都是在界面元素的搭建上。这个程序界面相对比较复杂，于是我根据自己的想法来进行组合，结果发现UITabBarController不能放入其他的视图内，而只能直接放在Window上（或Window里的UINavigationController里），否则就会出现界面向下偏移的情况。现在虽然有workaround，但是对于UITabBarController抗拒组合的情况，只能深表叹息了。 "
    },
    {
        "Title": "演出季上“异步编程模型的演变”幻灯片",
        "Link": "/2010/12/event-season-async-evolution-slides.html",
        "BriefIntro": "演出季终于过去了，现在就来做一个收尾吧。这次的主题是“异步编程模型的演变”，主要回顾了微软在.NET平台上异步编程上的进化：基于回调，基于迭代生成器，基于类库，基于语言。不过这样的编程模型其实并非微软独有，而是一些运用比较广泛的异步编程方式，因此在SD 2.0大会上我其实完全用JavaScript进行演示。从结果上来看，除了最早的TUP，其他两场演讲（.NET技术大会和SD 2.0）的反响都不错。 "
    },
    {
        "Title": "适合JavaScript 1.7中迭代生成器的异步编程机制",
        "Link": "/2010/12/javascript-17-yield-async-programming.html",
        "BriefIntro": "上篇文章我提出了一种基于JavaScript 1.7中迭代生成器（yield）的异步编程方式，它可以让混乱的异步代码逻辑变得清晰一些。不过之前的AsyncIterator其实是对基于C# 2.0的AsyncEnumerator的仿制品，在公司的分享会上进行交流以后，同事hax提出其实可以实现地更漂亮一些。在他的提示下，我了解到JavaScript 1.7中不同于C# 2.0里的特性，因而对这种异步编程机制提出了改进。只可惜yield特性被ECMAScript 5排除了，这实在可以说是委员会设计模式的又一次伟大胜利。 "
    },
    {
        "Title": "JavaScript版本的AsyncEnumerator",
        "Link": "/2010/11/asynciterator-the-asyncenumerator-in-javascript.html",
        "BriefIntro": "地球人都知道，在C# 2.0里提供了yield关键字，可以方便好用地生成一个迭代器，更可以简化异步操作――这是因为有了Jeffrey Richter开发的AsyncEnumerator。在接下来的某些演讲中我准备的主题是“异步编程模型”的演变，自然少不了这非常重要的一环。为了便于广大人民群众更好地接受，我决定使用JavaScript来进行说明。为此，我用JavaScript实现了一个AsyncEnumerator。 "
    },
    {
        "Title": "运行在.NET/Mono上的Readability",
        "Link": "/2010/11/readability-runs-on-dotnet.html",
        "BriefIntro": "之前我在《改善自己的阅读体验》推荐使用Readability这个小工具。它是一段JavaScript脚本，通过在浏览器的页面上运行，提取出文章正文部分，并通过一种干净清爽的形式展示给用户。那么，如果我们在服务器端得到了一个HTML字符串，又该如何得到它的可读部分？直接在服务器端执行JavaScript不太可行，因为Readability依赖浏览器的DOM结构及相关API。如果调用WebKit和IE的浏览器内核又需要大动干戈，也很难跨平台。因此，我基于HtmlAgilityPack将Readability的部分算法移植到了C#上。 "
    },
    {
        "Title": "关于即将到来的“演出季”以及Jscex类库",
        "Link": "/2010/11/the-coming-talks-and-jscex.html",
        "BriefIntro": "又到了一年一度的“演出季”，接下来将是各式会议扑面而来的一个月。作为“与会爱好者”我自然也进入了繁忙的准备工作。接下来我将在TUP（11月27日）、2010年第二届.NET技术大会（12月4~5日）以及CSDN软件开发2.0大会（12月9~10日）上与大家分享四场演讲。不过除了一场是关于Windows并发编程的基础以外，其余三场的话题都是围绕“微软在异步编程方面的演变”。在这场演讲中，我还会引入一个与该话题密切相关的JavaScript类库：Jscex。 "
    },
    {
        "Title": "一则有趣的Window 7广告",
        "Link": "/2010/11/windows-7-ad-change-perspective.html",
        "BriefIntro": "最近微软在Youtube上发布了一则有趣的Window 7广告，其中的台词从不同的方向阅读会有完全相反的意思。当然这个创意并非第一次出现，以前至少有两则笑话是相同的“原理”。当然，你我都能轻易写出这样的语句。 "
    },
    {
        "Title": "使用Narcissus解析JavaScript代码",
        "Link": "/2010/11/narcissus-javascript-parser.html",
        "BriefIntro": "最近在做一个有关JavaScript的实验，需要在客户端将JavaScript代码解析为一棵语法树。换句话说，就是一个用JavaScript实现的JavaScript解析器。这方面的选择有很多，常见的yacc、lex或是bison等等都有JavaScript的版本，使用ANTLR也可以将生成目标设为JavaScript。不过我不想在这方面耗费太多时间，自然想找个现成的工具，于是最终我将目标放在了Narcissus上。 "
    },
    {
        "Title": "PDC 2010：C#与Visual Basic的未来（下）",
        "Link": "/2010/11/pdc2010-the-future-of-csharp-and-vb-by-anders-hejlsberg-3.html",
        "BriefIntro": "前几天在PDC 2010会议上Anders Hejlsberg发表了一场名为“The Future of C# and Visual Basic”的演说，谈论了未来C#和VB中最为重要的两个特性：“异步（Async）”及“编译器即服务（Compiler as a Service）”。我现在对这场演讲进行总结，但不会像上次《编程语言的发展趋势及未来方向》那样逐句翻译，而是以Anders的角度使用一种简捷合适的方式表述其完整内容。上一篇Anders对async和await的的实现及效果作更进一步的解释，本篇则是对“编译器即服务”做了些最表面的尝试。 "
    },
    {
        "Title": "服务器端执行JavaScript代码",
        "Link": "/2010/11/execute-javascript-at-server.html",
        "BriefIntro": "话说，如今不在客户端使用JavaScript代码才是稀奇事儿。由于Web应用的体验越来越丰富，客户端用JavaScript实现的逻辑也越来越多，这造成的结果就是某些几乎一致的逻辑需要在客户端和服务器端各实现一遍。这违反了DRY原则，不容易维护。幸运的是，我们可以在服务器端执行JavaScript代码，谁让JavaScript傍上了这无比霸道的浏览器平台呢？ "
    },
    {
        "Title": "Silverlight与微软技术（下）：微软技术与技术学习",
        "Link": "/2010/11/silverlight-and-microsoft-technology-2-microsoft-technology-and-how-to-learn.html",
        "BriefIntro": "经常听到有人说微软的技术变化太快，持续性不好，让程序员追得很累。这种观点在微软技术社区内部和外部都有出现，似乎是一个不争的事实。但从我追随.NET平台这近十年的时间里，我并没有明显的感觉。微软的技术的确很多，但至少在.NET领域过渡性做的非常好，我没有任何疲惫之感。微软技术开拓了我的眼界，让我在微软内外许多技术方面越来越少有“新奇”的感觉，一切都是那么自然和稳妥。我现在就来仔细谈谈我在学习微软技术方面的经验与感受。 "
    },
    {
        "Title": "Silverlight与微软技术（上）：微软抛弃Silverlight了么？",
        "Link": "/2010/11/silverlight-and-microsoft-technology-1-is-silverlight-dead.html",
        "BriefIntro": "话说，在最近的PDC上，微软的副总裁Bob Muglia说了类似的话“我们对Silverlight的策略改变了，我们要用HTML5来实现跨平台的应用程序”，于是乎，社区铺天盖地响起了“微软要抛弃Silverlight”的调调。出现这个说法并不奇怪，媒体转述一遍，再给社区理解一下，很正常。但是我觉得奇怪甚至有些恶心的是，当事实愈发明朗化的时候，冒出的一些莫名其妙，兴灾乐祸，事后诸葛还在愈演愈烈。这两天我在社区里看的很多说法，某些“评论家”连一些基本概念，如“Silverlight是Windows Phone 7的开发平台”都不清楚，就来捕风捉影，实在让我难以继续旁观。 "
    },
    {
        "Title": "PDC 2010：C#与Visual Basic的未来（中）",
        "Link": "/2010/10/pdc2010-the-future-of-csharp-and-vb-by-anders-hejlsberg-2.html",
        "BriefIntro": "前几天在PDC 2010会议上Anders Hejlsberg发表了一场名为“The Future of C# and Visual Basic”的演说，谈论了未来C#和VB中最为重要的两个特性：“异步（Async）”及“编译器即服务（Compiler as a Service）”。我现在对这场演讲进行总结，但不会像上次《编程语言的发展趋势及未来方向》那样逐句翻译，而是以Anders的角度使用一种简捷合适的方式表述其完整内容。上一篇Anders讲述了async和await的使用方式，而这篇则是对这两个关键字的实现及效果作更进一步的解释。 "
    },
    {
        "Title": "PDC 2010：C#与Visual Basic的未来（上）",
        "Link": "/2010/10/pdc2010-the-future-of-csharp-and-vb-by-anders-hejlsberg-1.html",
        "BriefIntro": "PDC不愧为微软最高级的技术人员专业会议，让我看得直呼过瘾。前几天在PDC 2010会议上Anders Hejlsberg发表了一场名为“The Future of C# and Visual Basic”的演说，谈论了未来C#和VB中最为重要的两个特性：“异步（Async）”及“编译器即服务（Compiler as a Service）”。我现在对这场演讲进行总结，但不会像上次《编程语言的发展趋势及未来方向》那样逐句翻译，而是以Anders的角度使用一种简捷合适的方式表述其完整内容。 "
    },
    {
        "Title": "出售一批原版技术图书（CLR via C#等）",
        "Link": "/2010/10/selling-some-original-books-including-clr-via-csharp.html",
        "BriefIntro": "我是图书（收藏）爱好者，经常会因为看了一本经典的好书，就买一本原版来收藏，可谓美刀滚滚流。不过最近我慢慢意识到这么做并不合适，其一是因为书是用来看而不是用来收藏的，纸书相对于电子书有诸多不便，每次搬家都麻烦之至。而就算是所谓“阅读体验”的话，如今的影印版从各方面也几乎赶上原版书籍了。以后，我可能会买更多的电子书，然后在Kindle及电脑上阅读，或是购买影印版。至于手中已有的那些，就只保留少量经典的吧。 "
    },
    {
        "Title": "国内计算机图书真的不贵",
        "Link": "/2010/10/tech-books-published-in-china-are-not-expensive.html",
        "BriefIntro": "经常看到社区里有朋友抱怨说，现在的书好贵啊。但事实上我想要指出的一点是，在国内计算机图书真的不贵。不信我们一起来看看国外计算机图书的价格如何。我们应该舍得为知识进行投资，知识不应该是便宜的东西。国内的计算机图书市场其实处在一个很尴尬的境地：读者嫌贵，但其实作者和出版社都赚不到什么钱。对于每个在国内认真写书的作者，我们都应该视他们为楷模，他们实在是很不容易。我们要谴责的是那些写烂书，沽名钓誉的作者和出版社，因为正是他们还在继续扰乱国内计算机图书市场。而我们作为读者，对于图书市场也有十分关键性的力量，促进图书市场的良性循环是一种双赢的结果。 "
    },
    {
        "Title": "关于Iron语言的近况及nBazaar交流会",
        "Link": "/2010/10/status-of-iron-languages-and-nbazaar.html",
        "BriefIntro": "最近Iron语言方面有了一些令人瞩目的动作。我们知道IronPython及IronRuby一直是由微软维护的，不过前段时间微软有消息说要“取消”这两个项目，并直接导致Jimmy Schementi和Jim Hugunin离开微软。于是有人觉得Iron语言要死了。我倒不这么觉得，因为这两个是开源项目，是用的是Apache 2.0协议，它们会死的唯一原因便是社区放弃了它们，这和微软是不是参与维护并没有太大关系。微软固然有其影响力，但社区才是开源软件的核心。 "
    },
    {
        "Title": "对HTML做白名单过滤",
        "Link": "/2010/10/html-xss-filter-with-whilte-list.html",
        "BriefIntro": "让用户输入HTML的内容是很常见的需求，但是这有一定危险性，可能会带来XSS等问题，因此一般大家都要对HTML进行一定过滤。这个过滤并不容易，如<script />元素自不必说，其他还有如onload或onclick事件，甚至一个普通的<a />元素，它的href中也可以执行JavaScript代码。以前我一直有一段用于过滤的C#实现，一直没有出篓子，似乎也挺靠谱，但最近不知怎么的却发现了问题，可能是C & P出错，也可能原本就有问题，我没有太去关心。但问题总需要解决，于是我想，不如换个角度，基于白名单进行过滤吧。 "
    },
    {
        "Title": "当类型转换表达式遇上自定义转换操作",
        "Link": "/2010/10/when-conversion-expression-meet-customized-cast-operator.html",
        "BriefIntro": "之前我提到说System.Json是一个十分不好用的类库，其中一点就是在于，我没法将一个JsonValue转化为范型类型――它只为Int32，String等几种特定类型定义了隐式转换，又无法得到以object类型所引用的值。不过这也难不到拥有“在运行时创建自定义表达式树并编译成动态代码”的.NET程序员。我们可以写一个辅助方法进行JsonValue至任意类型的转化操作，.NET类库会负责为我们选择合适的转换方式。只不过，类库中的一个Bug会让我们稍微绕一点点弯路。 "
    },
    {
        "Title": "在传统.NET程序中使用Silverlight SDK里的JSON类库",
        "Link": "/2010/10/use-silverlight-system-json-in-normal-application.html",
        "BriefIntro": "话说在Silverlight SDK中提供了一套JSON类库，叫做System.Json。这个类库功能很简单，就是使用.NET来表示JSON格式的“结构”。换句话说，就是我之前在JsonMe中所提到的JsonObject，JsonArray之类的东西，但完全不包括JSON结构和实际类型之间的转化。虽然这个类库很不好用（谁用谁知道），但至少是一个可以通用于Silverlight和MonoTouch的类库，因此我决定将JsonMe基于它进行构建。为此，我对mono中的开源实现进行了移植，使它仅仅依赖于功能最基本的.NET Framework 3.5 Client Profile，并修改了其中的一些明显的Bug。 "
    },
    {
        "Title": "JsonMe - 合约与类型分离的轻量级JSON映射类库",
        "Link": "/2010/10/jsonme-a-type-contract-separated-lightweight-json-mapping-library.html",
        "BriefIntro": "JSON全称为JavaScript Object Notation，原本作为JavaScript语言中用于表示对象结构的文本形式。不过目前JSON成功地脱离了JavaScript语言，它已经成为一种运用十分广泛的数据交换格式。从表面看来，目前用于某个对象与JSON格式之间相互转化的解决方案已经有了许多种，例如在.NET平台上，我们可以使用ASP.NET AJAX中引入的JavaScriptSerializer，WCF中引入的DataContractJsonSerializer，亦或是Json.NET。但是，最近我忽然发现这些类库都无法满足我的要求，因此，我今天花了一点时间，写了一个非常简单的对象与JSON格式相互转化的类库，是为JsonMe。 "
    },
    {
        "Title": "Padding Oracle Attack实例分析",
        "Link": "/2010/10/padding-oracle-attack-in-detail.html",
        "BriefIntro": "在之前的《浅谈》一文中，我提到《Automated Padding Oracle Attacks with PadBuster》一文对理解Padding Oracle Attack非常有帮助，并打算将其翻译出来。现在我便来实现承诺了。《Automated》一文其实是在介绍PadBuster这个自动攻击工具，不过其中也通过实例加配图详细介绍了Padding Oracle Attack的原理――这也是我会翻译的部分。这篇文章写的非常通俗易懂，您只需要了解一点点关于加密的基础概念即可，不需要对加密算法或其证明有任何了解。我想只要配合些许Wikipedia上的定义，大部分朋友应该都能顺利地理解这篇文章。 "
    },
    {
        "Title": "在Visual Studio中使用MonoTouch开发iOS应用程序（下）：开发体验",
        "Link": "/2010/09/develop-ios-app-with-monotouch-in-visual-studio-2.html",
        "BriefIntro": "对于熟悉.NET程序员来说，编写iOS应用程序的最佳选择自然是MonoTouch。在上一篇文章里，我们已经在Mac OS X上安装了MonoTouch开发环境，并已经能够在Mac OS X和Windows之间共享文件。现在我们就可以来简单体验一下，如何使用Visual Studio，Interface Builder以及少量的MonoDevelop来开发一个最最简单的iOS应用程序。 "
    },
    {
        "Title": "在Visual Studio中使用MonoTouch开发iOS应用程序（上）：环境配置",
        "Link": "/2010/09/develop-ios-app-with-monotouch-in-visual-studio-1.html",
        "BriefIntro": "前段时间在工作机上装了Mac OS X，这主要是因为我最近需要开发iPhone应用程序。虽然Xcode，Objective C一定是开发iOS应用程序的主流，但是经过一番考虑，我还是决定尝试一下使用MonoTouch进行开发。MonoTouch是Novell公司基于开源的Mono平台构建的一套iOS开发环境，使用MonoDevelop作为代码编写工具。不过目前的MonoDevelop较之Visual Studio可谓“萤火之光比皓月之明”，甚至还有无法输入中文的低级问题。因此，至今我所有在Mono上运行的代码其实都是用Visual Studio写的，这次自然也不例外。不过，这似乎并不是件非常直接的事情…… "
    },
    {
        "Title": "Win7 + VirtualBox安装Mac OS X雪豹操作系统图文详解",
        "Link": "/2010/09/how-to-install-mac-os-x-snow-leopard-on-virtualbox.html",
        "BriefIntro": "由于工作需要，我需要同时使用Windows和Mac OS X操作系统，虽然公司可以配置两台机器，但是出于发热量，空间占用，操作系统互通等原因，我还是更倾向于在虚拟机环境里工作。由于在大部分工作还是在Windows上完成的，因此我选择Win 7作为Host，而将Mac OS X Snow Leopard作为Guest系统。由于各种原因（如严格和特殊的硬件需求），在虚拟机下安装OS X一直是件无比折腾的事情，留下了无数先驱的身影。但是，我忽然发现，似乎如今新版的VirtualBox对于OS X已经有了非常优秀的支持，尝试之后感觉大好，因此记录下来供需要的朋友参考。 "
    },
    {
        "Title": "浅谈这次ASP.NET的Padding Oracle Attack相关内容",
        "Link": "/2010/09/things-about-padding-oracle-vulnerability-in-asp-net.html",
        "BriefIntro": "上一周爆出了一个关于ASP.NET的安全漏洞，有关这个漏洞的第一篇文章应该是ScottGu的说明，但是其中各方面谈的也是语焉不详。由于这个漏洞关系到“安全”这样敏感的话题，其中又涉及到密码学这样常人看不明白的技术，于是导致了各种猜测和推测，其中甚至与我对ASP.NET的了解所有矛盾，因此我觉得也大都不靠谱。中秋休息在家，我简单地了解了一下与这个漏洞有关的内容，总结出了一些“能够说服自己”的内容，在此记录下来。因此，这篇文章的面向读者是那些和我差不多的同学：对ASP.NET有所了解，但对密码学知之甚少。 "
    },
    {
        "Title": "盛大创新院赞助第二届.NET技术交流会 - 演讲录像及下载",
        "Link": "/2010/09/2nd-snda-dotnet-conference-videos.html",
        "BriefIntro": "经过一个多星期的努力，我们在此为大家奉上盛大创新院赞助第二届.NET技术交流会的演讲录像。由于录像过程中的一些失误，我们在在讲师录像方面存在着很大问题，经过补救，也只能得到后两场演讲中使用手持设备拍摄下来的录像。在此向大家表示深深的歉意，有了这次的教训，我们以后会更加重视每一个环节的预防及补救措施，尽力避免如现在这样无可挽回的结果。 "
    },
    {
        "Title": "我爱编程，我很快乐。你找理由，你不快乐。",
        "Link": "/2010/09/about-the-passionate-programmer-book.html",
        "BriefIntro": "大约一个月前看了一本书，中文名叫《我编程，我快乐》，副标题是“程序员职业规划之道”。前段时间挺忙，一直没去记点什么东西，趁现在起了个大早，就写点吧。很显然，这本书是讲程序员职业规划的，200页，50篇短文。至于讲的内容，所实话，我认为常识成分居多的，其中大部分我同意，并且我也是这么做的――剩下一小部分中的大部分，我不会这么去做，但我也基本上也承认，照书上地去做，可能更有助于职业发展。 "
    },
    {
        "Title": "异步编程与响应式框架",
        "Link": "/2010/09/async-programming-and-reactive-framework.html",
        "BriefIntro": "异步操作是强大的，它是许多高伸缩性架构的基石。异步操作在许多情况下是必须的，例如在客户端保持用户界面的响应能力，以及在日益兴起的云计算场景中。但是，异步编程又是十分困难的，它让这让许多程序员敬而远之。因此，越来越多的编程语言都对异步编程提供了相当程度的支持，其中的典型代表便是F#中的异步工作流以及Scala的Actor模型。不过目前的一些主流编程语言，如C#或是JavaScript，它们在设计之时并没有在异步编程上考虑太多，我们便会根据它们的语言特性，提供合适的异步编程模型及其实现。而本文介绍的便是其中一例：响应式编程模型及响应式框架。 "
    },
    {
        "Title": "盛大创新院赞助第二届.NET技术交流会 - 各场演讲幻灯片",
        "Link": "/2010/09/2nd-snda-dotnet-conference-all-slides.html",
        "BriefIntro": "昨天有160多位朋友参加了盛大创新院赞助的第二届.NET技术交流会，再次感谢各位对我们的支持。比较遗憾的是，这次的讲师录像方面有着很大问题，我们正在想办法进行修补，希望可以有“差强人意”的结果。现在，大家请在第一时间浏览本次活动新鲜出炉的幻灯片。 "
    },
    {
        "Title": "盛大创新院赞助第二届.NET技术交流会即将召开",
        "Link": "/2010/09/2nd-snda-dotnet-conference-is-coming.html",
        "BriefIntro": "由盛大创新院赞助的第二届.NET技术大会将于9月11号下午1点召开，本次交流会请到了四位讲师，议题覆盖了响应式编程、算法、面向对象设计及Windows内核等多个方面，其中最为突出的莫过于由潘爱民老师为大家带来的Windows内核方面的话题。我已经看过了各场演讲的幻灯片终稿，也很期待各位讲师在正式演讲中的表现。 "
    },
    {
        "Title": "关于静态资源打包后的相对路径问题",
        "Link": "/2010/09/relative-path-in-packed-static-resources.html",
        "BriefIntro": "将多个静态资源打包为单个资源以减少请求数目，是提高页面加载速度的常用手段。于是上个星期，我就在实现网站静态资源的自动打包功能，原以为是个比较简单的问题，实现起来也没有遇到什么障碍，不过在开发完毕投入使用的时候却让我跌了下眼镜。由于静态资源在打包以后，它们的访问路径势必会改变，这样其他一些依赖于原有路径的资源就访问不到了。这方面最常见的例子，便是CSS样式表中引用的图片路径是相对于CSS文件路径的。当意识到这个问题以后，还真是让人手忙脚乱了一把。 "
    },
    {
        "Title": "程序员的档次？有没有搞错？！",
        "Link": "/2010/08/programmer-hierarchy-disgusting-csdn-news.html",
        "BriefIntro": "最近有一幅老图很火，很多人说这是“从语言来区分程序员的高低”。很多人说这幅图有问题，我说是你们的理解有问题，类似这样的对话在推特上面出现过多次，一般说着说着也就过了。不过突然发现，在CSDN――这个中国最大、最权威的IT类网站上居然发布了一篇名为“程序员的档次”的新闻，让我有些愤慨。CSDN首页是我常去的地方，在我印象中以前最令人不满的也最多是技术方面的硬伤吧，但这次就不明白了，这是故意的还是怎么的？我已经很难相信这是“无心之失”了。如果不是故意的，那么某些编辑同志的业务水平的确需要提高了。 "
    },
    {
        "Title": "为自己打造良好的文章阅读体验",
        "Link": "/2010/08/get-a-better-style-for-reading.html",
        "BriefIntro": "我的上一篇文章是《为自己打造良好的文章阅读体验》，是为广大“作者”所写的，希望大家的文章都能长得漂亮。但无论怎么样，我们作为读者一定还是会遇到大量阅读体验糟糕的的文章，它们可能是一些只重视搜索引擎流量的无良小站，或是很难推动调整的大站、或是审美情趣有所特色的个人站长等等。根据我的个人经验，如果能够为自己打造一个舒适习惯的阅读体验，会让文章阅读的效率更高，甚至心情也能变得愉快放松。现在这篇文章，便是为了广大“读者”朋友写的，如果能够帮助您“爱上阅读”，那便善莫大焉了。 "
    },
    {
        "Title": "为读者打造良好的文章阅读体验",
        "Link": "/2010/08/my-view-of-good-blogging-theme.html",
        "BriefIntro": "几个月前我在微软“社区精英计划”上谈过“如何打造受人欢迎的博客”，其中一点便是“样式美观”，这也是如Scott Hanselman这样的业界著名博主给出的建议之一。对于写文章、读文章来说，我可谓完全是外貌协会的高级会员，一旦遇上样式排版不好的文章、再好的内容我也难以坚持阅读下去――我也相信很多人多多少少有和我一样的习惯。有人说，我们是程序员，做不来样式怎么办？其实在我看来，打造一个良好的文章阅读体验并不困难，甚至只有那么几点而已。虽然我不是设计师，但我现在也想来谈一下我在这方面的习惯和“品味”。 "
    },
    {
        "Title": "盛大创新院赞助第二届.NET技术交流会开始报名了！",
        "Link": "/2010/08/2nd-snda-dotnet-conference-sign-up.html",
        "BriefIntro": "自上次盛大创新院赞助的首届.NET技术交流会到现在已经有两个月，这意味着按照原来的“一季一次”的计划也已经离第二次的活动不远了，考虑到9月份的中秋和国庆假期将工作日和休息日搞的支离破碎，于是交流会的时间会略微有些提前。第二届交流会的形式与上次相同，将为您献上四场高质量的技术演讲。当然这次在内容上有了新的尝试，除了引入了算法及面向对象设计的内容之外，这次更是请到了“传说中的大侠”为大家带来有关Windows内核的深度内容。人数暂定为200人，事不宜迟，赶快报名吧。除了.NET社区的群众以外，也欢迎其他技术社区的朋友前来参与交流。事实上，我组织技术交流会的目的之一便是希望能够促进.NET社区与其他技术社区的交流及相互学习。 "
    },
    {
        "Title": "读完《Scala程序设计》，随便谈一些想法吧",
        "Link": "/2010/08/programming-scala-and-more.html",
        "BriefIntro": "虽然我对Scala还算熟悉，但还是在china-pub上订阅了一本图灵引进的《Scala程序设计》。上上周五在公司收到了这本书，顺手带回家，在路上简单翻了翻。周六用来欢乐，周日懒觉睡觉中午，直到下午才又拿起这本书，不过加上周一上班途中的工夫也算将这本不到200页的小册子浏览完了。这本书的内容本身并没有给我留下太深刻的印象，但我也想谈一些有关Scala语言和其他一些方面的想法。 "
    },
    {
        "Title": "关于Windows频繁打开关闭端口时出现的问题",
        "Link": "/2010/08/lack-of-dynamic-ports-when-frequently-open-and-close-socket.html",
        "BriefIntro": "最近事情很多，人也懒，东西看了不少，也想到过一些东西，但就是懒得写。现在记录一下前两个星期做一个压力测试时出现的现象，希望重开一个好头。简单地说，这是个从Windows Server连接Linux下的MongoDB服务时出现的问题。MongoDB使用的是自定义的二进制协议，客户端使用普通的TCP连接进行连接后再读写数据。在以前的测试中，我使用的都是建立少量连接，每个连接进行多次操作，而这次则是对“应用程序”进行压力测试，因此需要不断地开启及关闭连接――频率大约是每秒4、500次吧。 "
    },
    {
        "Title": "活动：来自Opera挪威的子斌与上海前端工程师交流HTML5 & CSS3",
        "Link": "/2010/08/html5-css3-talk-in-snda-innovation.html",
        "BriefIntro": "最近有些忙，疏于写博客，在此先带来一个创新院周末的活动通知，希望感兴趣的朋友可以来参加。地点在创新院，到时候会有专人负责接待。这次我们请到了Opera挪威的子斌给大家带来一个关于HTML5和CSS3的演讲，他会介绍HTML5和CSS3的新特性以及一些实用技巧，并且会跟大家就一些关心的问题进行讨论。 "
    },
    {
        "Title": "关于DLR及.NET版本的问题",
        "Link": "/2010/07/dlr-in-different-version-of-dotnet.html",
        "BriefIntro": "动态语言运行时（Dynamic Language Runtime，DLR）是一套基于.NET的类库，它的作用是简化在CLR上开发动态语言的工作，例如DLR中提供了表达式树的创建，代码生成、优化及调试等实现动态语言的常见功能，而语言的编写者则着重关注解析器等方面的工作。不过最近接触了观察了DLR代码之后，却发现它和各版本.NET中BCL的协作还真是件不容易理清的事情。 "
    },
    {
        "Title": "无处不在的DRY原则",
        "Link": "/2010/07/dry-principle-everywhere.html",
        "BriefIntro": "DRY（Don't Repeat Yourself）原则，一般是指在写代码的时候尽量避免重复的实现。违反DRY原则导致的坏处很容易理解，例如维护困难，修改时一旦遗漏就会产生不易察觉的问题。不过其实这个原则并非写代码的时候独有，其实在各处都有类似的情况。当然，现在还是不谈“生活”，而是简单谈谈我在工作中发生的一些事情。 "
    },
    {
        "Title": "如今的MSN病毒越来越有喜感了",
        "Link": "/2010/07/interesting-msn-virus.html",
        "BriefIntro": "请慎入，这是一篇无聊文，没有任何技术含量，实在是因为我觉得现在的MSN病毒越来越有喜感了。在此提醒大家还是要当心啊，千万不要在网上泄露你的各种账号和密码，在任何情况下。 "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（6）：yield及其作用",
        "Link": "/2010/07/why-java-sucks-and-csharp-rocks-6-yield.html",
        "BriefIntro": "C# 2.0新增了yield关键字，其初衷是简化迭代器的生成，这可以说是现代语言的标配。只可惜Java历经数次升级，从数量上来说也算增加了不少语言特性了，却还是将这个功能拒之门外，让人费解。除了用于生成迭代器之外，yield还可用于其它一些场景，颇为奇妙。这些场景都是在生产过程中常用的开发模式，只可惜对于使用Java语言的程序员来说都只能望而兴叹了。 "
    },
    {
        "Title": "NDC 2010视频下载：看看其他微软平台程序员们都在做什么",
        "Link": "/2010/07/ndc-2010-videos.html",
        "BriefIntro": "NDC（Norwegian Developers Conference，挪威开发者大会）是一年一度的挪威最大的微软平台开发者大会，内容丰富，讲师阵容强大。NDC与PDC同为高端技术会议，但NDC与PDC的不同之处在于，PDC是微软官方会议，主要是面向微软资深产品的深入探讨。而NDC涉及的内容则广泛的多，包括了我所感兴趣的Java、Mono、IronRuby/Ruby on Rails、NoSQL方面的内容。这也就像我一直强调的那样，微软技术社区非常开放，微软平台上的太多程序员都能够非常热情地拥抱其他平台的技术。那些认为微软技术社区是井底之蛙的兄弟，殊不知你们的嘲笑只能体现出自身的狭隘。 "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（补2）：标准事件模型",
        "Link": "/2010/07/more-why-java-sucks-and-csharp-rocks-2-standard-event-model.html",
        "BriefIntro": "这又是一篇“补”，本来并不想写这方面的内容，因为这并非完全是“语言”相关。打个比方，如果您觉得.NET中的事件模型不友好，那么就按Java的做法去做咯（反之就做不到了）。不过既然正好看到有些涉及到这方面的讨论，那么我也趁此机会发表一下自己的看法吧。这次谈的是两种语言（其实在这个话题上也是平台）下“标准”的事件模型。“标准”二字意味着是被双方社区各自接受的模型，而不仅仅是为了实现“事件”这一理念而使用的任意做法。 "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（5）：匿名方法",
        "Link": "/2010/07/why-java-sucks-and-csharp-rocks-5-anonymous-method.html",
        "BriefIntro": "确切地说，这里的标题应该是“C#中的匿名方法”，因为这是C#中特有的功能。在之前的文章里，虽然我都用长篇文字加代码示例来说明问题，但总有朋友认为我谈的只是C#和Java的“区别”，算不上优势。不过从这篇文章开始，我们将正式进入C# 2.0的时代，这也是C#大步甩开Java语言的开端――可以看出，Anders Hejlsberg从此开始实现他对于编程语言的各种理想，而并非纠缠于与Java所谓的“竞争”中。例如这篇文章要讨论的“匿名方法”特性，以及随之而来的“函数式编程”痕迹，便开始引领C#在开发理念上的进步。 "
    },
    {
        "Title": "为什么我支持托管运行时（虚拟机）",
        "Link": "/2010/07/why-i-support-managed-runtime-virtual-machine-based-program.html",
        "BriefIntro": "最近博客园上在炒关于C#性能的问题，其实应该说是.NET性能的问题，其中某位仁兄提出，他希望C#能够直接编译为原生代码，而不是在CLR这样一个托管运行时上执行，因为虚拟机啊，JIT什么的性能差。后来发到TL上以后，也有朋友认为，“基于虚拟机的语言都是大公司为了利益在推动，说白了就是政治”，因此“对C#提高性能的建议感到可笑，因为它本来就不是用来开发高性能程序的”，再有，“C、C++已经明确不和这些后进争所谓的‘容易开发’的头衔”，那么其他语言为什么要和C++它们比较性能呢？我是托管运行时，或者虚拟机的忠实拥护者，这里谈一下我在这方面的看法。 "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（补1）：Reddit，兼谈C#属性",
        "Link": "/2010/06/more-why-java-sucks-and-csharp-rocks-1-reddit-and-property.html",
        "BriefIntro": "最近博客冷清了不少，主要是事情较多，一是.NET交流会，二是工作，三是几篇暂时无法发在博客上的文章。周末在家，发现邮箱里经常收到SlideShare的邮件，说是我的Why Java Suck and C# Rocks幻灯片在推特上很火热。今天早上忽然发现，它被人发到Reddit的编程版块了，讨论地颇为热烈。关于讨论内容，您可以亲自阅读一下。最近的讨论也让我想要补充一些关于C#属性的问题。 "
    },
    {
        "Title": "盛大创新院赞助首届.NET技术交流会 - 演讲录像及下载",
        "Link": "/2010/06/first-snda-dotnet-conference-videos.html",
        "BriefIntro": "经过几天的努力，终于将盛大创新院赞助的首届.NET技术交流会的演讲录像制作完成了。本来在现在的高清视频以外，我还想像Channel 9一样提供一些低码率的格式下载，但多次尝试都以失败告终，各中滋味难以言喻。因此目前只能给大家提供mov格式的高清视频下载，对于Windows下各类强大的播放器都不成问题。您也可以在线观看这些视频，不过上传至优酷后，发现除了清晰度较低外，甚至还有音画不同步的问题。我正在联系酷六网，会尽快用上质量更好的视频。 "
    },
    {
        "Title": "讨论？讨论你妹啊！",
        "Link": "/2010/06/no-room-for-discussion.html",
        "BriefIntro": "无论是针对什么东西的讨论，或是争论也好，最重要的便是观点明确，论据清晰，这样大家也可以有针对性进行回复或是反驳。但如果观点和论据不配套，处处呓语，动辄非逻辑性判断，这又让人如何应对？我遇到许多争论，虽然明显是错的，但从头到尾却不知道如何入口。还有对人不对事，还有遇上猪一般的队友的时候……讨论？讨论你妹啊。 "
    },
    {
        "Title": "盛大创新院赞助首届.NET技术交流会 - 各场演讲幻灯片",
        "Link": "/2010/06/first-snda-dotnet-conference-all-slides.html",
        "BriefIntro": "今天是近期最热的一天，气温高达35度，异常闷热，但是依然有160多位朋友冒着酷暑参加了盛大创新院赞助的首届.NET技术交流会，这让我感到很欣慰，因此这里首先要感谢大家的支持。我刚才浏览了一下三场演讲的桌面录像，可谓异常完美，现在只等酷六网的摄影师的讲师录像到手，便可以合成为最终的演讲视频了，希望能够尽快展示给大家。不过现在，大家可以在第一时间浏览本次活动新鲜出炉的幻灯片。 "
    },
    {
        "Title": "盛大创新院赞助首届.NET技术交流会即将召开",
        "Link": "/2010/06/first-snda-dotnet-conference-is-coming.html",
        "BriefIntro": "由盛大创新院赞助的首届.NET技术大会将于6月19号下午1点召开，本次交流会请到了四位讲师，议题覆盖了F#、C#、Rails及架构等多个方面。我已经看过了各场演讲的幻灯片草稿，也很期待各位讲师在正式演讲中的表现。本次大会中，我们还获得了人民邮电出版社图灵教育赠送的20册图书，将会作为奖品赠送给在交流会中表现积极的听众。此外，我们还请到了酷六网的专业摄影师对演讲过程进行全程拍摄，并配合各位讲师自身的屏幕录像，将在后期合成为适合独立观看的演讲视频，让不能到场的朋友在线或是下载后观看。 "
    },
    {
        "Title": "趣味编程：在JavaScript中实现简单的yield功能（2 - 循环支持及解释执行）",
        "Link": "/2010/06/code-for-fun-iterator-generator-yield-in-javascript-answer-2-loop-and-interpreter.html",
        "BriefIntro": "在上一篇文章里，我们构造了$yield和$yieldSeq两个基础编程组件，于是我们可以“在一定程度上”使用C#中的yield功能来构造一个迭代器。从表面上看来似乎不错，不过它的实际价值还是有值得推敲的。例如，我们目前还必须使用递归来代替循环，那么我们有办法改变这种变成方式吗？此外，在评论中有朋友谈到，这样写代码其实不是一个格式化就混乱了吗？至少，您是否觉得这种编程方法的function和括号实在多了些呢？这次我们就来探索这些问题的解决办法。 "
    },
    {
        "Title": "趣味编程：在JavaScript中实现简单的yield功能（1 - yield与yieldSeq）",
        "Link": "/2010/06/code-for-fun-iterator-generator-yield-in-javascript-answer-1-yield-and-yieldseq.html",
        "BriefIntro": "上文我谈到了迭代器及其生成器，即C#或Python中的yield功能，它们极大地简化了创建一个迭代器的工作，让代码的语义和可读性有了很大提高。虽然在JavaScript 1.7中已经有了相同的功能，可惜目前我们还无法用到这种强大的能力。那么，我们能不能为JavaScript提供如C#中一样的功能？在文章的评论里许多朋友也给出了他们的解决方案，也让我获得了许多启发。因此，我也打算在以后的文章中总结一下各位的做法。不过在这篇文章里，我先来阐述一下我个人的想法。 "
    },
    {
        "Title": "趣味编程：在JavaScript中实现简单的yield功能（问题）",
        "Link": "/2010/06/code-for-fun-iterator-generator-yield-in-javascript.html",
        "BriefIntro": "说起迭代器（Iterator）大家一定都不陌生，无论是是Java，C#或是Python等语言都有内置标准的迭代器结构，它们也都提供了内置的for或foreach关键字简化迭代器的“使用”。不过对于迭代器的“生成”，不同语言之间的就会有很大差距。例如，在C#和Python中都提供了yield来简化迭代器的“创建”，此时生成一个迭代器便再简单不过了。但对于Java程序员来说，即使到了Java 7还必须为在迭代器内部手动维护状态，非常痛苦。而更重要的一点是，利用yield我们可以轻松地创建一个“延迟”的，“无限”的序列。那么，我们能否在JavaScript中享受到这样的yield生成器呢？ "
    },
    {
        "Title": "浅谈Java 7的闭包与Lambda表达式之优劣",
        "Link": "/2010/06/first-version-of-lambda-and-closures-in-java-7.html",
        "BriefIntro": "前几天Oracle推出了Java 7官方的闭包与Lambda表达式的第一个实现，这基本上也是最终在正式版中的样式了。看了这个实现之后，我的第一感觉便是“丑”，当然不排除这是因为看惯了其他语言中实现的缘故。后来再仔细看了看又想了想，发现Java 7的实现也并非毫无可取之处，但似乎又感到某些做法上有一些问题。总之整个过程颇为有趣，决定将我的想法记录下来，希望可以吸引人来一起讨论一下。 "
    },
    {
        "Title": "编程语言的发展趋势及未来方向（7）：总结",
        "Link": "/2010/06/trends-and-future-directions-in-programming-languages-by-anders-7-conclusion.html",
        "BriefIntro": "这是Anders Hejlsberg在比利时TechDays 2010所做的开场演讲。由于最近我在博客上关于语言的讨论比较多，出于应景，也打算将Anders的演讲完整地听写出来。在上一部分中，Anders谈论了“并发”，这也是他眼中编程语言发展的三种趋势之一，并演示了.NET 4.0中并行库的神奇效果。现在则是此次演讲的最后一部分，Anders对整场演讲内容进行了总结和回顾。 "
    },
    {
        "Title": "跨平台到底是不是谎言？",
        "Link": "/2010/06/is-cross-platform-a-lie-or-not.html",
        "BriefIntro": "前几天是个神奇的日子，博客园里咣咣咣地出现了三篇文章，都包含了“跨平台”和“谎言”这两个关键字。从Java开始谈到.NET，最后哐地一下，“跨平台”本身也变成一种谎言了。从文章内容上看，我个人觉得基本不靠谱，主要论述方式是用“气势”或是“自信”来压倒对方……呃，是“说服别人”。我不打算谈那两篇文章的内容了，许多意见我和其他人也在文章后面回复过了。我现在只想在这里简单谈谈我对“跨平台”这个问题的看法。 "
    },
    {
        "Title": "编程语言的发展趋势及未来方向（6）：并发",
        "Link": "/2010/05/trends-and-future-directions-in-programming-languages-by-anders-6-concurrency.html",
        "BriefIntro": "这是Anders Hejlsberg在比利时TechDays 2010所做的开场演讲。由于最近我在博客上关于语言的讨论比较多，出于应景，也打算将Anders的演讲完整地听写出来。在上一部分中，Anders谈论了“元编程”及他正在努力的“编译器即服务”功能。在这一部分中，Anders则谈论了“并发”，这也是他眼中编程语言发展的三种趋势之一，并演示了.NET 4.0中并行库的神奇效果。 "
    },
    {
        "Title": "编程语言的发展趋势及未来方向（5）：元编程",
        "Link": "/2010/05/trends-and-future-directions-in-programming-languages-by-anders-5-meta-programming.html",
        "BriefIntro": "这是Anders Hejlsberg在比利时TechDays 2010所做的开场演讲。由于最近我在博客上关于语言的讨论比较多，出于应景，也打算将Anders的演讲完整地听写出来。在上一部分中，Anders谈及了他眼中编程语言的另一个发展趋势：动态性。在这一部分中，Anders则讨论了动态语言所擅长的“元编程”，并简单介绍了他为静态类型语言所设计的一种改进方案：编译器即服务。 "
    },
    {
        "Title": "使用OpenOffice.org将各类文档转为PDF",
        "Link": "/2010/05/convert-document-to-pdf-via-openoffice.html",
        "BriefIntro": "最近在项目上遇到一个需求，是要将各类文档转换为PDF。这应该是个很常见的工作，而且我也只需要支持MS Word，Excel，PowerPoint等常见的文档格式就行了。于是有朋友就建议了，可以使用MS Office转嘛。当然也可以使用其他方法，例如装一些PDF打印机，把文档打印成pdf文件。不过这些做法在“授权”方面似乎都有些问题。当然，我也找了一些商业解决方案（如Aspose）保底，咋看之下它的授权方式也并不算贵。不过现在看来，OpenOffice.org已经能够满足我的需求了。如果您有更好的做法也请告诉我。 "
    },
    {
        "Title": "随便说说邮件列表那点事儿",
        "Link": "/2010/05/things-about-mail-list.html",
        "BriefIntro": "这两天推特上在讨论RT方式与时间线干扰的问题，主要是有人抱怨官方的RT，或是民间的RT，还是所谓RT式回复的方式会污染追随者的时间线。对此有朋友应对到，如果感到“信息过载”，应该寻找合适的工具来进行管理。我没有参与这个问题的讨论，因为我本身其实还没有搞清各种RT方式分别是指什么，而且我也没有混乱的感觉──要知道我才fo了不到300人，如笑来老师fo了超过一万五千人还处理的井井有条，和他相比我算什么嘛。不过霍炬刚才举了一个例子提到了邮件列表相关的事情，我也就顺便谈一下吧。 "
    },
    {
        "Title": "编程语言的发展趋势及未来方向（4）：动态语言",
        "Link": "/2010/05/trends-and-future-directions-in-programming-languages-by-anders-4-dynamic-languages.html",
        "BriefIntro": "这是Anders Hejlsberg在比利时TechDays 2010所做的开场演讲。由于最近我在博客上关于语言的讨论比较多，出于应景，也打算将Anders的演讲完整地听写出来。在上一部分中，Anders谈及了声明式编程的另一个重要组成部分：函数式编程，并使用.NET平台上的函数式编程语言F#进行了演示。在这一部分中，Anders讨论了动态语言及JavaScript的相关内容，“动态性”也是Anders眼中编程语言的发展趋势之一。 "
    },
    {
        "Title": "2010年5月《程序员》杂志“架构师接龙”栏目中的问答",
        "Link": "/2010/05/programmer-magazine-2010-5-architect.html",
        "BriefIntro": "上个月《程序员》杂志向我约稿，希望我可以参加5月份的“架构师接龙”栏目，我略为犹豫了一下便答应了。“架构师接龙”是一个问答形式的栏目，每期由一个人提问，并由另一个人回答。回答的一方便是下期的提问者。这次提问的架构师是新浪微博的技术经理杨卫华。他提出的问题包括语言选择与架构设计、NoSQL存储方案的取舍、微博类系统的架构等多个方面。杨卫华是国内技术社区一等一的高手，这使得我在回答问题时更有小心翼翼地班门弄斧之感。如果您对某些问题感兴趣，也不妨来一起讨论一下。 "
    },
    {
        "Title": "永远的G点：中医和科学",
        "Link": "/2010/05/science-and-chinese-medicine.html",
        "BriefIntro": "最近由于@tinyfool同学要对博客的缓存插件进行压力测试，于是又引发了一场关于中医和科学的讨论、嗯或者说是争论……讨论……好吧我也不知道算是什么。这的确是个G点，一碰就能让许多人兴奋。兄弟我学识浅薄，既不懂科学，也不懂中医，本来不该参与这个话题讨论的，但最近看着其他人围着G点打转，脑子里也产生了不少想法，如果不记下来着实有些浪费脑细胞了。 "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（4）：泛型",
        "Link": "/2010/05/why-java-sucks-and-csharp-rocks-4-generics.html",
        "BriefIntro": "Java 5.0和C# 2.0发布于同一年，各自添加了一个重要的特性：泛型。泛型可以让程序员针对泛化的数据类型编写相同的算法，这大大增强了两种语言的类型系统及抽象能力。不过即便是这看似相近的功能，Java和C#两者在语言实现和功能上也有很明显的区别，这甚至会形成编程方式上的不同。在这里可能需要事先打声招呼，因为在这个特定的话题上，语言和运行时的确是密不可分的，因此在这篇文章中我会涉及到相对较多的“运行平台”上的比较，而这点在整个系列中是我尽量避免的。不过您请放心，只此一次，欢迎监督。 "
    },
    {
        "Title": "盛大创新院赞助首届.NET技术交流会开始报名了！",
        "Link": "/2010/05/first-snda-dotnet-conference-sign-up.html",
        "BriefIntro": "自从上次在博客中提到盛大创新院赞助.NET技术会议已经过去了一个半月，如今这件事情终于落实了。我为此准备了数千字的申请书，但老大看也不看便表示支持。他的说法是，只要办得热烈，有影响力，那么这样的活动绝对支持。为此，各场次演讲内容及会场等诸多事宜之后，现在“首届.NET技术交流会”正式进入报名阶段了。人数不设上限，多多益善，怕只怕会场会显得空旷。除了.NET社区的群众以外，也欢迎其他技术社区的朋友前来参与交流。事实上，我组织技术交流会的目的之一便是希望能够促进.NET社区与其他技术社区的交流及相互学习。 "
    },
    {
        "Title": "使用.NET 4.0中的表达式树生成动态方法",
        "Link": "/2010/05/generate-dynamic-method-with-expression-tree-in-dot-net-4.html",
        "BriefIntro": "为了在模型为dynamic类型的视图中使用一个匿名对象，我们在上一篇文章里为匿名对象创建了对应的动态类型。于是在使用时，我们会创建动态类型的对象，然后将匿名对象的属性赋值给动态对象的公开字段上。在赋值时我们使用了反射，再加上这个方法使用比较频繁，因此使用更好的方法来优化性能便是个很自然的选择。在.NET 1.0中，我们需要Emit；在.NET 2.0中则增加了DynamicMethod，相对简化了单个动态方法的创建过程；在.NET 3.5中则增加了可编译表达式树，可谓前进了一大步――那么在.NET 4.0中呢？ "
    },
    {
        "Title": "当类型为dynamic的视图模型遭遇匿名对象",
        "Link": "/2010/05/asp-net-mvc-dynamic-view-model-binding-error-with-anonymous-types.html",
        "BriefIntro": "当年在ASP.NET MVC 1.0时代我提到，在开发时最好将视图的Model定制为强类型的，这样可以充分利用静态检查功能进行排错。不过有人指出，这么做虽然易于静态检查，但是定义强类型的Model类型实在是太麻烦了，因此也出现了基于SmartBag等折衷方案。强类型是一种极端方案，而在C# 4.0中我们又可以使用另一个极端，那就是让Model成为dynamic类型，这样在视图中便可以完全自由地获取数据了。不过，在使用匿名对象的情况下视图会抛出奇怪的“无法找到成员”异常，我们必须解决这个问题。 "
    },
    {
        "Title": "您精通XXX吗？那么就来谈谈它的缺点吧",
        "Link": "/2010/05/learn-from-disadvantages.html",
        "BriefIntro": "“精通”这个词已经被用滥了，当年招人时收到过无数简历，继而发现，似乎简历上面不写几个“精通”还真对不起咱这张脸。那么到底啥叫精通呢？应该是对某样东西无比了解，不能再了解的程度吧――不过地球人都知道，简历上的“精通”已经算不得数了。那么，如果我们真要考察一个人（比如自己）对某件事情是否“精通”，又有什么合适方法呢？我觉得有个方式比较靠谱，那就是谈谈这东西的缺点。 "
    },
    {
        "Title": "编程语言的发展趋势及未来方向（3）：函数式编程",
        "Link": "/2010/05/trends-and-future-directions-in-programming-languages-by-anders-3-functional-programming-and-fsharp.html",
        "BriefIntro": "这是Anders Hejlsberg在比利时TechDays 2010所做的开场演讲。由于最近我在博客上关于语言的讨论比较多，出于应景，也打算将Anders的演讲完整地听写出来。在上一部分中，Anders阐述了他眼中声明式编程的理念及DSL，并演示C#中一种内部DSL的形式：LINQ。在这一部分中，Anders谈及了声明式编程的另一个重要组成部分：函数式编程，并使用.NET平台上的函数式编程语言F#进行了演示。 "
    },
    {
        "Title": "关于“程序员圈子”说几句废话",
        "Link": "/2010/04/programmers-group-effect.html",
        "BriefIntro": "最近有人在TopLanguage上发了一条，怎么说，我个人感觉写的还不错的帖子。帖子的标题叫做“程序员的虚伪”，里面主要谈的是说如今在程序员社区里有这么一种不好的现象：话说一群人抱成团，有福同享有难同当，一荣俱容一损俱损，你方开张我来捧场，谁遇问题同仇敌忾。这样的风气造就了一些南郭先生，本事不大却感觉良好。这样的事情简直就是一出台湾偶像剧大陆白领剧，俗不可耐矫揉造作──这不就是在说我嘛。 "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（3）：Attribute与Annotation",
        "Link": "/2010/04/why-java-sucks-and-csharp-rocks-3-attribute-and-annotation.html",
        "BriefIntro": "上一篇文章里我谈了Java和C#语言中对于基础类型的不同态度，我认为C#把基础类型视做对象的做法比Java更有“万物皆对象”的理念，使用起来也更为方便。此外，C#拥有一个Java 1.4所不存在的特性，即Attribute（自定义特性），而在之后的Java 5.0中也增加了类似的功能，这便是Annotation（标注）。那么，Attribute的作用是什么，Java中的Annotation和C#中的Attribute又有什么区别呢，Java 5.0中又从C# 1.0中吸收了哪些优点？我们现在就来关注这方面的问题。 "
    },
    {
        "Title": "在QCon中了解到的一些有关Groovy和F#的内容",
        "Link": "/2010/04/something-about-groovy-and-fsharp-from-qcon.html",
        "BriefIntro": "今天参加了QCon Beijing 2010的活动，第一天采访了Groovy和F#两种语言的技术领袖，在交流的过程中了解了不少内容，趁着还有一些印象就记点下来吧。Groovy方面这次来的是社区中贡献最多（没有之一）的Paul King，他也是《Groovy in Action》的作者之一。F#方面参加QCon的是Timothy Ng，年轻高大帅气，生于香港，四岁去加拿大，毕业后加入微软至今，目前是F#开发团队的Senior Dev Lead。与Tim晚餐时聊了许多，最大的收获是……发现我的英语也不是太哑巴嘛。 "
    },
    {
        "Title": "为什么我要反对北大青鸟",
        "Link": "/2010/04/why-i-say-no-to-aptech.html",
        "BriefIntro": "您是否知道最近北大青鸟有什么新闻吗？嗯，最近的电脑报发表了“中国IT培训现状大调查之二”一篇题为“北大青鸟高薪就业迷雾”的文章，描述了北大青鸟的种种问题。我这里不想用“揭露”、“黑幕”等激烈的词汇，但我会全文转载这篇文章，大家可以自己阅读，自行评价。客观地说，这篇报道的内容是否属实我不敢打保票，但是我愿意相信其中的说法，因为北大青鸟及其他一些培训机构的学生于我的感觉，真的不敢恭维。 "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（2）：基础类型与面向对象",
        "Link": "/2010/04/why-java-sucks-and-csharp-rocks-2-primitive-types-and-object-orientation.html",
        "BriefIntro": "既然已经谈过这次语言比较的意义与目的，而完整的幻灯片和录音也已经放出，那么接下来自然是详细讨论了。在这篇文章中，我会对两个语言的基本特征进行简单描述，并主要讨论两者对于基础类型的处理方式。在我看来，Java语言对于基础类型的处理方式，并不如C#中值类型般妥当。如果您有任何觉得不妥或是想要补充的意见，请不吝回复。由于C# 1.0发布于2002年，因此本文内容将基于Java 1.4及C# 1.0的情况。 "
    },
    {
        "Title": "幻灯片：Why Java Sucks and C# Rocks",
        "Link": "/2010/04/why-java-sucks-and-csharp-rocks-slides-final-version.html",
        "BriefIntro": "昨天在5173与博客园联合举办的技术交流活动中进行了演讲，现在幻灯片终于可以放出了。当然，光看幻灯片本身的效果不大，在演讲过程中我进行了非常多的代码演示和说明，幻灯片本身只能算是一个提纲，因此各位没有来听演讲的朋友，还是等我慢慢地对这个话题进行详细讨论吧。只是有些话我不得不说：Java平台的开放只能反衬出一些Java粉丝的狭隘心态和视野，我一个封闭的微软平台的封闭的.NET程序员，如果心态和眼界都比您要开阔，这难道不够讽刺吗？ "
    },
    {
        "Title": "Why Java Sucks and C# Rocks（1）：比较的意义与目的",
        "Link": "/2010/04/why-java-sucks-and-csharp-rocks-1-thoughts-and-goals.html",
        "BriefIntro": "消息发布之后，许多朋友都表示对我这个主题的关注――无论是正面还是负面的――这让我很高兴。不过说实话，我原本并没有打算写这篇文章。我原本的打算是从一开始就进行技术方面的讨论，但是大家在前文的反馈让我把一些问题想得更清楚了，也认识到有些东西可能需要先说在前面可以有更好的效果。希望各位朋友可以继续给我一些反馈，这样我可以在必要的时候进行补充更完整的内容。这次的话题很有价值，我想把它做的更好。 "
    },
    {
        "Title": "编程语言的发展趋势及未来方向（2）：声明式编程与DSL",
        "Link": "/2010/04/trends-and-future-directions-in-programming-languages-by-anders-2-declarative-programming-and-dsl.html",
        "BriefIntro": "这是Anders Hejlsberg在比利时TechDays 2010所做的开场演讲。由于最近我在博客上关于语言的讨论比较多，出于应景，也打算将Anders的演讲完整地听写出来。在上一部分中，Anders指出语言本身在过去的数十年里并没有明显的发展，并给出了他眼中编程语言发展趋势的预测。在现在的第2部分中，Anders将阐述声明式编程的理念及DSL，并演示C#中一种内部DSL的形式：LINQ。 "
    },
    {
        "Title": "编程语言的发展趋势及未来方向（1）：历史回顾及趋势概述",
        "Link": "/2010/04/trends-and-future-directions-in-programming-languages-by-anders-1-history-and-trends.html",
        "BriefIntro": "这是Anders Hejlsberg在比利时TechDays 2010所做的开场演讲。由于最近我在博客上关于语言的讨论比较多，出于应景，也打算将Anders的演讲完整地听写出来。我希望这个讲座可以从侧面回答某些朋友关于“语言讨论是否有价值”的疑问，并且展示出目前语言的发展状况以及微软在这方面的努力。完整内容将分为多次发表，每天一小部分，每次大约10分钟的演讲内容。等不及的朋友也和可以下载演讲视频一睹为快。现在的第1部分则包含Anders对编程语言发展的历史回顾，以及对趋势简单概述。 "
    },
    {
        "Title": "演讲预告：Why Java Sucks and C# Rocks",
        "Link": "/2010/04/speech-why-java-sucks-and-csharp-rocks.html",
        "BriefIntro": "怎么样，这个标题是不是足够吸引眼球？嗯，我下个星期便打算在5173和博客园举办的技术交流会上讨论一下这个话题。原本这是一个为盛大创新院内部分享交流会准备的内容，不过正好5173要举办一个技术交流会──还有比那儿更适合这个话题的地方吗？直到现在，还有许多朋友认为，Java语言和C#的区别并不大，也有人认为C#只是语法糖比较多，没有什么特别的――而我现在便打算详细阐述C#是如何改变开发人员“编程理念”及“思维方式”，并在生产力上大大超越Java语言。我也打算在会后将这个内容详细地总结成一系列文章，除了发表在博客上，还会转载去一些Java开发社区，看看那儿的弟兄们对这个话题会怎么看。 "
    },
    {
        "Title": "Keynote，对不起，我爱的是PowerPoint 2007",
        "Link": "/2010/04/powerpoint-2007-vs-keynote-for-beginners.html",
        "BriefIntro": "两个月前我加入了水果党，使用至今，感觉挺好，尤其是触摸板的多点触摸功能令人着迷。一直听许多果粉说Mac系统在艺术设计方面表现一流，其办公套件iWork更是远胜于Microsoft Office，后者的流行完全是“劣币驱逐良币”的结果。耳濡目染之下我自然对此期待万分，于是在Open Office及NeoOffice这两个免费的办公套件身上无法得到快感的情况下，兴冲冲地花费了近700块钱购买了一套正版的iWork。然后打开Keynote制作幻灯片，心想终于可以尝试一下超越PowerPoint 2007的产品了。可能是期望过高吧，初尝Keynote的感觉只能用“大失所望”来形容――而且，真的是我期望过高吗？ "
    },
    {
        "Title": "F#与ASP.NET（2）：使用F#实现基于事件的异步模式",
        "Link": "/2010/04/fsharp-for-asp-net-2-implement-event-based-asynchronous-pattern-with-fsharp.html",
        "BriefIntro": "在上一篇文章中，我们的简单讨论了.NET中两种异步模型以及它们在异常处理上的区别，并且简单观察了ASP.NET MVC 2中异步Action的编写方式。从中我们得知，ASP.NET MVC 2的异步Action并非使用了传统基于Begin/End的异步编程模型，而是另一种基于事件的异步模式。此外，ASP.NET MVC 2对于这种异步模式提供了必要的支持，使此方面的程序设计变得相对简单一些。但是，简单的原因主要还是在于已经由其他组件提供了良好的，基于事件的异步模式。那么现在我们就来看看一般我们应该如何来实现这样的功能，以及F#是如何美化我们的生活的吧。 "
    },
    {
        "Title": "F#与ASP.NET（1）：基于事件的异步模式与异步Action",
        "Link": "/2010/04/fsharp-for-asp-net-1-event-based-asynchronous-pattern-and-async-action.html",
        "BriefIntro": "提高ASP.NET应用程序伸缩性的有效手段之一便是使用异步请求。而在ASP.NET MVC 1中是不能直接支持异步Action的，因此我们需要使用一些简单的Hack方式来实现这一点。不过简单的Hack毕竟无法利用ASP.NET MVC的完整功能，幸好ASP.NET MVC 2已经正式支持ASP.NET中的异步请求处理方式，并且通过一种比较易于使用的方式提供给开发人员使用。只可惜，由于语言层面的约束，这种使用方式还是有些不便，而此时便是F#的用武之地了。 "
    },
    {
        "Title": "最容易令初学者混乱的F#命令",
        "Link": "/2010/03/reference-cell-retrieval-in-fsharp.html",
        "BriefIntro": "话说，其实我也是F#的初学者，至少相对于C#等语言来说一定是这样的。而对于初学者，或是C#和F#混用的程序员来说，我认为最F#中最容易令人混乱的命令是Reference Cells的取值操作了。下面便详细谈谈这么说的原因，及建议的应对方法。 "
    },
    {
        "Title": "如何成为一名优秀的博主（PPT）",
        "Link": "/2010/03/how-to-become-a-good-tech-blogger.html",
        "BriefIntro": "如何成为一名优秀的博主？这是一个问题。我一直到处建议别人写博客，写技术博客，但是还真没想过或总结过这个问题。上个星期微软“社区经营计划”讲解了微软内部关于撰写优秀博客的一些方法和注意事项――同时微软的朋友也希望我分享一下我的经验，于是我制作了这份PPT。后来发现，我写的内容和微软的内部资料倒有相当部分不谋而合的地方，自然微软的资料更为美观，图示丰富，而我的内容则相对更有山寨的感觉。 "
    },
    {
        "Title": "盛大创新院赞助.NET技术会议意见征询",
        "Link": "/2010/03/snda-dotnet-conference-advices.html",
        "BriefIntro": "各位可能大都知道，我于不久前加入了盛大创新院。最近我了解到，创新院这边对于社区开展技术会议的活动也是相当支持的，并且对每个社区的会议会有资金和人员上的支持。这几天我和副院长聊了一下，他表示只要组织得当，创新院也支持把技术交流会办成一个有规律的活动，定期举行。事实上，创新院已经赞助过多次Flash及产品设计方面的技术会议。当然，会议的目的是进行技术交流，对观众自然是完全免费的。因此，我打算在5月或6月份在上海举办一次.NET技术会议，在此征求一下您的意见。 "
    },
    {
        "Title": "博客评论使用方式介绍",
        "Link": "/2010/03/comment-markup-help.html",
        "BriefIntro": "新博客终于上线了，与旧博客不同的是，我在评论方面花了许多精力，希望可以提供一个优秀的评论方法。我对优秀的定义是“格式丰富，使用简单”，再加上由于是技术博客，因此对于代码片段也要有较好的支持。最终，我选择使用Markdown作为评论的输入标记。Markdown是一个轻量的标记规则，但对于评论应用来说也已经足够丰富了。Markdown的运用非常广泛，例如著名的编程网站Stack Overflow也使用了这种标记语言。事实上，我这篇评论使用方式的介绍也有相当部分是翻译自Stack Overflow编辑器的帮助，自然还有部分自定义的内容（主要是对于代码片段的支持）。 "
    },
    {
        "Title": "F#中的异步及并行模式（3 - 下）：代理的进一步使用",
        "Link": "/2010/03/async-and-parallel-design-patterns-in-fsharp-3-more-agents.html",
        "BriefIntro": "之前的文章中我们了解了F#中并行及交互式程序的编程方式。在本系列的第3部分中，我们会来探索F#中轻量级的，交互式的代理，以及与代理有关的一些模式，包括隔离的内部状态。（译注：由于原文内容较多，译文拆成两段进行。在上半段文章中讨论了代理的基本使用方式，而下半段则讨论关于代理使用中更进一步的模式。） "
    },
    {
        "Title": "F#中的异步及并行模式（3 - 上）：代理的基本使用",
        "Link": "/2010/03/async-and-parallel-design-patterns-in-fsharp-3-agents.html",
        "BriefIntro": "之前的文章中我们了解了F#中并行及交互式程序的编程方式。在本系列的第3部分中，我们会来探索F#中轻量级的，交互式的代理，以及与代理有关的一些模式，包括“隔离的内部状态”。（译注：由于原文较长，因此译文分为两段，目前是第一段，讲解了F#中异步代理的基本使用方式。） "
    },
    {
        "Title": "一种以ID特征为依据的数据分片（Sharding）策略",
        "Link": "/2010/03/sharding-by-id-characteristic.html",
        "BriefIntro": "假如您有一个应用程序，随着业务越来越有起色，系统所牵涉到的数据量也就越来越大，此时您要涉及到对系统进行伸缩（Scale）的问题了。系统的扩展方式往往分为“向上伸缩”和“向外伸缩”两种，而从“硬件成本”或是“系统极限”的角度来说，“向外伸缩”一般都会优于“向上伸缩”，因此大部分上规模的系统都会在一定程度上考虑“向外”的方式。由于许多系统的瓶颈都处在数据存储上，因此一种叫做“数据分片（Database Sharding）”的数据架构方式应运而生，本文便会讨论这种数据架构方式的一种比较典型的实现方式。 "
    },
    {
        "Title": "F#中的异步及并行模式（2）：反馈进度的事件（包含Twitter示例）",
        "Link": "/2010/03/async-and-parallel-design-patterns-in-fsharp-2-reporting-progress-with-events.html",
        "BriefIntro": "上一篇文章中谈到，“异步CPU并行”与“异步I/O并行”两个模式的限制之一便是无法通知组合操作的进度或结果。在这篇文章中，我们讲关注一个常见的异步模式：反馈进度的事件（Reporting Progress with Events），这是一种用于强大而优雅的做法，用于在某个边界之后对并行的执行过程加以封装，并同时汇报执行的结果或是进度。在文章最后，我们会使用这个设计模式开发一个示例，从Twitter中获取一系列记录。 "
    },
    {
        "Title": "谈谈微软技术，以及对待技术应有的态度",
        "Link": "/2010/03/microsoft-technology-and-the-attitude.html",
        "BriefIntro": "昨晚在家上网，一边对那些有趣而奇妙的微软技术感叹不已，同时却又产生出一种忿忿之情。为什么？因为在国内的技术圈子里，经常有一种在我看来莫名奇妙的鄙视微软技术的风气。这样的风气在国内的推特圈里也非常明显，基本上只有我一个人对微软的技术抱有好感并“勇于”和大量意见向左的人争辩。忿忿之余，我便在推特上不断表达我对这种风气的抱怨及否定，在这个过程中也基本表达了我在这方面的大部分看法，在这里也进行一番总结总结吧。同时，我也想对微软社区的许多弟兄讲一些话。 "
    },
    {
        "Title": "F#中的异步及并行模式（1）：并行CPU及I/O计算",
        "Link": "/2010/03/async-and-parallel-design-patterns-in-fsharp-1-parallelizing-cpu-and-io-computations.html",
        "BriefIntro": "F#是一门并行（parallel）及响应式（reactive）语言。这个说法意味着一个F#程序可以存在多个进行中的运算（如使用.NET线程进行F#计算），或是多个等待中的回应（如等待事件或消息的回调函数及代理对象）。 F#的异步表达式是简化异步及响应式程序编写的方式之一。在这篇及今后的文章中，我会探讨一些使用F#进行异步编程的基本方式──大致说来，它们都是F#异步编程时使用的模式。我们从两个简单的设计模式开始：CPU异步并行（Parallel CPU Asyncs）和I/O异步并行（Paralle I/O Asyncs）。 "
    },
    {
        "Title": "MongoDB与Tokyo Tyrant性能比较（2）：并发写入操作",
        "Link": "/2010/02/mongodb-tokyo-tyrant-benchmark-2-concurrent-insert.html",
        "BriefIntro": "在上一次的测试中我们比较了MongoDB与Tokyo Tyrant的Table Database两种存储方式的性能。不过由于条件限制，我只能在自己的MBP上测试，而这至少会带来两个问题。首先，真实环境下客户端和服务器是通过内网连接的，它的性能比本地回环要慢不少，一些和网络传输性能有关的问题可能会体现不出。其次，由于无法进行并发测试（并发测试的客户端资源占用较高，放在同一台机器上准确性较差），这又和生产环境有很大区别了。因此，我前两天向同事借了台性能测试用的机器，希望可以得到更可靠的结果。 "
    },
    {
        "Title": "MongoDB与Tokyo Tyrant性能比较（1）：基础CRU操作",
        "Link": "/2010/02/mongodb-tokyo-tyrant-benchmark-1-basic-cru-operations.html",
        "BriefIntro": "以前的项目大都把数据存放在关系型数据库中，但是它们的问题比较明显的，一是在数据量上升的情况下伸缩性比较差，且进行结构调整的代价比较高。因此现在有个所谓NoSQL的“运动”也逐渐普遍起来了，它便是借助一些非关系型存储方式来开发项目。因此在新项目里，我也想尝试一下使用之前一直只是“听说”的存储方式。MongoDB和Tokyo Tyrant都是其中的典型代表，那么现在就来比较一下它们对于基本CRU操作的性能。 "
    },
    {
        "Title": "为什么JVM上没有C#语言？浅谈Type Erasure特性",
        "Link": "/2010/02/why-not-csharp-on-jvm-type-erasure.html",
        "BriefIntro": "JVM上目前已经有许多语言了：JRuby，Jython，也有一些特定于JVM平台的语言，如Scala和Groovy等。但是，为什么JVM上没有C#语言呢？按理说，这门和Java十分相似，却又强大许多的语言更容易被Java程序员接受才对。有人说，Sun和微软是对头，怎么可能将C#移植到JVM平台上呢？嗯，有道理，但是为什么社区里也没有人这么做呢（要知道JVM上其他语言都是由社区发起的）？其实在我看来，这是受到了技术方面的限制。例如：Type Erasure。 "
    },
    {
        "Title": "哥谈的是语言，不是寂寞",
        "Link": "/2010/02/programming-languages-platform.html",
        "BriefIntro": "经常看到一些文章在谈论语言，例如“哪个语言更有前途”，“语言选择是否关键”。我是个语言粉丝，但是看到这些文章总有一些奇怪的感觉。因为在我看来，这些文章谈的东西都不是我眼中的语言――可能与国内技术环境有关，语言本身被淡化了，例如，谈语言的时候涉及更多的却是“平台”方面的内容。那么我现在便来描述一下我眼中的“语言”该如何谈论吧――下次在我猛砍Java语言时也好有个参考。 "
    },
    {
        "Title": "浅谈字节序（Byte Order）及其相关操作",
        "Link": "/2010/02/byte-order-and-related-library.html",
        "BriefIntro": "最近在为Tokyo Tyrant写一个.NET客户端类库。Tokyo Tyrant公开了一个基于TCP协议的二进制协议，于是我们的工作其实也只是按照协议发送和读取一些二进制数据流而已，并不麻烦。不过在其中涉及到了“字节序”的概念，这本是计算机体系结构/操作系统等课程的基础，不过我还是打算在这里进行简单说明，并且对.NET中部分类库在此类数据流处理时的注意事项进行些许记录与总结。 "
    },
    {
        "Title": "总结：史上第一混乱、程序员的爱情、Nobody & Sorry Sorry",
        "Link": "/2010/02/play-novel-nobody-sorry-sorry.html",
        "BriefIntro": "星期六是我的休息日，这天一般我不安排自己做什么和工作有关的事情，一般就是去看看电影，出去逛逛，或者在家上上网吹吹牛。昨天总结了一部分由推特上的讨论，现在继续剩下的一部分。不过，这次的内容可能就要和技术或产业略远一些了，其中大部分是我自己的一些体会和感想。现在我打算谈三个东西，一是《史上第一混乱》这部话剧，《程序员的爱情》这本小说，以及Nobody和Sorry Sorry（您不知道这是啥？你成奥特曼啦！）。 "
    },
    {
        "Title": "总结：0 bug事件、交大ACM夺冠",
        "Link": "/2010/02/0-bug-and-sjtu-acm-champion.html",
        "BriefIntro": "如果您还没有上推特（或是还没有想到办法上），那您失去的不光是一个风靡世界的网络应用，您同时还失去了一个优秀的信息获取平台及讨论环境。目前国内大部分靠谱的技术专家都在推特上有帐号，您几乎不会错失任何有价值的信息，更可以参与一些有价值讨论。周六是休息日，因此也在推特上和大家聊得不亦乐乎。不过推特的一个缺陷可能便是难以留住有价值的信息，它们会随着时间推移渐渐消失，因此还是及时记录一下吧。 "
    },
    {
        "Title": "李笑来激起千层浪，赵姐夫力拒众强敌",
        "Link": "/2010/02/twitter-talk-about-ms-dev-at-20100201.html",
        "BriefIntro": "昨天晚上，李笑来（@xiaolai）老师的无心之语却引起了推特上一次前后长达1个多小时的讨论――当时他似乎只是随手发了一句“Apple告诉我们的铁律是：表面功夫一定要做足”便不见了踪影，但是这句话立即引起了众果粉的共鸣。此后，我（@jeffz_cn）的一句评论又引起了众人对微软开发平台的批判之声。在这次讨论中，几乎只有我孤军奋战为.NET平台进行辩解。因此事后有人给出一副对联为此次争论作出总结：李笑来激起千层浪，赵姐夫力拒众强敌。 "
    },
    {
        "Title": "从今日起正式加入水果党",
        "Link": "/2010/02/use-mac.html",
        "BriefIntro": "想来我现在的笔记本也用了将近3年，虽然至今没有出现过任何问题，但更新换代似乎也不是件让人无法接受的事情――再加上老爸正好也需要一台笔记本，于是我想，不如就乘此机会升一下级吧。不过其实我本没有打算那么着急，只是两天前忽然出现了一个千载难逢的机会，一台十分便宜的MBP放在我面前，于是我当机立断，即刻入手。因此我在此庄严宣布：从今日起，我正式加入水果党。 "
    },
    {
        "Title": "光有逻辑也是万万不能的",
        "Link": "/2010/02/logic-is-not-everything.html",
        "BriefIntro": "之前我多次强调“逻辑”在讨论问题时的重要性，我也多次表示说，如果大家都运用合适的逻辑思维来讨论问题，那么论坛上8成吵架可以避免。现在我也想再次探讨一下这个话题，只不过这次我想反过来说：光有逻辑也是万万不能的。除了“逻辑”这个东西之外，讨论问题时还有很多其他东西值得注意。 "
    },
    {
        "Title": "数组排序方法的性能比较（5）：对象大小与排序性能",
        "Link": "/2010/01/sort-array-linq-5-object-size-and-performance.html",
        "BriefIntro": "在我公开测试结果之后，有朋友也进行了其他测试。在测试中我使用的是int数组，经过分析之后我们了解到Array.Sort对于int数组有特殊的优化。于是，某些朋友使用了一些引用类型的数组进行排序，得到Array.Sort方法的性能落后于LINQ排序――虽然由于测试方式的问题，这个结果和结论都不太妥当。不过在讨论的过程中，我们都意识到了一个问题：在其他条件不变的情况下，引用类型的字段越多，Array.Sort方法所需时间就越久。这次我们就来讨论一下这个问题。 "
    },
    {
        "Title": "数组排序方法的性能比较（4）：LINQ方式的Array排序",
        "Link": "/2010/01/sort-array-linq-4-linq-style-array-sort.html",
        "BriefIntro": "经过前两篇文章的分析，我们已经了解了Array.Sort与LINQ排序两种实现方式的差别：前者直接比较两个元素的大小，而后者先选出每个元素的“排序依据”再进行比较。因此，虽然后者需要相对较多的“周边工作”，但由于每次比较时都可以仅仅使用高效的基础类型（如int），因此从整体来看，两者的性能高低难以辨别。不过，既然我们已经了解LINQ排序“高效”的原因，又能否将其利用在数组排序上呢？程序是人写的，此类问题大都有肯定的答案。那么我们现在就来实现一下。 "
    },
    {
        "Title": "数组排序方法的性能比较（3）：LINQ排序实现分析",
        "Link": "/2010/01/sort-array-linq-3-linq-sort.html",
        "BriefIntro": "上次我们分析了Array.Sort方法的实现方式，并了解到类库会为一些特例而使用高性能的排序方式――int数组便是这样一例，因此从测试结果上来看其性能特别高。不过从数据上看，即便是在普通的情况下，Array.Sort的性能也比LINQ排序要高。不过也有朋友从测试中得出的结论正好相反，这又是为什么呢？那么现在，我们再来分析一下LINQ排序的实现方式吧，希望这样可以了解到两者性能差别的秘密。 "
    },
    {
        "Title": "人肉反编译使用yield关键字的方法",
        "Link": "/2010/01/decompile-methods-with-yield-manually.html",
        "BriefIntro": "我认为这是一个真命题：“没有用.NET Reflector反编译并阅读过代码的程序员不是专业的.NET程序员”。.NET Reflector强大的地方就在于可以把IL代码反编译成可读性颇高的高级语言代码，并且能够支持相当多的“模式”，根据这些模式它可以在一定程度上把某些语法糖给还原，甚至可以支持简单的Lambda表达式和LINQ。只可惜，.NET Reflector还是无法做到极致，某些情况下生成的代码还是无法还原到易于理解――yield关键字便是这样一个典型的情况。不过还行，对于不复杂的逻辑，我们可以通过人肉来“整理”个大概。 "
    },
    {
        "Title": "昨日搬至办公室的书籍",
        "Link": "/2010/01/books-20100125-at-snda-office.html",
        "BriefIntro": "由于家里地方小，总有一部分书籍需要跟着我辗转至各公司。其中一些公司只能让我放抽屉（地方小）甚至地板上，而有一些公司就能让我把书都摞桌子上。昨天下午我特地来了一次办公室搬运书籍。灭霍霍，可真是一个体力活。 "
    },
    {
        "Title": "土人眼中的差距：That’s Why I Chose Yale",
        "Link": "/2010/01/why-i-chose-yale.html",
        "BriefIntro": "上周五中午我看了一个视频：That's Why I Chose Yale（我选择耶鲁大学的原因），是由耶鲁大学的学生自导自演自己拍摄、剪辑的短片。这部短片直接就把我看哭了――好吧，还差一点点，但是其中的震撼是难以描绘的，建议您一定要自己体会一下。震撼源于各方面的差距，同样是大学，同样是大学生，为什么差距就那么大呢？而且，这几乎已经是我无法去弥补的差距了，因此遗憾，因此震撼。 "
    },
    {
        "Title": "数组排序方法的性能比较（2）：Array.Sort<T>实现分析",
        "Link": "/2010/01/sort-array-linq-2-array-sort.html",
        "BriefIntro": "昨天我们比较了Array.Sort方法与LINQ排序的性能，知道了LINQ排序的性能以较大幅度落后于Array.Sort方法。而对于Array.Sort来说，性能最高的是其中使用Comparer.Default作为比较器的重载方法。在前文的末尾我们做出了推测：由于排序算法已经近乎一个标准了（快速排序），因此从算法角度来说，Array.Sort方法和LINQ排序上不应该有那么大的差距，因此造成两者性能差异的原因，应该是具体实现方式上的问题。 "
    },
    {
        "Title": "数组排序方法的性能比较（1）：注意事项及试验",
        "Link": "/2010/01/sort-array-linq-1-notes-and-benchmark.html",
        "BriefIntro": "昨天有朋友写了一篇文章，其中比较了List的Sort方法与LINQ中排序方法的性能，而最终得到的结果是“LINQ排序方法性能高于List.Sort方法”。这个结果不禁让我很疑惑。因为List.Sort方法是改变容器内部元素的顺序，而LINQ排序后得到的是一个新的序列。假如两个排序方法的算法完全一致，LINQ排序也比对方多出元素复制的开销，为什么性能反而会高？如果LINQ排序的算法/实现更为优秀，那为什么.NET Fx不将List.Sort也一并优化一下呢？于是今天我也对这个问题进行了简单的试验。 "
    },
    {
        "Title": "今日入职盛大创新院",
        "Link": "/2010/01/1651772.html",
        "BriefIntro": "在去年年底的总结中，我谈到放弃所谓的创业，想要加入一家国内的大公司安心发展技术，正所谓“打怪升级”。不过，其实在写完文章不久之后（大约数个小时），我就收到了盛大创新院给我的offer。在家休息了整整两周时间后，今天我终于入职了，因此我现在终于有了个颇为响亮的头衔。好吧，当然这不是关键，当然这终究让我梦想中“搞研究”的心理小小地满足了一把。 "
    },
    {
        "Title": "浅谈代码的执行效率（4）：汇编优化",
        "Link": "/2010/01/talk-about-code-performance-4-asm-optimization.html",
        "BriefIntro": "终于谈到这个话题了，首先声明我不是汇编优化的高手，甚至于我知道的所有关于汇编优化的内容，仅仅来自于学校的课程、书本及当年做过的一些简单练习。换句话说，我了解的东西只能算是一些原则，甚至也有一些“陈旧”了――不过我想既然是一些原则性的东西，还是能够用它来做一定程度的判断。至少我认为，我在博客园里看到的许多关于“汇编优化”也好，“内嵌汇编”也罢的说法，经常是有些问题的。 "
    },
    {
        "Title": "京沪两地Scrum实战营（免费，上海1月23日，北京1月30日）",
        "Link": "/2010/01/1646783.html",
        "BriefIntro": "种种迹象表明，Scrum已经在很多公司得到实施。同时，不争的事实是很多开发人员和团队在实施过程中也遇到了各种各样的问题，包括对Scrum方法本身的认识、辅助实施工具的使用等等。有关Scrum应用和实施的各种问题也在InfoQ网站和其他网站上被广泛讨论和争论。等等这些，组成了我们要举办这次Scrum实战营的基础。我们希望通过这次活动帮助正在进行敏捷实施、Scrum实施的团队更加清晰地理解Scrum，并将其他人的有效经验借鉴到自己的团队中来。本次活动由InfoQ中文站、雅各布森软件（北京）有限公司、微软中国有限公司共同举办，我们期待您的参与！ "
    },
    {
        "Title": "浅谈代码的执行效率（3）：缓存与局部性",
        "Link": "/2010/01/talk-about-code-performance-3-locality.html",
        "BriefIntro": "在前两篇文章里，我们讨论了程序性能的两个方面，一是算法（广义的算法，即解决问题的方法），二是编译器。通过这两个方面，我想表达的意思是，一段程序的执行效率，是很难从表面现象得出结论的，至少从一些简单的层面，如代码的长度是几乎难以说明任何问题――因此一定要进行Profiling才能做到有效的优化。而现在，我们假设两段程序算法基本相同，编译器也只是进行简单的“翻译”，那么……我们能从“表面”看出性能高下吗？ "
    },
    {
        "Title": "按月统计博客园单个用户的发文数量",
        "Link": "/2010/01/fsharp-per-user-posts-by-month-statistics.html",
        "BriefIntro": "这几天在家闲着，便试着写一些小程序。之前有朋友问到“F#能不能写Web”，于是我也就打算这么一试。虽然我能肯定，用F#写Web应用程序不会是问题，不过倒真还没有做过这方面的尝试。我想，如果用F#写Web应用程序，那么它很重要的一点，应该是利用其在异步编程方面的强大特性。最后我决定，使用F#编写一个按月统计博客园单个用户发文数量的简单服务。尝试的结果是――还有些问题没有解决。不管怎么样，我先把其主体逻辑描述一下吧。 "
    },
    {
        "Title": "浅谈代码的执行效率（2）：编译器的威力",
        "Link": "/2010/01/talk-about-code-performance-2-compiler.html",
        "BriefIntro": "在上一篇文章中，我主要表达了这样一个观点：影响程序效率的关键之一是算法，而算法的选择与优化，和是否多一个赋值少一个判断的关系不大。关于算法的选择，我谈到其理论上的复杂度，并不直接反映出效率。因为在实际运用时，数据的规模，形式等等都会涉及到算法的实际效用。一个时间复杂度低的算法并不代表任何情况下的效率都高。这是“实际”和“理论”的区别之一。现在我打算来谈一下另一个比较“实际”的东西：编译器对于程序效率的影响。 "
    },
    {
        "Title": "浅谈代码的执行效率（1）：算法是关键",
        "Link": "/2010/01/short-code-is-not-always-fast-1-algorithms.html",
        "BriefIntro": "前一段时间在博客园里看到这样一篇文章，那位兄弟谈到程序效率的关键是“简短”。他说，“程序越简短，其可执行代码就越少，就越有效率”，而在编写程序的时候，“要尽量改进我们的算法，而改进算法中最重要的一条，就是减少语句”。这句话从表面上似乎正确，但我认为性能这问题不能用“简短”这种方式去思考，否则会进入一些误区。我整理了一下思路，希望可以从几个方面把详细谈一下这个问题。首先我想说的是：“简短”不是关键，“算法”更加重要。 "
    },
    {
        "Title": "AV不识爱卖克，便看三弟也枉然",
        "Link": "/2010/01/1640998.html",
        "BriefIntro": "阿凡达，已然无人不知无人不晓。江湖流传：“AV不识爱卖克，就看三弟也枉然”。此处AV自然指的就是Avatar，这句话意思是说，如果你没有看iMax的阿凡达，就算是看了3D版也等于没看过。因此，对于全国只有11块的iMax屏幕，大家自然就是疯抢了。而上海这边，只有位于人民广场的和平影都有这条件，试想全上海有这想法的人都涌到同一个地方，抢这个每日一千多（350 * 4场）人次的机会……是什么景象。 "
    },
    {
        "Title": "一次批量修改博客文章的经验（下）：操作过程",
        "Link": "/2010/01/batch-update-posts-1-progress.html",
        "BriefIntro": "上一篇文章中我们进行了一些预备工作，主要是了解了该如何使用MetaWeblog API读取和修改博客园的文章――包括同步和异步两种调用方式。此外，由于F#在异步调用方面的优势，我决定使用F#来完成批量修改文章任务。这个任务并不困难，但很“危险”，一旦出错可能之前的文章就无法恢复了。因此，我把这个任务拆成多个步骤，每个步骤都会将数据保存在硬盘上。由此，即便出错，还是有挽回的余地。 "
    },
    {
        "Title": "一次批量修改博客文章的经验（上）：准备工作",
        "Link": "/2010/01/batch-update-posts-1-preparation.html",
        "BriefIntro": "这几天赋闲在家，除了看书和还债（如RSS订阅），终于把一直以来想做却拖着的事情完成了：批量去除博客文章段首的空格。这个过程并不难，只需要按部就班地去做就行了，一切资料都可以在互联网上搜索到。不过我还是打算记录一下，也是为了今后再做类似工作时有个参考，少走一些弯路。 "
    },
    {
        "Title": "F#中的XML序列化",
        "Link": "/2010/01/fsharp-xml-serialization.html",
        "BriefIntro": "这两天在用F#写一小段代码，需要把一些对象存到外部文件中去。这个功能很容易，因为.NET本身就内置了序列化功能。方便起见，我打算将这个对象序列化成XML而不是二进制数据流。这意味着我需要使用XmlSerializer而不是BinaryFormatter。这本应没有问题，但是在使用时候还是发生了一些小插曲。 "
    },
    {
        "Title": "2009年末，多少进行一些总结和展望吧",
        "Link": "/2009/12/summary-2009.html",
        "BriefIntro": "时间就这样悄无声息地到了2009年的最后一天，回首我这过去的一整年，可以用一句废话来总结，那就是“既有遗憾，也有收获”。不管怎么样，多少也应该总结一下吧――尤其是此时此刻，对我来说可谓是一个新的起点。自然，在技术博客上，终究还是围绕着“事业”谈谈吧。 "
    },
    {
        "Title": "使用Fiddler辅助观看InfoQ的视频",
        "Link": "/2009/12/fiddler-infoq-video.html",
        "BriefIntro": "InfoQ是一个好地方，而我认为其中最有价值的资源，便是其中的演讲视频。InfoQ在这方面有个特点：在演讲视频下方提供了清晰的幻灯片，而在播放的同时，还会根据进度进行切换。这观看体验自然比单纯的演讲录像要高出许多。可惜的是，时不时有朋友会向我反馈说，InfoQ实在是太慢，几乎无法流畅地观看视频。由于一时半会儿InfoQ也不会在中国放CDN，因此视频加载速度这问题……几乎无法解决。还好，如果我们退而求其次，至少可以使用Fiddler等工具来“缓解”这个问题。 "
    },
    {
        "Title": "五十种语言的“圣诞快乐”（下）：F#实现",
        "Link": "/2009/12/merry-christmas-in-fifty-languages-2-fsharp-async-workflow.html",
        "BriefIntro": "不知道大家的圣诞节过的如何？有没有玩点啥有趣的东西？上次的文章中我们主要分析了使用Google Translate进行文字翻译的方式，并使用C#写了一个简单的的翻译程序，效果良好。不过，在平时开发过程中，对于此类问题我常用F#来解决这样的问题。那么使用F#来实现此类任务有什么优势吗？不错，我们现在便来看看这个问题。 "
    },
    {
        "Title": "推荐内容索引",
        "Link": "/2009/12/valuable-posts-index.html",
        "BriefIntro": "写了不少文章，其中有不少比较用心的系列。积累了那么久，我在博客上也已经讨论过了各种问题。许多人提问的时候，我会说我写过某某文章，可以搜一下，但得到的反馈经常是找不到。其中一个原因是那些弟兄还不太会用搜索引擎――或是懒，但也有可能是以前的文章的确是“沉没”了。无论是博客园还是独立博客，对于内容的组织和管理还做得不够好，所以在这方面有所突破之前，还是通过手动整理的方式来保留重点内容吧。 "
    },
    {
        "Title": "五十种语言的“圣诞快乐”（上）：分析与实现",
        "Link": "/2009/12/merry-christmas-in-fifty-languages-1-analysis.html",
        "BriefIntro": "您知道“圣诞快乐”在不同语言中的写法吗？Google Translate知道。不过Google Translate好像并不希望我们可以直接获得这些内容――但这并不能阻止我们这些光荣的程序员来获得这些信息。 "
    },
    {
        "Title": "老赵谈IL（4）：什么时候应该学IL，该怎么学IL",
        "Link": "/2009/12/my-view-of-il-4-how-to-learn-il.html",
        "BriefIntro": "又是一个拖了半年的系列，可能是前几篇主要以事实为准，举例子的文章总是比较容易写的，因此十分顺畅。而最后一篇打算做一个总结，以讲道理为主――却发现该将的似乎都已经讲完了。不过做事要有始有终，该完成的也必须要完成。那么现在就来谈谈我的一些个人看法：什么时候应该学IL，以及应该怎么学IL。 "
    },
    {
        "Title": "重谈字符串连接性能（下）：分析优化",
        "Link": "/2009/12/string-concat-perf-3-profiling-analysis.html",
        "BriefIntro": "经过之间的性能比较，我们得知StringBuilder的性能并非时时最优，再经过实现分析，我们大致了解了StringBuilder的实现方式。虽然在此之前，大家也基本已经了解StringBuilder的实现原理，也有不少朋友指出了它性能缺陷的原因。不过“严谨”起见，寻找性能问题的方式应该是进行Profiling，然后找出性能关键再进行优化――而不是纯粹进行“阅读”这种静态分析方式。 "
    },
    {
        "Title": "使用Profiler分析程序性能",
        "Link": "/2009/12/profiler-sampling.html",
        "BriefIntro": "三个星期之前我向大家求助说，VS的Profiler分析程序性能时无法跟踪框架内部的方法调用。当时我做了不少尝试，例如下载并配置了.NET Framework的symbol文件和源代码，还尝试使用了ANTS Profiler和CLR Profiler等其他工具，最终还是没有成功。Ivony...老大在评论中告诉我说Sampling方式可以获得比Instrumentation更多的信息，不过我觉得Sampling得到的结果并不像我的目标那样干净，因此还是在寻找Instrumentation的方式。不过最终耗费了一个GTSC的支持点数，才被告知――的确应该使用Sampling。 "
    },
    {
        "Title": "在.NET平台上使用Scala语言（下）：分析",
        "Link": "/2009/12/scala-for-dotnet-2-analysis.html",
        "BriefIntro": "上一篇文章里我们简单尝试了在Scala里编写.NET应用程序。这个过程并不困难，因为似乎Scala官方已经对此已经有较好的支持了。我们要做的只是“获取工具”，“编译成IL”，最后再“生成程序集”即可。那么，这些工具究竟做了些什么，Scala究竟又是如何支持.NET平台的，它的可用性究竟如何，我们还需要进一步的分析及尝试。 "
    },
    {
        "Title": "在.NET平台上使用Scala语言（上）：初尝",
        "Link": "/2009/12/scala-for-dotnet.html",
        "BriefIntro": "Scala是Java平台上的一门新兴起的语言，我也不止一次在博客上提到它。我非常希望它可以取代Java这种劣质语言，让Java平台的生产力上一个台阶。事实上，Scala从一开始――或者说“很早”就对生成.NET程序集提供了支持。只可惜，毕竟还是Java平台的东西，.NET方面的资源少之又少，不过我们还是可以进行一番尝试的。 "
    },
    {
        "Title": "定制Paste from Visual Studio插件（下）",
        "Link": "/2009/12/vspaste-customization-2.html",
        "BriefIntro": "上一篇文章里我们进行了简单的实验，验证了通过修改IL生成新插件的可行性，不过我们要做的事情还有很多，因为我们实际要做的事情其实是……插入行号。这需要我们补充新的逻辑，并且对CreateContent进行修改。那么我们又该如何写这大段大段的IL呢？没关系，其实这些事情不懂IL也可以做。 "
    },
    {
        "Title": "定制Paste from Visual Studio插件（上）",
        "Link": "/2009/12/vspaste-customization-1.html",
        "BriefIntro": "我在上一篇文章里谈了我常用Paste from Visual Studio（下文称VSPaste）的插件，这大大方便了我写博客时贴代码的工作。不过今天早上有朋友在我博客后面留言说：“VSPaste没法显示行号，不知大家有没有办法解决？”其实这点很容易，写个小程序，把VSPaste生成的HTML再进行一番处理不就可以了嘛。不过最方便的做法还是让VSPaste直接生成带行号的代码块，不是吗？那么，我们就来自己动手丰衣足食解决这个问题吧。 "
    },
    {
        "Title": "浅谈代码着色（下）：服务器端着色",
        "Link": "/2009/12/syntax-highlighting-server-side.html",
        "BriefIntro": "上篇文章谈了客户端着色，而现在自然就来讨论服务器端着色了。先下个定义：我在这里谈的“服务器端着色”，是指直接从服务器端输出着色效果的做法（与“客户端着色时”输出纯代码文本相对）。至于这个着色效果是如何获得的，例如是由另一个用户直接提供的，还是用户提供纯代码文本，而用服务器端逻辑“着色”，在这里就统称为“服务器端”着色了。不过接下去的讨论，我们还是会作一些区分。 "
    },
    {
        "Title": "浅谈代码着色（上）：客户端着色",
        "Link": "/2009/12/syntax-highlighting-client-side.html",
        "BriefIntro": "作为程序员，写文章时总免不了插入代码，而对代码进行着色几乎已经成为一个基础，一个事实标准。代码着色的确可以大大加强代码的可读性，因此即便是再不待见IDE的朋友，代码着色永远是必不可少的。不过在网页中进行代码着色的方式有很多，现在我们就来对比一下。记得之前也有朋友写过，但我总觉得不够完整，于是还是自己写一下吧。我们先来看客户端的着色方式。 "
    },
    {
        "Title": "总结一下F#中运算符的定义规则",
        "Link": "/2009/12/fsharp-operator.html",
        "BriefIntro": "F#允许开发人员定义或重载各类运算符，合理利用这一规则可以让编程变得方便，让代码更容易阅读。例如，在使用F#的MailboxProcessor的时候，我会习惯于定义一个运算符来代替显式的Post操作。不过，F#的运算符定义规则较为复杂，要搞清楚编译器的整体处理方式着实花费了一番功夫。比较奇怪的是，即便是《Expert F#》中对于这个话题也没有详细的叙述――更夸张的是MSDN的文档也相当马虎，甚至有代码缺失以及与试验不符情况（因为还没有正式发布？）。于是我连看带试，最终打算总结一番，作为备忘的同时也算是补充互联网资源。 "
    },
    {
        "Title": "数十行F#打造简易Comet聊天服务",
        "Link": "/2009/12/fsharp-comet-prototype.html",
        "BriefIntro": "普通的Web应用程序，都是靠大量HTTP短连接维持的。如实现一个聊天服务时，客户端会不断轮询服务器端索要新消息。这种做法的优势在于简单有效，因此广为目前的聊天服务所采用。不过Comet技术与之不同，简单地说，Comet便是指服务器推（Server-Push）技术。它的实现方式是（这里只讨论基于浏览器的Web平台）在浏览器与服务器之间建立一个长连接，待获得消息之后立即返回。否则持续等待，直至超时。客户端得到消息或超时之后，又会立即建立另一个长连接。Comet技术的最大优势，自然就是很高的即使性。而F#实现一个Comet原型，只要几十行代码。 "
    },
    {
        "Title": "在项目中使用Google Closure Compiler",
        "Link": "/2009/12/ikvm-google-closure-compiler.html",
        "BriefIntro": "现在的Web项目总是离不开大量JavaScript，而JS文件的体积也越来越大，也越来越影响页面的感知性能（Perceived Performance）。因此，我们会对JS文件进行压缩，一方面是使用Gzip，而另一方面则是去除JS文件里的注释、空白，并且压缩局部变量长度等等。对于一些成熟的类库来说，它们本身都会提供“完整注释”以及“强烈压缩”两个版本。但是，有时候我们需要自己修复类库里的bug，这只能在注释版中修改，对于压缩版自然就无能为力了。此外，自定义的脚本文件一般也值得一压。因此我在项目中时常会备一个脚本压缩工具。 "
    },
    {
        "Title": "Route组件GetVirtualPath方法性能优化结果",
        "Link": "/2009/12/route-getvirtualpath-optimization.html",
        "BriefIntro": "由于使用Lambda表达式生成URL的方式性能较差，因此我使用Fluent Interface来代替原有的Lambda表达式构建方式。Fluent Interface主要对生成URL的前两个阶段（创建对象及分析对象）进行了优化，分别带来了超过2/3和1/2的性能优化，但因为最后一步，也就是使用Route对象的GetVirtualPath方法构造URL的性能没有提高，因此总体性能只提高了30%。于是我打算重新实现GetVirtualPath方法，希望得到更好的性能。那么优化的结果又如何呢？ "
    },
    {
        "Title": "真有必要去除HTML中的空白字符吗？",
        "Link": "/2009/12/is-it-really-necessary-to-strip-white-space-in-html.html",
        "BriefIntro": "刚才有朋友在MSN上问我说，他的页面中有许多空白字符，打开源文件一看发现这代码稀疏得很。他觉得很浪费，他说有什么办法可以去除它们。我问他“你的页面使用GZip压缩了吗？”他说用了，于是我回答说“那么就不用去除空白字符了，连续空白字符压缩得很好，去掉后效果不大的”。这时我又不禁想到早上那篇《博客园首页优化心得》中也有一条是“去除HTML中的空格、空行”，于是我便打算尝试一下，去除空白字符到底有多少效果。 "
    },
    {
        "Title": "使用值类型LazyString分析字符串",
        "Link": "/2009/12/lazystring.html",
        "BriefIntro": ".NET里提供了值类型与引用类型可谓是一个非常关键的特性，例如开发人员使用值类型时，可以充分控制内存的布局方式，这对于Interop等操作非常重要。不过，其实值类型最重要，最基本的特性还是内存分配上。现在基本上是个.NET开发人员就会叨念说“值类型”分配在栈上，“引用类型”分配在堆上。但是什么是栈什么堆？分配在栈上和堆上的区别是什么？如果说这两个问题太“理论”，那么来个实际的：您在平时什么情况下会使用，或者说，定义一个值类型呢？其实这才是重要的，否则背再多概念也没有用。只可惜从我面试的经验上来看，基本没有多少兄弟能把这些.NET基础完整说清楚。 "
    },
    {
        "Title": "求助：如何使用VS的Profiler跟踪框架内部的方法调用？",
        "Link": "/2009/12/how-to-track-fx-methods-in-visual-studio-profiler.html",
        "BriefIntro": "解决性能问题必须使用Profiler，无论是自己写的实验代码还是一些高级工具，没有数据，而是凭感觉来解决性能问题在绝大部分情况是不靠谱的。VSTS包含了Profiler，也经常见一些博客上用Profiler得到的数据进行性能分析，其中最著名的莫过于Rico Mariani的Performance Quiz系列了。使用VSTS的Profiler可以收集程序运行过程中每个方法的调用次数，所消耗的总时间等等，一目了然，但是我在使用过程中却出现了问题。 "
    },
    {
        "Title": "jQuery Validation插件remote验证方式的Bug",
        "Link": "/2009/12/jquery-validate-remote-bug.html",
        "BriefIntro": "jQuery插件很多，其中一个重要的插件便是jQuery Validation，它的作用是对表单进行验证，还上了jQuery官网。不过奇怪的是，最近用下来感觉有些古怪，因为好像有些死板，已有功能的应变能力还不强，甚至还有个奇怪的Bug。任何项目有Bug其实也正常，但这个Bug其实是一个文档上已经记载了，却没有实现的功能，这就有些说不过去了。这个问题便出在remote验证方式上，还好修改起来非常容易，在此记录一下，也方便以后的参考。 "
    },
    {
        "Title": "做个游戏：设计代码生成特定的调用堆栈",
        "Link": "/2009/12/stack-trace-with-stringbuilder-and-string-concat.html",
        "BriefIntro": "前篇文章里我谈了谈String.Concat与StringBuilder的实现，于是后来有个朋友回复到：“我发现StringBuilder里好像也用了String.Concat。在一次异常中，Exception的StackTrace显示是先发生了String.Concat异常，然后再StringBuilder.Append。”不过经过一些简单的分析，我们会发现StringBuilder.Append方法的各个重载都没有依赖（即调用）String.Concat方法，那么这样的调用堆栈又是如何形成的呢？ "
    },
    {
        "Title": "重谈字符串连接性能（中）：细节实现",
        "Link": "/2009/12/string-concat-perf-2-stringbuilder-implementations.html",
        "BriefIntro": "根据上次的评测结果，我们了解了几种字符串拼接方式的性能高低。从中可以看出，广受追捧的StringBuilder性能似乎并不是最好的，String.Concat方法有时候有时候更适合使用。那么为什么String.Concat方法性能那么高，StringBuilder又为什么落败，而我们又有没有什么可以改进的做法呢？为此，我们不妨动用.NET Reflector这一利器，看一下两者是怎么实现的。 "
    },
    {
        "Title": "各种数组元素复制方式的性能比较",
        "Link": "/2009/12/array-copy-benchmark.html",
        "BriefIntro": "原本这只是“字符串”话题的一个分支，不过后来我发现这个问题单独来看也有一定参考价值，也有一些问题值得讨论的地方，其中也有一些问题希望得到高手指点，最终打算把这个话题独立处理。话不多说，现在就来看看。 "
    },
    {
        "Title": "使用WinDBG + SOS谈对象大小及字符串的结构",
        "Link": "/2009/12/windbg-sos-for-string.html",
        "BriefIntro": "昨天我们使用了一个最最简单的小实验，来检查相同类型的不同对象大小是否相同。当然，我们很轻易地“验证”得出，不同长度的字符串大小是不一样的。不过这种表面现象其实很难说明问题，因此我现在还是用WinDBG + SOS来进行一些检查，希望可以得到一些表面上看不出来的信息。 "
    },
    {
        "Title": "相同类型的每个对象大小都是一样的吗？",
        "Link": "/2009/11/do-all-instances-of-the-same-type-are-equal-in-size.html",
        "BriefIntro": "快速回答：“相同（引用）类型的每个对象大小都是一样的吗？”其实个问题对于大多数情况下来说应该正确的，不过的确也有些类型受到CLR的特殊照顾，因而有那么些例外。我现在尝试使用一些简单的小实验来进行验证，当然它是不严谨的，只能算是一个简单尝试而已。 "
    },
    {
        "Title": "验证fixed关键字效果的小实验",
        "Link": "/2009/11/lab-fixed-keyword.html",
        "BriefIntro": "之前谈到String连接操作的性能，其中会涉及到unsafe操作，而unsafe操作必然会涉及到指针，于是fixed关键字也应运而生。fixed关键字是用来pin住一个引用地址的，因为我们知道CLR的垃圾收集器会改变某些对象的地址，因此在改变地址之后指向那些对象的引用就要随之改变。这种改变是对于程序员来说是无意识的，因此在指针操作中是不允许的。否则，我们之前已经保留下的地址，在GC后就无法找到我们所需要的对象。现在就来我们就来做一个小实验，验证fixed关键字的效果。 "
    },
    {
        "Title": "视频：Microsoft PDC 09，算法及数据结构内容及其他",
        "Link": "/2009/11/videos-of-pdc09-algorithms-data-structure-visual-studio-documentary.html",
        "BriefIntro": "这里又有一些新整理好的视频。Microsoft PDC 09是最近的重头，只要您是搞微软技术的，无论关注哪个技术方面，都可以找到许多有用的内容。我也经常从此类大会中了解许多平时不太关注的内容，也算是保持知识的新鲜度。此外，还有算法和数据结构相关的内容，以及有趣的Visual Studio纪录片。 "
    },
    {
        "Title": "重谈字符串连接性能（上）：性能评测",
        "Link": "/2009/11/string-concat-perf-1-benchmark.html",
        "BriefIntro": "看到这个标题是不是觉得很奇怪呢？字符串连接的性能，这个话题已经被谈了一遍又一遍，一次又一次，似乎已成定论，这又有什么好谈的呢？不过说来奇怪，根据我的实验结果在网上进行搜索，却找不到答案。因此，我现在和大家一起重新再作一次实验并观察结果。在文章最后我也会给出完整的代码，您可以自由地运行，修改，尝试，我们再一起进行交流。 "
    },
    {
        "Title": "一系列技术视频：MIT 6.00，Channel 9 E2E，FP Foundamentals",
        "Link": "/2009/11/technical-videos-mit600-channel9-e2e-fp.html",
        "BriefIntro": "最近看一些技术视频上瘾，每天都要看一两个才满足，有时还会整理整理总结总结。视频的来源主要是Channel 9等外国网站，它们往往必须下载到本地才能观看，代价太高。在线看的也不是没有，不过要么就在Youtube等国内无法访问的站点上，或者就因为国内没有CDN导致播放不畅。因此，我正在把一些视频上传到号称国内第一视频站的优酷上，这样便可以比较方便的播放，甚至可以拖拖看看。目前我准备了三个系列，并且还在不断地进行搬运和整理工作。 "
    },
    {
        "Title": "关于浮点数计算时的精度问题",
        "Link": "/2009/11/precision-of-float-point-calculation.html",
        "BriefIntro": "那个有问题的缩略图生成的方法发布之后，短短半天就有很多朋友响应，其中指出了不少方法中的不少问题，有些也是我没有意识到的。果然集体的智慧是无穷的，一段代码在许多人的眼皮底下经过，想留有bug也不容易。不过，我在这里只能谈一下我写那篇文章的本意了，我认为那篇文章中最主要的问题是，在计算图片尺寸时没有处理好浮点数计算的精度问题。 "
    },
    {
        "Title": "您能看出这个生成缩略图的方法有什么问题吗？",
        "Link": "/2009/11/problem-of-generating-thumbnail-image.html",
        "BriefIntro": "昨天又使用了某个多年以前写的，或者说是“收集”而来的方法。这个方法的作用是根据一幅图片（一般是幅大图）生成它的缩略图。这个方法用了许多年了，一直没有去怀疑过它的正确性，但是昨天忽然发现它一直以来都存在一个问题，虽然可能不是那么明显，而且也不会造成太大问题（否则早就发现了）――但是，这的确是个不妥的地方。这个问题在我看来也有一定借鉴意义，因此我打算把它展示出来。那么，您能否看出它究竟是错在什么地方了呢？ "
    },
    {
        "Title": "老赵书托（3）：深入理解计算机系统",
        "Link": "/2009/11/recommended-reading-3-csapp.html",
        "BriefIntro": "如果说我上次推荐的SICP强调的是编程能力，抽象能力的话，那么CSAPP这本书强调的便是作为一个程序员的基本知识。SICP来自世界顶级学府MIT，而CSAPP也同样出身名门：CMU（卡耐基梅隆大学）。虽然没有SICP那么历史悠久，但它被世界几百所大学（幸运的是也包括我所就读的复旦大学）用作教材也有好多年了。不过我很不喜欢它的中文译名《深入理解计算机系统》――如果有人说它“底层”，我同意。但如果说它“深入”，至少我不那么赞同。 "
    },
    {
        "Title": "再谈Attribute性能优化方式：使用CCI Metadata",
        "Link": "/2009/11/more-on-attribute-cci.html",
        "BriefIntro": "Attribute使用了反射，密集调用时会带来较大开销，因此我们上次提出了一些优化方式，这样就不会产生性能方面的问题了。这个优化方式的关键，主要是使用直接获得构造Attribute的元数据，然后自定义它们的生成方式并缓存，这样就避免了每次获取元数据及反射构造Attribute的开销。我从一开始就抱有这个优化的“思路”，但是上篇文章中最终的做法是受到了heros同学的提示才得出的，因为我一开始还根本不知道CustomAttributeData这个已然内置的类库。我当时在探索的方向是使用CCI Metadata读取程序集中与Attribute相关的元数据。 "
    },
    {
        "Title": "URL生成方式性能优化结果",
        "Link": "/2009/11/url-generation-performance-improvement-result.html",
        "BriefIntro": "继上次发现URL生成的性能问题之后，我最近一直在关注一些细节的性能优化。这些优化方式不是宏观的，理论的，而是在实践上对相同问题的不同做法进行探索。我把探索的过程和结论都发布在博客上了，从结果上看性能提高是比较明显的。但是，把它们用于解决实际问题时，效果又会如何呢？我把MvcPatch进行了一些修改，然后再使用UrlGenBenchmark进行了一番比较。 "
    },
    {
        "Title": "Attribute操作的性能优化方式",
        "Link": "/2009/11/attribute-performance-improvement.html",
        "BriefIntro": "Attribute是.NET平台上提供的一种元编程能力，可以通过标记的方式来修饰各种成员。无论是组件设计，语言之间互通，还是最普通的框架使用，现在已经都离不开Attribute了。迫于Attribute的功能的重要性（Kent Beck认为NUnit比早期JUnit设计的好，一个主要方面便是利用了Attribute），Java语言也在5.0版本中引入了与Attribute类似的Annotation概念。不过Attribute说到底也是一种反射操作，平时正常使用不会带来问题，但是密集的调用还是对性能有一定影响的。这次我们就来总结看看我们究竟可以如何回避Attribute操作的一些性能问题。 "
    },
    {
        "Title": "《链接、装载与库》里的一个错误：关于调用栈",
        "Link": "/2009/11/linker-loader-library-correction-about-call-stack.html",
        "BriefIntro": "周六老同学聚会，出门前随手从桌上抓起了《程序员的自我修养――链接、装载与库》在路上翻。自从武汉博文出版社的周筠老师送给我这本书后，我基本上还没怎么看过。对这本书第一感觉是“标题党”，主标题起大了，虽然经过解释之后并非无法理解，但还是不太喜欢。但书还是好书，已经看完大半，而且基本上会在近期找个方式推荐一把。不过现在我想细说的并不是推荐相关话题（如适合谁看，该怎么看，结合什么一起看等等），而是想指出书中还未被《勘误》收录的一个错误：P288讲调用栈时，文字描述和配图上的问题。 "
    },
    {
        "Title": "并发环境下的缓存容器性能优化（下）：性能测试",
        "Link": "/2009/11/concurrent-cache-performance-improvement-2-benchmark.html",
        "BriefIntro": "上一篇文章里，我谈到对于某些场景中的缓存容器，其写操作非常少，到了程序后期甚至为零，而对它的读操作却几乎是密集连续且无穷无尽的。对于这样的容器，如果使用ReaderWriterLockSlim去进行保护每个“读”操作，这开销是在有些多余。因此我提出了“不可变”的哈希表，目的是在保持读操作的时间复杂度为O(1)的情况下，尽可能避免多余的开销。现在我们便将它和其他几种时间进行一个性能的对比。 "
    },
    {
        "Title": "“表达式树”配合“泛型参数字典”定义通用操作",
        "Link": "/2009/11/general-add-operation.html",
        "BriefIntro": "上午有朋友提出了这么一个问题：如何定义一个通用的相加操作。其实这可以利用“泛型参数字典”和“表达式树”配合完成，也有着非常优秀的性能。于是，我们便可以定义一个比.NET框架自带的Enumerable.Sum强大许多的扩展方法了。 "
    },
    {
        "Title": "F#版本的CodeTimer（已支持CPU时钟周期统计）",
        "Link": "/2009/11/fsharp-codetimer.html",
        "BriefIntro": "CodeTimer很好用，自从在今年三月在.NET技术大会上看到Jeffrey Richter用类似的东西之后，我就自己写了一个。不过，当时是用C#写的，现在我需要在F#里做相同的事情就不那么方便了。当然，F#与.NET本是无缝集成，因此C#写的CodeTimer也应该可以被F#使用。不过，我平时在使用CodeTimer时并不是通过程序集引用，而是使用代码复制的方式，因此如果有个F#版本那么应该使用起来更加方便。 "
    },
    {
        "Title": "并发环境下的缓存容器性能优化（上）：不可变的哈希表",
        "Link": "/2009/11/concurrent-cache-performance-improvement-1-immutable-hash-table.html",
        "BriefIntro": "我们在项目中经常会遇到这样的场景：一些信息读取开销较大，但只需要生成一次便可反复使用，因此我们会将其永久地缓存起来。例如在ASP.NET MVC中，系统会根据Controller的名称来缓存对应的元数据。这些缓存容器都有一些共同的特点，便是存储的对象数量有限（少则几十，多不过数千），但都需要在并发环境下被大量地读取，因此必须是线程安全的。那么，我们该如何设计这样的容器呢？ "
    },
    {
        "Title": "缓存方式与对象创建的性能比较",
        "Link": "/2009/11/cache-and-object-creation-benchmark.html",
        "BriefIntro": "由于Lambda表达式构造URL的速度不佳，我最近对于性能上的细节问题进行了一些探索和尝试。对于很多问题，以前由于不会形成性能瓶颈，因此并没有进行太多关注。还有一些问题可以“推断”出大致的结论，也趁这个机会进行更详细的试验，希望可以得到更为确切的结论和理性的认识。这次我打算做的实验，是关于对象的缓存与创建的性能比较。在某些情况下，我们会将创建好的对象缓存起来，以便今后进行复用。但是不同的缓存方式会有不同的性能，因此……我们现在便来试试看。 "
    },
    {
        "Title": "一次失败的尝试（下）：无法使用泛型的Attribute",
        "Link": "/2009/11/cannot-use-generic-attribute.html",
        "BriefIntro": "原本打算两篇写在一起，但是我认为这两个话题本身并没有太大关联，因此分开，便于查询。其实在构建Attribute的时候，我们经常会从构造函数中传入一个Type类型，然后在Attribute中使用Activator.CreateInstance或其他的“反射”方法来构造对象。那么，我忽然想，为什么不能使用泛型的Attribute呢？有了泛型便可以利用静态检查，也可以获得其他有用的特性。只可惜，C#并不支持在Attribute中使用泛型……而且这点在C# 4中也基本不会有所改变了。 "
    },
    {
        "Title": "如何对一个博客系统进行CSS管理？",
        "Link": "/2009/11/style-management-for-blog-system.html",
        "BriefIntro": "忽然发现，我的博客皮肤又改变了，这次是About栏。我在我的博客版式上投入了很大的精力，动用了大量的JavaScript和自定义CSS，希望可以让浏览效果更加“和谐”。可是，博客园在样式管理上似乎经常会出现一些问题，时不时让一些基础的样式修改破坏了版式。为什么这样的事情总是一而再，再而三地发生呢？这无法不让我多想一些。似乎这次的问题是由两方面原因造成的：1) 博客园修改了过于宽泛的选择器 2) 皮肤的样式直接依赖了最基础的样式 "
    },
    {
        "Title": "一次失败的尝试（上）：原来GetCustomAttributes方法每次都返回新的实例",
        "Link": "/2009/11/getcustomattribute-always-returns-new-instances.html",
        "BriefIntro": "前一段时间我在比较各种URL生成方式性能的时候，其实已经为利用Lambda表达式的做法进行了优化。在优化之前，使用Lambda构建URL的性能比现在的结果还要慢上50%。性能低下的原因，在于每次都使用GetCustomAttributes来获取参数（或其他一些地方）标记的Custom Attribute。这里应该用到了反射，在这种密集调用情形中性能急转直下。 "
    },
    {
        "Title": "我在TechEd的演讲：Real World ASP.NET MVC",
        "Link": "/2009/11/dev343-teched-2009-real-world-aspnet-mvc.html",
        "BriefIntro": "上周的TechEd 2009比想象中忙，掺和了不少Session。不过一到晚上就开始胡吃海喝，总体来说过得还是挺不错的――只不过博客就落下了。嗯嗯，从现在开始继续。这个是我在这次TechEd上关于ASP.NET MVC的演讲以及演示代码下载，内容比较多，时间有些不够用。大家不妨看看，权当消遣。我去处理别的事情了……太多邮件没有回复，太多RSS没有看了。 "
    },
    {
        "Title": "为URL生成设计流畅接口（Fluent Interface）",
        "Link": "/2009/11/fluent-interface-for-url-generation.html",
        "BriefIntro": "昨天我比较了三种URL生成方式的性能，并对结果进行了分析。从结果中我们得知使用Lambda表达式生成URL的性能最差，而且差到了难以接受的地步。经过分析，我们发现其中光“构造表达式树”这个阶段就占了接近30%的开销。虽然表达式树的节点是有些多，但是.NET中创建对象其实非常快，我实在没想到它会占这么高的比例。因此，我们需要这种做法进行方向性的调整，减少对象创建的数目。 "
    },
    {
        "Title": "各种URL生成方式的性能对比（结论及分析）",
        "Link": "/2009/11/several-ways-of-generating-url-benchmark-result.html",
        "BriefIntro": "上次我们设计了一个实验，比较三种不同URL生成方式的性能。您运行了吗？如果运行的话，有没有对结果进行一些的分析呢？现在我们就来详细观察及分析这次试验的结果，并给出我的分析。如果您有一些其他的看法，也请进行一些补充。从结果上看，Lambda表达式生成URL的性能令人难以接受，经过分析之后更发现，这是一个硬伤，必须根本性，方向性地进行改变。您对此有什么看法呢？我们不妨一起讨论一下如何做到“既美观，又高效”。如果您有更理想的做法也请告诉我。 "
    },
    {
        "Title": "统计一个表达式树拥有的节点数量",
        "Link": "/2009/10/get-expression-tree-nodes-count.html",
        "BriefIntro": "如果要统计表达式树的节点数量，我们可以编写一个Expression Visitor来完成这个任务。值得注意的是，由于ExpressionVisitor只负责“遍历”，因此在进行“统计”、“收集信息”等任务的时候，都需要在子类内部保存临时信息。因此，许多ExpressionVisitor的实现其实都不是线程安全的。一般说来，由于自动生成闭包等机制，一个Lambda表达式实际构造出的节点总比我们“看出”的要多一些。 "
    },
    {
        "Title": "各种URL生成方式的性能对比",
        "Link": "/2009/10/several-ways-of-generating-url-benchmark.html",
        "BriefIntro": "在上一篇文章中我们列举了各种URL生成的方式，其中大致可以分为三类：1) 直接拼接字符串，2) 使用Route规则生成URL，3) 使用Lambda表达式生成URL。我们可以轻易得知，这3种作法可维护性依次增加，而性能依次减少。不过，我们还是有一个疑问，这个性能究竟相差多少？它是否的确真的可以被忽略？为此，我们还是来进行一次性能对比吧。您可以在这里下载文末的解决方案，亲自试验一下――不过在此之前，您不妨进行一个预测，猜猜看最后的结果究竟如何。 "
    },
    {
        "Title": "浅谈URL生成方式的演变",
        "Link": "/2009/10/several-ways-of-generating-url.html",
        "BriefIntro": "开发Web应用程序的时候，在页面上总会放置大量的链接，而链接的生成方式看似简单，也有许多不同的变化，且各有利弊。现在我们就来看看，在一个ASP.NET MVC应用程序的视图中如果要生成一个链接地址又有哪些做法，它们之间又是如何演变的。这个演变的过程，其实也是一步步发现缺点，再进行针对性改进的过程。我们虽然使用在ASP.NET MVC的视图作为演示载体，但是它的方式和思路并不仅限于此，它也可以用在ASP.NET MVC的其它方面（如在Controller中生成URL），或是其它模型（如WebForms），甚至与Web开发并无关联的应用程序开发上面。 "
    },
    {
        "Title": "您选择简单的组合，还是完整的集成？（补充）",
        "Link": "/2009/10/more-on-composition-or-integration.html",
        "BriefIntro": "昨晚就写到这里，刚看到有朋友提意见了，说我标题党，标题写着“文化”，里面变成PowerShell介绍了。其实如果我要介绍PowerShell就会更详细一些，而现在即使把所有的PowerShell脚本删了也还是有些内容的吧……不过现在还想多谈一些东西。例如，如果你要完成一件事情，那么会选择什么方式。我这里简单分为两种，一种是集成进常用的工具，如Visual Studio；另一种便是使用额外的工具――可以是Shell，也可以是别的。 "
    },
    {
        "Title": "您选择简单的组合，还是完整的集成？",
        "Link": "/2009/10/composition-or-integration.html",
        "BriefIntro": "其实这是两种文化，很多人说前者属于Unix文化，后者属于Windows文化。前者好比是一系列分散的小工具，它们互相配合完成任务，其典型代表是Unix Shell。而后者好比是一个完整的工具箱，包含了完成某件特定工作所需的几乎全部功能，其典型代表是我们再熟悉不过的Visual Studio。当然，既然是文化，就能够互相借鉴和采纳，因此我们在Unix环境中也可以使用如Eclipse和IntelliJ IDEA，而Windows环境中也有cygwin和Powershell。我今天写这个东西的原因是，我想要做的一件事情正好落入了这样的“俗套”，于是不仅“多想”了一些。这个事情便是所谓的“项目模板”。 "
    },
    {
        "Title": "二十行C#代码打造Ruby Markup Builder",
        "Link": "/2009/10/implement-ruby-markup-builder-in-20-lines-of-c-sharp-codes.html",
        "BriefIntro": "从.NET诞生之日起就有了XML类库，但是从使用上来说非常不方便，许多行代码只能构造一个简单的XML对象。这个情况在.NET 2.0中也没有得到改变，直到有一天，LINQ to XML随.NET 3.5横空出世，于是乎XML的生活一下子变得美好了很多。与DOM API相比，使用LINQ to XML，无论是XML的构造还是读取都容易了许多。不过俗话说得好：“不怕不识货，就怕货比货”，这样的API与Ruby Markup Builder相比还是有明显差距。但是我们这些可怜的C#程序员难道只有在一边眼馋的份吗？不见得。 "
    },
    {
        "Title": "书评：卓有成效的ThoughtWorks程序员的45个习惯",
        "Link": "/2009/10/book-review-practices-of-an-agile-developer-the-productive-programmer-the-thoughtworks-anthology.html",
        "BriefIntro": "这个书名看起来似乎有些莫名其妙，因为其实它包含了三本书：《高效程序员的45个习惯》、《卓有成效的程序员》和《软件开发沉思录：ThoughtWorks文集》。虽然最后一本书的中文标题里包含“沉思”字样，但总体来说其实这三本都是实践性的很强的书，基本上是会告诉你“怎么做”――当然同样也会告诉你为什么。基本上这三本小于等于200页的小册子陪伴了我半个多月来的上下班，上厕所已经睡觉前的时间，也带给了我不少体会和思考。 "
    },
    {
        "Title": "到底博客园首页的标准是什么？",
        "Link": "/2009/10/1589474.html",
        "BriefIntro": "博客园首页的标准是什么？它是有客观依据的，有案例可查的标准，还是仅仅是靠每个人心里自己的主观感觉来衡量的？现在的主要矛盾似乎就在于首页是个聚集区，大家靠自己的对自己文章的评价标准发上首页，用自己对别人文章的评价作为标准认为某某文章应该撤下首页，博客园管理团队也是使用自己的标准来操作――博客园团队也是人，我不知道有几个人，但肯定不会多，所以窃以为同样不能算是“集体智慧”。 "
    },
    {
        "Title": "对Action方法的参数进行双向转化",
        "Link": "/2009/10/bidirectional-conversion-for-action-parameter-with-route-binder.html",
        "BriefIntro": "昨天有朋友忽然告诉我，在G点中国上搜索URL Routing时，我的《请别埋没了URL Routing》一文排在首位。这不禁让我汗颜，这是因为从现在的角度看起来，这篇文章的内容虽不能算错，但的确也不算是一种非常合适的做法。那篇文章的目的是展示如何利用URL Routing的扩展能力，将URL和Route Values通过Formatter进行双向的转化。这样便可以在Action方法中使用复杂参数的同时，也可以使用复杂参数得到正确的URL。这个目标是好的，可惜当时的思路有些偏差。现在我总结出了更合适的做法，并已经在项目中大量使用，效果不错。 "
    },
    {
        "Title": "趣味编程：从字符串中提取信息（参考答案 - 下）",
        "Link": "/2009/10/code-for-fun-tokenizer-answer-2-fsharp.html",
        "BriefIntro": "昨天我们观察了如何使用基于状态机的顺序解析方式来提取字符串中的信息，不过由于winter-cn的做法和我原始的想法不谋而合，但实现的更为清晰，因此我在不献丑的同时，又设法使用另外一种方式来解决这个问题。后来又看到许多朋友给出了各种各样的做法，有普通拆分的方式，有利用正则表达式的做法。于是最后，我“不得不”使用一种特别的方式：F#来编写这么一段解析逻辑。从中我们也可以看到F#在做一些解析工作时的方便之处，在今后我还会谈一下它对我编写C#代码时的启发。 "
    },
    {
        "Title": "趣味编程：从字符串中提取信息（参考答案 - 上）",
        "Link": "/2009/10/code-for-fun-tokenizer-answer-1.html",
        "BriefIntro": "这次“趣味编程”的目的是解析字符串，从一个指定模式的字符串中提取信息。对于目前这个问题，解决方案有很多种，例如直接拆分，使用正则表达式，或是如现在本文这般按照顺序解析。总结果上来说，这些做法都是可取的，不过现在我打算举出的做法是我认为最为“典型”也最有“学习”和“展现”价值的解决方案：基于状态机的顺序字符解析。也欢迎您对此其他的做法进行深入分析。 "
    },
    {
        "Title": "浅谈线程池（下）：相关试验及注意事项",
        "Link": "/2009/10/thread-pool-3-lab.html",
        "BriefIntro": "三个月，整整三个月了，我忽然发现我还有三个月前的一个小系列的文章没有结束，我还欠一个试验！线程池是.NET中的重要组件，几乎所有的异步功能依赖于线程池。之前我们讨论了线程池的作用、独立线程池的存在意义，以及对CLR线程池和IO线程池进行了一定说明。不过这些说明可能有些“抽象”，于是我们还是要通过试验来“验证”这些说明。此外，我认为针对某个“猜想”来设计一些试验进行验证是非常重要的能力，如果您这方面的能力略有不足的话，还是尽量加以锻炼并提高吧。 "
    },
    {
        "Title": "我的TDD实践：可测试性驱动开发（下）",
        "Link": "/2009/10/testability-driven-development-2.html",
        "BriefIntro": "在上一篇文章里，我谈到自己在采用传统TDD方式进行开发时感到有些尴尬，最后不得不放弃这种先写测试再写代码最后重构的方式。不过我还是非常注重单元测试的实践，慢慢发现自己的做法开始转向另一种TDD方式，也就是“可测试性驱动开发”。简单的说，我现在采取的做法是，先开发，再测试，一旦发现产品代码不太容易测试，则将其重构为容易测试的代码。我发现，这种时刻注重可测试性的开发方式，其最终也能够得到质量较高的代码。上次谈的比较理论，而这次我便通过一个简单功能的开发过程，来表现我的思维方式及常用做法。 "
    },
    {
        "Title": "谈吉日嘎拉的《白话反射技术》及其他（吵架篇）",
        "Link": "/2009/10/jiri-reflection-argue-2-non-tech.html",
        "BriefIntro": "在技术社区还是以技术为先，在上一片文章里我谈了技术方面内容，那么这次就来谈谈非技术的。我反感这种社区氛围，火药味不是问题，但是谈技术不好好谈技术，总是扯上这人如何那人如何，我实在心烦的慌。您觉得吉日的文章误导初学者吗？写文章反驳吧！您觉得吉日的文章充满铜臭味吗？写文章反驳吧！我已经写了一篇文章，接下来就要靠大家了。挑出你最不满的吉日的文章，逐条反驳吧。 "
    },
    {
        "Title": "谈吉日嘎拉的《白话反射技术》及其他（技术篇）",
        "Link": "/2009/10/jiri-reflection-argue-1-tech.html",
        "BriefIntro": "社区又掀起了腥风血雨，这次又是吉日嘎拉这一博客园的众矢之的所引发的惨案。他的一篇《白话反射技术》发表之后，被包同学一篇文章狠狠地踩在脚底下，言辞之激烈令人罕见。从两片文章的内容与评论来看，大家的眼光似乎都没有集中在技术本身，而是针对个人在你来我往。有评论称这是“门派之争”，虽然看不出到底哪门哪派，但看上去也还真像那么一回事情。不过这真是技术社区该有的讨论氛围和方式？如果觉得吉日嘎拉在技术上有问题，难道不应该条条指出吗？既然没有人做这件事情，那么就还是我来吧，反正我写博客也成习惯了。 "
    },
    {
        "Title": "博客二三事",
        "Link": "/2009/10/talk-about-blogging.html",
        "BriefIntro": "其实我一直想写篇文章来谈谈博客这些方面的事情。我虽然在博客上投入了很多，它也是我工作和生活中非常重要的一部分，也自认为写的不少亦不差，但是一直缺少对这方面的总结，以及系统的思考。即便是看着一轮又一轮地“年度总结”过去，我也没有针对我的博客讨论过什么内容。之前也有过朋友问过我博客方面的事情，也有一些讨论引起我的思考，但都没有下决心写点文章。而这次就趁着一些冲动，细细谈一下博客方面的事情吧。 "
    },
    {
        "Title": "我的TDD实践：可测试性驱动开发（上）",
        "Link": "/2009/10/testability-driven-development-1.html",
        "BriefIntro": "TDD（测试驱动开发，Test Driven Development）是重要的敏捷实践之一，它的基本原理是用测试来带动开发，先写测试代码，再写开发代码，最后重构。许多TDD推广和实践者认为，这种方式易于带来高质量的代码。而如今，TDD也慢慢有了Test Driven Design，也就是测试驱动设计的意味。也就是说，它更像是一种设计方式了。这些理论我很愿意相信，也很支持，但是从实际角度来说，我还是较难接受正统的TDD行为。不过，我也在实际开发过程中总结出……怎么说呢，应该说是更适合我自己的实践方式，在此希望能和大家交流一下。 "
    },
    {
        "Title": "简化DomainRoute的配置",
        "Link": "/2009/10/simplify-domain-route-configuration.html",
        "BriefIntro": "昨天有朋友写邮件告诉我说，他正在项目中尝试着使用我提供的DomainRoute组件。我很高兴，这说明我的努力不是在自娱自乐，是对别人有实际帮助的，也有一些朋友会尝试着自行对项目进行扩展，而不总是靠微软提供的食物来过活。不过他说，他发现DomainRoute的配置非常繁琐，需要为每个Route使用WithDomain，提供了大量重复的信息。他说他也在构建了辅助API，不过似乎效果不够好，问我有没有更好的解决方法。其实是有的，因为我在使用DomainRoute的初期也遇到了这个问题，不过现在已经在MvcPatch中提供了个人认为比较令人满意解决方案。 "
    },
    {
        "Title": "关于排错：专注思考，细心观察，步步为营",
        "Link": "/2009/10/about-debugging.html",
        "BriefIntro": "时常有朋友发邮件给我，说遇到了一个什么什么奇怪的问题，不知道是怎么回事，希望我帮忙看看。我基本上每天都会抽出或长或短的时间来回复这些邮件，不过也经常发现，其实许许多多的问题都完全是有能力自行解决的。在很多时候，我发现许多朋友还缺乏最基本的解决问题，分析问题的方式。其实我在平时工作中也会遇到各种各样的问题，有时候甚至异常古怪，但是在仔细分析之下，往往都能解决。于是我现在打算谈点解决问题的基本方式，希望可以帮到一些朋友。 "
    },
    {
        "Title": "浅谈Route组件的设计思考与模式",
        "Link": "/2009/10/aspnet-routing-design-ideas-and-patterns.html",
        "BriefIntro": "Route组件虽然可以说是ASP.NET的“门户”，不过至今为止似乎都被微软当作是二等公民。可能是由于自带的Route类功能已经太强，微软官方或社区内都不太关注RouteBase的扩展。不过有一点是正确的，那就是在大部分情况下的确没有必要去扩展RouteBase。事实上，我构建过不少RouteBase类，不过除了DomainRoute之外，其余的都被我放弃了，例如在大半年前写的《请别埋没了URL Routing》中所提供的FormatRoute，在MvcPatch中也已经有了更好的替代品（过几天便会谈到这一点）。 "
    },
    {
        "Title": "我对NHibernate的感受（4）：令人欣喜的Interceptor机制",
        "Link": "/2009/10/my-view-of-nhibernate-4-interceptor.html",
        "BriefIntro": "之前谈了NHibernate的几个方面，似乎抱怨的居多，不过这次我想谈一下我对Interceptor的感受，则基本上都是好话了。这并不一定是说Interceptor设计的又多么好（事实上它使用起来还是挺麻烦的），但是这的确也是我认为NHibernate超越LINQ to SQL，尤其是Entity Framework的又一个重要方面――因为Entity Framework本身也已经不差了。更重要的是，Interceptor机制让我得以实现我“理想中的”数据访问功能。当然现在只是浅尝辄止一番，我打算以后再慢慢地，详细地谈谈我所满意的“数据访问层”设计。 "
    },
    {
        "Title": "浅谈Route规则名称的作用，及MvcPatch的处理方式",
        "Link": "/2009/10/name-of-route-with-mvcpatch.html",
        "BriefIntro": "国庆前的最后一天，我写了《关于ASP.NET Routing的几点内容》，其中谈论了ASP.NET Routing作用，设计目的，工作流程等等。不过我还有一个比较重要的东西一笔带过了，不知道您注意到了没有，在向ASP.NET Routing的RouteTable.Routes属性（一个RouteCollection对象）中添加Route规则的时候，我们会同时指定一个“名称”。在微软给出的官方“广告”中，似乎看不出这个名称有什么用。但事实上，它的功能非常关键。 "
    },
    {
        "Title": "趣味编程：从字符串中提取信息",
        "Link": "/2009/10/code-for-fun-tokenizer.html",
        "BriefIntro": "字符串解析是程序员工作中非常重要的一部分，也是非常考验编程能力的工作。基本上我在面试程序员的时候，一定会出一道编程题目作为考察的一方面，而这道题目有很大的可能性是做字符串的解析。例如，给出一个模式规则，要求写程序判断某个字符串是否符合特定格式。例如，要求将BB Code转化为HTML。而现在这个趣味编程题，来自于我目前正在进行的项目。因此从实用角度来说，也有一定现实意义。 "
    },
    {
        "Title": "NHibernate自定义集合类型（下）：自动维护双向关系",
        "Link": "/2009/10/nhibernate-custom-collection-3-bidirectional-relation.html",
        "BriefIntro": "如果使用NHibernate自带的集合类型，其中一个问题就在于需要在代码中手动维护双向关系，迫使开发人员编写额外的代码。其实这就是集合自定义逻辑的一个应用方面。现在，既然我们已经得到了一个方便的自定义集合的解决方案，那么现在便把“自动维护双向关系”作为目标来实现一番，也算是一个非常典型的示例了。 "
    },
    {
        "Title": "NHibernate自定义集合类型（中）：通用实现方式",
        "Link": "/2009/10/nhibernate-custom-collection-2-general-implementations.html",
        "BriefIntro": "上一片文章中我们观察了在代码中自定义一个基于Set的集合类型该怎么做，以及简单了解了一下NHibernate的这些自定义支持大致是如何工作的。不过文章最后还是留了两个问题，一是认为这种扩展方式不够通用，二是其中会出现的“重复”或是“反向依赖”。现在我们就需要在上文的基础上进行总结，提出一个通用的实现，可以方便我们构建自定义的集合类型。 "
    },
    {
        "Title": "NHibernate自定义集合类型（上）：基本实现方式",
        "Link": "/2009/10/nhibernate-custom-collection-1-basics.html",
        "BriefIntro": "前天一篇文章中我说NHibernate的集合类型实现有些“尴尬”，它无法使用自定义集合类型，设计也有些古怪――不过在许多朋友的指点下，我意识到NHibernate是可以使用自定义集合类型的。至于它的设计是否合理（或者说是用是否方便？）……这就是这几篇文章中想要探讨的内容了。不少朋友给出了一些自定义集合类型的示例链接，我参考之余也自己找了一些资料，慢慢尝试，也终于有了一些体会。 "
    },
    {
        "Title": "最受欢迎中国技术博客评选（PB50）结果公布",
        "Link": "/2009/10/popblogger50.html",
        "BriefIntro": "国外有博客评选榜单，记得之前也有人提议国内也做一下类似的评选。这不，ZDNET搞了一个。现在结果终于揭晓了，看看有几位是您已经知道并订阅了呢？不过，我还是感觉大部分的博客更新的实在不够频繁，这和人家世界级的榜单差太远了啊，兄弟们还得努力才是。 "
    },
    {
        "Title": "尝试使用IKVM运行Lucene 2.9.0版",
        "Link": "/2009/10/ikvm-simple-lucene-benchmark.html",
        "BriefIntro": "上月末Lucene发布了2.9.0版，这个版本的改进比较明显，主要是各方面性能的增强，以及对数字字段范围查询的直接支持。这个版本还有个重要的意义，就是它标记了Lucene 3在API上的改变，及早跟进的话对Lucene 3的未来接受程度会比较好。Lucene的更新很慢，而移植到.NET平台上的Lucene.NET的二进制发布则更是一直停留在07年三月的2.0版本。虽然我们可以通过svn获取到Lucene.Net 2.3.2的源代码自行编译，但这次我还是想直接使用最新的2.9.0版本。最终我决定趁这个机会尝试一下IKVM.NET。 "
    },
    {
        "Title": "我对NHibernate的感受（3）：有些尴尬的集合支持",
        "Link": "/2009/10/my-view-of-nhibernate-3-collection-support.html",
        "BriefIntro": "既然是一个ORM框架，那么自然是将O这一端映射R上。至于集合，是O这方面最常见，也是R这一边非常容易表示的关系。例如，一个问题（Question）可以包含多个回答（Answer）。不过，NHibernate需要“一锅端”地设置集合属性，它没有保留自定义集合的逻辑。此外，在更新集合数据的时候，它也会出现多余的数据加载。 "
    },
    {
        "Title": "关于ASP.NET Routing的几点内容",
        "Link": "/2009/09/things-about-aspnet-routing.html",
        "BriefIntro": "在之前的文章中，有一些朋友会问我一些关于ASP.NET Routing的内容。这个组件的重要性越来越大，ASP.NET MVC，ASP.NET Dynamic Data都用到了ASP.NET Routing。事实上，在ASP.NET 4.0中还会出现对ASP.NET WebForms的支持。可惜的是，目前对于ASP.NET Routing的文档和描述内容都很少。因此，有的时候一些朋友可能无法理解我一些扩展的设计思路。现在我打算详细解释一下有关ASP.NET Routing中最常见的几个问题。 "
    },
    {
        "Title": "ASP.NET Routing对请求的处理方式",
        "Link": "/2009/09/aspnet-routing-request-processing.html",
        "BriefIntro": "原本这是《关于ASP.NET Routing的几点内容》一文中的一节，不过等写完这节之后发现这块内容已经比较完整了，而且它本身也是独立和最为常见的部分，因此我把它提取出来单独成文。至于那片文章的其他部分我会再修改一下，明天发布。希望这些内容会对您理解ASP.NET Routing工作方式，以及阅读ASP.NET Routing的代码有所帮助。 "
    },
    {
        "Title": "趣味编程：C#中Specification模式的实现（参考答案 - 下）",
        "Link": "/2009/09/specification-pattern-in-csharp-practice-answer-2.html",
        "BriefIntro": "上一篇文章中我们利用C#语言的特性实现了一种轻量级的Specification模式，它的关键在于抛弃了具体的Specification类型，而是使用一个委托对象代替唯一关键的IsSatisfiedBy方法逻辑。据我们分析，其优势之一在于使用简单，其劣势之一在于无法静态表示。但是它们还都是在处理“业务逻辑”，如果涉及到一个用于LINQ查询或其他地方的表达式树，则问题就不那么简单了――但也没有我们想象的那么复杂。 "
    },
    {
        "Title": "使用Model Binder绑定Action参数字段时的取舍问题",
        "Link": "/2009/09/exclude-field-when-bind-action-parameters.html",
        "BriefIntro": "刚才在看代码的时候忽然发现了一件可能会成为问题的情况，而这个情况还挺隐蔽的。因此，我原本写到一半的东西就暂时停下，顺延至明天，而现在先来谈谈这个问题。这个问题就是在使用DefaultModelBinder在绑定字段时的取舍问题。而您在使用ASP.NET MVC的时候不妨也检查一下，看看有没有这方面的情况。 "
    },
    {
        "Title": "趣味编程：C#中Specification模式的实现（参考答案 - 上）",
        "Link": "/2009/09/specification-pattern-in-csharp-practice-answer-1.html",
        "BriefIntro": "Specification模式的作用是构建可以自由组装的业务逻辑元素。不过就上篇文章的示例来看，“标准”的Specification模式的实现还是比较麻烦的，简单的功能也需要较复杂的代码。不过，既然说是“标准”的方式，自然就是指可以在任意面向对象语言中使用的实现方式，不过我们使用的是C#，在实际开发过程中，我们可以利用C#如今的强大特性来实现出更容易使用，更轻量级的Specification模式。 "
    },
    {
        "Title": "在视图中使用递归生成树状结构",
        "Link": "/2009/09/rendering-tree-like-structure-recursively.html",
        "BriefIntro": "在开发过程中往往会有一个需求，就是将一个树状的数据结构在视图中表示出来。例如最传统的多级分类，系统中有一系列根分类，每个分类中又带有一些子分类，而我们的目标便是在页面上生成一个由ul和li嵌套组成的HTML结构。这个问题看似简单，但是如何让实现变的轻松、易于使用也是一个值得讨论的问题。这次就来谈谈这部分的情况。 "
    },
    {
        "Title": "使用Lambda表达式编写递归函数（性能测试）",
        "Link": "/2009/09/recursive-lambda-expressions-benchmark.html",
        "BriefIntro": "为了补充引用资料，现在对之前Lambda表达式编写递归函数进行一番性能测试。测试的对象为辗转相除法求最大公约数，使用以下三种方式计算：普通递归，使用SelfApplicable及Fix进行计算。从执行时间上看，直接递归的性能最好，Self次之，但相差不大，但Fix方式消耗的时间就为前两者的7倍左右了。从GC压力上看，直接递归与Sel对GC都没有丝毫压力，但Fib由于构建了额外的委托对象，其压力也相对较大。 "
    },
    {
        "Title": "谈谈我对《ThoughtWorks文集》中多语言开发部分的看法",
        "Link": "/2009/09/talk-about-muti-language-programming-in-thoughtworks-anthology.html",
        "BriefIntro": "一早看怪怪同学评论《ThoughtWorks文集》公开的样章，一谈多语言开发（第5章），二谈测试（第13章）。怪怪同学的看法是贬前者而捧后者，并提出“同样一个包装下、同一个公司不同的作者，差异如此之大，那么在我们的学习过程中，就要注意去芜存菁了”。说实话，我没有理解他对第5章的评价，如在“抽象方式”方面的说法我没有太深的理解。不过现在我也谈谈我对书中所写多语言开发的看法。用一句话概括的话就是：赞同结论，不赞同论据。的确如怪怪同学所言，即使是有“大师”称号的作者，其内容也该去芜存菁。 "
    },
    {
        "Title": "幻灯片：LINQ Inside, Part 1",
        "Link": "/2009/09/slides-linq-inside-part-1.html",
        "BriefIntro": "整理电脑时整理发现一个幻灯片，修改日期是去年年底，当时不知道为了什么，对方是谁讲一次LINQ。这次讲座是入门型的，主要讲了讲什么是LINQ，什么是表达式，表达式树等等。不过这第一部分似乎……还没有提到LINQ，更那个什么的是，我已经找不到第二部分了……因此，大家可以随意看看。目前脑袋写了几篇相当不错的，可作为入门的LINQ相关文章。以后我再提到这部分内容时终于也有东西可以引用了…… "
    },
    {
        "Title": "语言特性与API设计",
        "Link": "/2009/09/language-and-better-interface-for-decorator.html",
        "BriefIntro": "我平时的主要工作之一，便是编写一些基础及通用的类库，能够在项目中大量复用。换句话说，我的工作目的，是让其他开发人员可以更好地完成工作。因此，如何设计更容易使用的API是我经常要考虑的东西，偶尔也会有一些体会。而现在这些内容，是我在为Functional Reactive Programing写“参考答案”的时候忽然“总结”出来的想法。可能比较简单，但我想也是设计API是需要考虑的一些内容。 "
    },
    {
        "Title": "我对NHibernate的感受（2）：何必到处都virtual",
        "Link": "/2009/09/my-view-of-nhibernate-2-virtually-everything.html",
        "BriefIntro": "上一篇文章主要是在夸NHibernate实现的好，而这篇就完全是来抱怨的了。NHiberante有个毛病，就是如果是和数据库产生映射的类，就要求所有的public成员和protected成员必须是virtual的。这就让我觉得无厘头了，为什么没有任何关系的东西也要受到限制？我知道NHiberante要求将属性标记为virtual是为了延迟加载，但这又关没有映射的属性，甚至方法什么事情呢？虽然我现在明白了原因，但还是不能接受――因为我们在承受Java语言所带来的痛苦。 "
    },
    {
        "Title": "我对NHibernate的感受（1）：对延迟加载方式的误解",
        "Link": "/2009/09/my-view-of-nhibernate-1-lazy-loading.html",
        "BriefIntro": "我用NHibernate时间不长，而NHibernate的复杂程度也决定了我无法像了解LINQ to SQL那样容易。不过在使用了一段时间过后，还是对它有一定体会。有欣喜，有误解，也有抱怨。总体来说，目前NHibernate是我最满意的ORM框架。之前我一直认为NHibernate使用了一种简单的延迟加载方式。但事实上，它使用了一种维持原有业务逻辑的延迟代理写法。如果您关注我的文章，会发现这就是我之前提出的最为理想的延迟代理实现方式，也是我在Eazy类库中使用的做法。惭愧啊。 "
    },
    {
        "Title": "一些技术图书编写、推荐、出版人员需要自重",
        "Link": "/2009/09/1572868.html",
        "BriefIntro": "国内图书市场已经很不健康了，虽然现在许多出版社、编辑和作者的努力都看得到，但是总有更多的书冒出来拖他们的后腿。对于普通人来说，有多少人会区分出版社，区分作者呢？因此，我真希望技术图书的编写、推荐和出版人员还是要自重，写不好书就不要写，出不了好书就不要吹，没看过书就不要推。图书产业虽然也早已商业化，但是这毕竟还代表了知识，有其特殊性，经济利益不该是你们唯一考量的东西。 "
    },
    {
        "Title": "在ASP.NET MVC中使用IIS级别的URL Rewrite",
        "Link": "/2009/09/aspnet-mvc-iis-level-url-rewrite.html",
        "BriefIntro": "大约一年半前，我在博客上写过一系列关于URL Rewrite的文章，把ASP.NET平台上进行URL Rewrit的方式和各自地特点进行了较为详细的描述。应该来说，已经讲的非常具体，可以应对90%的情况。其实IIS Rewrite的原理非常容易理解，进行一些简单的变化和推断之后，便可以得出一些问题的原因和解决方案。现在我们就来看一个真实案例：在ASP.NET MVC中使用IIS级别的URL Rewrite。 "
    },
    {
        "Title": "趣味编程：Functional Reactive Programming（参考答案）",
        "Link": "/2009/09/functional-reactive-programming-for-csharp-answer.html",
        "BriefIntro": "初见Functinal Reactive Programming时，它的编程方式让我大开了眼界，居然可以用这种方式来操作和控制事件。虽然从技术角度来说，要实现这种方式并不是非常困难，甚至颇为有趣。因此我把它当作一次“趣味编程”。不过，这次的结果似乎让我对API设计有了一些新的体会，我打算明天再来总结一下。今天，我们先关注原题的解决方式。 "
    },
    {
        "Title": "片段缓存的实际应用、延迟加载及Eazy类库",
        "Link": "/2009/09/how-to-use-fragment-cache-lazy-load-and-library-eazy.html",
        "BriefIntro": "片段缓存已经实现完整了，但好像还没有提到如何在项目中进行实际应用，那么现在就来谈一谈这方面。之前也有朋友提出，这个片段缓存难道节省的只是拼接HTML字符串的时间吗？这其实就涉及到片段缓存在实际项目中该如何使用的问题了。我们通过延迟加载来省下数据加载的开支，而且有了Eazy类库之后，定义延迟加载是件非常容易的事情。 "
    },
    {
        "Title": "适合ASP.NET MVC的视图片断缓存方式（下）：页面输出原则",
        "Link": "/2009/09/aspnet-mvc-fragment-cache-3-rendering-principle.html",
        "BriefIntro": "上一篇文章里已经把Html.Cache打造成了非常具有可用性的API，需要缓存时我们只需在页面上做一个标记即可。标记内部的写法和普通视图的写法相同，RenderPartial等辅助方法输出内容也会被一并缓存下来。只可惜，上次文章末尾我提到有些效果是有前提的。这个前提就是必须修改RenderPartial的实现，让它遵守一个原则：如果您是在向页面输出内容，请务必将所有内容通过页面的Writer输出。 "
    },
    {
        "Title": "适合ASP.NET MVC的视图片断缓存方式（中）：更实用的API",
        "Link": "/2009/09/aspnet-mvc-fragment-cache-2-more-friendly-api.html",
        "BriefIntro": "上一篇文章中我们提出了了片断缓存的基本方式，也就是构建HtmlHelper的扩展方法Cache，接受一个用于生成字符串的委托对象。但是在实际开发过程中，我们最乐于看到的使用方法，应该只是使用某个标记来“围绕”一段现有的代码。不过这个方法并不实用，如果您要缓存大片的HTML，还需要准备一个Partial View，再用它来生成网页片段。这次我们会构建一个更为良好的API。 "
    },
    {
        "Title": "幻灯片：Web开发中的缓存",
        "Link": "/2009/09/slides-web-cache.html",
        "BriefIntro": "这是我昨天在博文视点Open Party上海站上关于Web开发中缓存的简单讲座。原本博文视点的朋友们希望我讲一下ASP.NET MVC方面的话题（估计看我最近一直在搞这个），但是我觉得其他平台一直用的是MVC框架，而ASP.NET MVC作为“后来者”也没有什么出彩的地方，所以最终选择这个稍微“通用”些的话题。 "
    },
    {
        "Title": "从ASP.NET的PHP执行速度比较谈起",
        "Link": "/2009/09/aspnet-php-benchmark-and-more.html",
        "BriefIntro": "上星期我在InfoQ发表了一篇新闻，对Joe Stagner在博客上发表的三篇关于ASP.NET与PHP性能对比的文章进行了总结。写新闻其实挺不爽的，因为不能夹杂个人的看法，只能平铺直叙陈述事实。当然，如果像某些新闻那样“换一种说法”是可以骗过一些“不明真相的群众”，但是这就有违道德了。因此，在客观陈述完新闻内容之后，我只能选择把自己的感想、评论等内容放在自己的博客上。 "
    },
    {
        "Title": "适合ASP.NET MVC的视图片断缓存方式（上）：起步",
        "Link": "/2009/09/aspnet-mvc-fragment-cache-1.html",
        "BriefIntro": "说到网站性能优化，没有什么比“缓存”更重要了。即便是某些朋友口中念念不忘的“静态页”，说到底也只是缓存了整张页面内容而已。但是，显然这样大粒度的缓存策略，在如今“牵一发而动全身”的Web 2.0站点中几乎是无法使用的。视图片断缓存，缓存的也是页面内容，它比更低级别的缓存更有效率，也比静态页等整页内容缓存的适用面要大得多。在Rails或Django中都有类似的功能，但ASP.NET MVC甚至在2.0的Road Map中还没有包含这一功能，我们只能自己动手丰衣足食了。不过有了ASP.NET WebForm作为强大的视图引擎，加这样的功能简直是举手之劳。 "
    },
    {
        "Title": "趣味编程：将事件视为对象（参考答案）",
        "Link": "/2009/09/on-event-as-object-practice-answer.html",
        "BriefIntro": "这次我们是要编写一个DelegateEvent对象，提供它AddHandler和RemoveHandler的实现。事实上，在之前还有一篇文章中，我们搞了一个人模狗样的构造方式，但是它往往不适合用于实际使用过程中。因此，其实DelegateEvent最关键的地方还是各种不同的“构造方式”，使它可以用于各种情况。 "
    },
    {
        "Title": "ASP.NET WebForm页面内容输出方式",
        "Link": "/2009/09/where-does-aspnet-page-render-to.html",
        "BriefIntro": "这次我们谈的话题是“Web Form页面上输出内容的方式”。这其实是一个非常旧的话题了，因为本文的内容甚至可以运用于ASP.NET 1.1之上。不过这个话题的适用范围很广，因为即使是目前最新的ASP.NET MVC框架，它的默认视图引擎依旧是基于ASP.NET WebForm的（如Page，Control，MasterPage）。甚至说，由于ASP.NET MVC框架的特性，我们会遇到更多在页面上“直接输出”内容的情况。因此，这个话题在ASP.NET MVC应用中可能由为重要。 "
    },
    {
        "Title": "Get Ready for Real World ASP.NET MVC",
        "Link": "/2009/09/get-ready-for-real-world-aspnet-mvc-at-teched-2009.html",
        "BriefIntro": "2009年的TechED大会即将在北京举行（11/5 - 11/7），其中有我的一个Session。我将其命名为“Real World ASP.NET MVC”，希望可以分享一下自己在ASP.NET MVC方面的使用体会。现在，希望大家可以给我一点帮助。例如，您在使用ASP.NET MVC开发Web应用程序时有没有遇到什么困难？您认为ASP.NET MVC哪方面还无法让人满意？各个方面都可以。 "
    },
    {
        "Title": "趣味编程：C#中Specification模式的实现",
        "Link": "/2009/09/specification-pattern-in-csharp-practice.html",
        "BriefIntro": "Specification模式的作用是构建可以自由组装的业务逻辑元素。多个Specification对象可以组装起来，并生成新Specification对象，这便可以形成高度可定制的业务逻辑。例如，我们可以使用依赖注入（控制反转）的方式来配置这个业务逻辑，以此保证系统的灵活性。但是Wikipedia上提供了非常旧的内容，很可能是在C#只是1.0版本的时候编写的代码（或者说它为了“兼容”Java那种语言的实现方式）。那么在实际开发过程中，我们又该如何利用C#如今的强大特性来实现出更容易使用，甚至是更为“轻量级”的Specification模式呢？ "
    },
    {
        "Title": "WebFormView的标准修改办法及MvcPatch项目",
        "Link": "/2009/09/standard-webformview-patch-and-mvcpatch-project.html",
        "BriefIntro": "上一篇文章中我提到WebFormView的实现破坏了IView对象设计思路，它会把视图内容直接生成至HttpContext.Current而不是Render方法指定的TextWriter中。之前我提出了一种非常临时，非常山寨，非常简陋，绕弯，但是可行，或者说是可以“表现出解决问题的方法”的代码，而这次我们来做一次“标准”的修改。此外，我还创建了一个MvcPatch项目来保存这些内容。 "
    },
    {
        "Title": "应该算是WebFormView的一个Bug",
        "Link": "/2009/09/webviewengine-bug-always-render-to-current-context.html",
        "BriefIntro": "最近需要搞一些重要的功能，结果又遇到了意料外的障碍。于是又仔细地看了看ASP.NET和ASP.NET MVC的源代码，又发现了以前不曾知道的一些细节。其实ASP.NET为我们留下了不少切入点，但几乎没什么书会提到这些切入点，我们只能从微软自己的框架中一探究竟。不过这次我想谈的是ASP.NET MVC框架中的一个Bug，这个Bug在一般情况下不会出现问题，但是这的确违反了ASP.NET MVC自身的设计。这个问题就出在WebFormView对象的实现上。 "
    },
    {
        "Title": "MIT 6.00 Introduction to Computer Science and Programming, Fall 2008",
        "Link": "/2009/09/mit-open-course-sicp-replacement.html",
        "BriefIntro": "SICP的替代品，终于有了进一步完整的消息。看着教授用苹果在明亮的教室里讲课的感觉，的确比看之前的视频要舒畅很多。很憧憬MIT的这类顶级学府的学术氛围，虽然这个梦想似乎越来越遥远了。 "
    },
    {
        "Title": "检查几个程序集中的internal成员",
        "Link": "/2009/09/detect-internal-members-in-libraries.html",
        "BriefIntro": "两个星期前我写了一篇文章谈到一个现象（或是感觉）：我发现“类中的internal成员可能是一种坏味道”，原因在于违反了“单一职责”原则。然后谈了一般情况下遇到这种情况时一种可用的重构方式之一。结果自然是有人同意有人反对。不过刚才我忽然想到，不如检查一下微软的框架中internal成员的情况吧。微软最近几个框架都公开的源代码，社区反响不错，应该较为值得参考。 "
    },
    {
        "Title": "基于DelegateEvent创建第一个IEvent对象",
        "Link": "/2009/09/build-the-first-ievent-by-delegateevent.html",
        "BriefIntro": "继续和“事件即对象”打交道。我们之前提到过两个“趣味编程”：DelegateEvent与Functional Reactive Programming，现在我们在它们两者之间架起一座桥梁。也就是说，我们要从一个DelegateEvent对象创建一个IEvent对象出来。这样，您就可以把它作为第一个IEvent对象，继续尝试Functional Reactive Programming了。 "
    },
    {
        "Title": "如何创建TextWriter的子类",
        "Link": "/2009/09/how-to-create-your-own-text-writer.html",
        "BriefIntro": "如果您需要继承TextWriter实现自己的类型，您会怎么做？继承TextWriter不难，不过接下来，您打算覆盖（override）掉哪些方法？从Reflector的观察结果发现，其中所有的方法最终都会委托给Write(char)方法。但是只覆盖Write(char)方法只能保证最终成果“可以运行”，却无法保证是最优秀的结果。但是又有谁可以告诉我，究竟该怎么做呢？ "
    },
    {
        "Title": "趣味编程：Functional Reactive Programming",
        "Link": "/2009/09/functional-reactive-programming-for-csharp.html",
        "BriefIntro": "基于事件的编程再常见不过了，尤其是在和UI相关的WinForm，WPF，Silverlight开发方面。把事件作为一等公民看待之后，我们可以实现一些较为“特别”的编程模型，例如Functional Reactive Programming。这是一种较为优雅的基于事件的处理方式，适合一些如交互式动画，自动控制方面的工作。即使平时不太常见，我想作为一个“尝试”或“练习”也是非常合适的。那么我们就学习F#的类库，为C#也设计一套这样的功能吧。 "
    },
    {
        "Title": "监视程序中的死锁及其他",
        "Link": "/2009/09/dotnet-deadlock-detect.html",
        "BriefIntro": "每天回家路上总有一段比较长的路一片漆黑无法看书。这种时候，如果我有兴致则会用手机上上网，但是大部分情况下还是用来想问题的。今天我回忆起今天园子首页的一篇文章谈到死锁，想到了一种可行的解决方案，只可惜到家一搜索……别人已经实现过了。于是，又没我什么事情了…… "
    },
    {
        "Title": "趣味编程：将事件视为对象",
        "Link": "/2009/09/more-on-event-as-object.html",
        "BriefIntro": "如果一个语言（平台）把事件视为对象，则表明它把“事件”作为了语言的一等公民来对待。这可以有效地提高语言的抽象能力，由于.NET本身无法将事件作为单个对象处理，因此在某些时候就会束手束脚，也难以引入一些特别的编程模型。前一篇文章中我们提出了一个糊弄人的解决方案。而这次，不妨由您来试试看如何给出一个更好的实现。 "
    },
    {
        "Title": "我犯了一个错误，您能指出吗？（结论）",
        "Link": "/2009/09/i-made-a-mistake-can-you-figure-it-out-answer.html",
        "BriefIntro": "其实许多朋友已经在回复中发现问题所在了。泛型类中的静态变量会因为T的不同而产生不同的值，也就是说每个T所访问的静态变量都是独立的。因此，看似共享的静态ConnectionKey实际上是两个不同的Guid。 "
    },
    {
        "Title": "我犯了一个错误，您能指出吗？",
        "Link": "/2009/09/i-made-a-mistake-can-you-figure-it-out.html",
        "BriefIntro": "这是我最近在项目中犯的一个错误，您能指出吗？ "
    },
    {
        "Title": "把事件当作对象进行传递",
        "Link": "/2009/09/treat-event-as-an-object.html",
        "BriefIntro": "最近在琢磨一些事情，和API设计有关。API设计在很多时候是和语言特性有关的，因此如Java这样的语言，在API设计时会处处受到压抑。而C#就能够出现如Moq或Fluent NHIbernate这样的项目。同样，F#能够开发出FsTest，Scala号称Scalable Language，都是依靠着丰富的语言特性。不过，最近在使用C#的时候鼻子上也碰了一点灰，这是因为我发现“事件”这个东西没法作为对象进行传递。 "
    },
    {
        "Title": "较为理想的延迟代理的编写方式",
        "Link": "/2009/09/standard-lazy-proxy.html",
        "BriefIntro": "之前我谈到，在普通情况下我们可以很轻松地写出过一个代理类，用来处理延迟加载的情况。当时给出了一个很简单的做法，也就是指创建基类，覆盖它的一些属性实现。不过我当时也提到，这么做可能够用，但是也有一些缺点。例如，它破坏了SomeID属性中包含的业务逻辑。这也是我认为NHibernate的延迟加载方法欠妥的原因。因此我又想了想，理想中的延迟加载方式应该是什么样的呢？ "
    },
    {
        "Title": "如果是能简单解决的问题，就不用想得太复杂了",
        "Link": "/2009/09/simple-over-complex.html",
        "BriefIntro": "有个朋友在MSN问我说，有没有关于Emit的资料，它想生成一个类的动态代理。他抱怨Emit还是很麻烦，不过交谈过后知道他是想要做什么。他希望为一个对象的某个属性作延迟加载，这样可以避免一些无谓的消耗。不过我提出，这个方法是不是太重了，因为动态代理不是那么孤立存在的，它往往需要考虑很多其他东西。有时候我们可以使用最简单的代码，在一定程度上也可以达到目的。 "
    },
    {
        "Title": "一份值得阅读的幻灯片：微软对PHP支持的改进，及其它一些胡言乱语",
        "Link": "/2009/09/php-on-windows-and-more.html",
        "BriefIntro": "这里有一份我觉得值得推荐给大家的幻灯片。这个幻灯片是不久前举办的WordCamp China 2009上微软王超群的演讲，演讲主题是《熟悉的陌生人：微软对PHP的新支持使WordPress在IIS7上雄起》。WordCamp是业界著名的PHP大会，不过我这里推荐这个幻灯片不是为了为了推广PHP，而是为了说明一些其他问题――当然也有关于技术的有价值的内容，这些您看了幻灯片和我的文章之后就会明白了。 "
    },
    {
        "Title": "通过表达式树构造URL时忽略部分参数",
        "Link": "/2009/09/ignore-some-arguments-when-constructing-url-via-expression-tree.html",
        "BriefIntro": "您的使用ASP.NET MVC的时候，一定遇到过使用Post接受数据的Action方法。为了实现这个功能，我们必须在客户端准备一个form，并填写它的Action――也就是Post的目标URL。按照传统的做法，我们会使用表达式树来构造这个URL，但因为ASP.NET Routing在处理配置规则中没有标明的Route Values时，会将它们作为Query String拼接在URL后面。因此，我们需要得到一种“忽略”某个参数的方式。 "
    },
    {
        "Title": "您能看出这个Double Check里的问题吗？（解答）",
        "Link": "/2009/09/double-check-failure-answer.html",
        "BriefIntro": "已经很有很多朋友得到了结果，是由于m_categories过早初始化，而导致double check的验证条件被破坏（或者说，满足）。不过，这里我们可以再谈一些更深入地内容，例如Memory Consistency Model。 "
    },
    {
        "Title": "您能看出这个Double Check里的问题吗？",
        "Link": "/2009/09/double-check-failure.html",
        "BriefIntro": "昨天在做code review时看到一位同事写了这样的代码。这段代码的目的使用Double Check的做法来保证线程安全的延迟加载。但是我看到这代码之后发现了一个问题，这个问题不是第一次出现。因此，我打算在博客上记录一笔，希望可以给更多人提个醒吧。 "
    },
    {
        "Title": "趣味编程：函数式链表的快速排序（参考答案）",
        "Link": "/2009/09/functinal-list-quick-sort-answer.html",
        "BriefIntro": "之前我提出了一个“趣味编程”，模仿Haskell的方式对一个链表进行快速排序。在那篇文章中我解释了Haskell列表的结构，并给出了ImmutableList的基础实现。快速排序的例子很多，多做也没有意思。这题虽然打着“快速排序”的旗帜，但事实上这里的关键在于实现ImmutableList数据结构的相关操作――否则为什么叫“函数式链表”的快速排序呢？。 "
    },
    {
        "Title": "优化通过表达式树构造URL的性能",
        "Link": "/2009/09/make-expression-tree-based-url-construction-faster.html",
        "BriefIntro": "我们继续改进通过表达式树构造URL的方式。在上一篇文章中，辅助方法可以正确地识别了ActionNameAttribute，而这次改进的则是性能方面的问题。原先的代码使用了传统计算一个表达式树的方式：“使用LambdaExpression对象封装，再编译，最后执行”来获得一个Expression对象的值。但是，Compile方法的性能是比较低下的，如果密集地执行会对性能产生一定影响。我们可以使用FastLambda中的组件来优化这部分操作的性能。 "
    },
    {
        "Title": "通过表达式树构建URL时正确识别ActionNameAttribute",
        "Link": "/2009/09/get-action-name-from-expression-tree-by-actionnameattribute.html",
        "BriefIntro": "在MvcFutures项目中提供了一个辅助方法，可以将一个表达式树对象转化成一个RouteValueDictionary集合。只可惜，这个辅助方法的毛病比较多。例如，它直接把方法名作为action的值，而忽略了其上标记的ActionNameAttribute。这导致了某个被“改名”的Action方法一旦用在了表达式树中，最终得到的URL便是错误的。不过只需寥寥数行代码便可改变这个情况。 "
    },
    {
        "Title": "使用表达式树构建DomainRoute的URL",
        "Link": "/2009/08/build-url-from-expression-tree-for-domainroute.html",
        "BriefIntro": "由于DomainRoute支持针对URL域名的捕获和构造，这有些破坏了ASP.NET Routing所制定的“协议”（ASP.NET Routing只支持Path），因此在上一篇文章中，我们需要自己构造一个辅助方法来获得一个“包含域名”的URL。不过根据尽可能强类型的原则，我们应该使用的是类似于MvcFutures中定义的基于表达式树的辅助方法。由于MvcFutures已经提供了非常充足的辅助功能，因此这其实并不需要耗费我们多少代价。 "
    },
    {
        "Title": "使用Lambda表达式编写递归函数",
        "Link": "/2009/08/recursive-lambda-expressions.html",
        "BriefIntro": "其实这从来不是一个很简单的事情，虽然有些朋友认为这很简单。如果您把委托变量的声明和Lambda表达式分开写为两行，那么其实这已经是一中“伪”递归了。可能已经有朋友知道“标准”的做法是什么样的，不过我这里还想谈一下我当时遇到这个问题时想到的一个做法。比较笨（非常符合我的特点），但是可以解决问题。但是装配脑袋很早给了我们更好的解决方法，希望在以后的某一天，我可以把这部分内容融会贯通地理解下来，并且可以详细地解释给大家听。在这之前，我还是听脑袋的话，把Fix强行记在脑袋里吧。 "
    },
    {
        "Title": "与protected成员有关的单元测试方式",
        "Link": "/2009/08/unit-test-protected-method.html",
        "BriefIntro": "protected是一个有趣而有用的修饰符，它把方法的访问成员严格限制在自身或自己的子类身上。换句话说，在使用过程中，protected成员对外部是开放的（因为其他类可以通过继承来使用该成员），又是封闭的（不是自身或子类的一切成员都无法访问）。而对于单元测试来说，protected成员又是尴尬的，因为它的“开放”意味着我们必须对它进行单元测试，而“封闭”又阻碍了我们在单元测试中涉及protected成员。 "
    },
    {
        "Title": "所有的成员都应该是virtual的吗？",
        "Link": "/2009/08/virtually-necessary-members.html",
        "BriefIntro": "这是一个由来已久的讨论，由于Java默认所有的方法都是可以被override的（除非手动写成final），因此从C#语言设计起初就有此番争论，甚至让Anders都出来解释了一下。最近又有人在讨论这方面话题了，虽然我的看法并没有超出这些人所涉及的范畴，但是我还是打算谈一下我的理解。退几步说，就当补充一些“实例”吧。 "
    },
    {
        "Title": "趣味编程：函数式链表的快速排序",
        "Link": "/2009/08/functinal-list-quick-sort.html",
        "BriefIntro": "前一段时间有朋友问我，Haskell快速排序的代码，是否可以转化成C#中等价的Lambda表达式实现。我当时回答，C#中缺少一些基础的数据结构，因此不行。经过补充之后，就没有任何问题了。后来，我觉得这个问题挺有意思，难度适中，也挺考察“基础编程”能力的，于是就自己写了一个。如果您感兴趣的话，也不妨一试。 "
    },
    {
        "Title": "再谈public类型中internal成员的坏味道",
        "Link": "/2009/08/more-on-bad-smell-of-internal-members-in-public-classes.html",
        "BriefIntro": "上一篇文章里我讨论了一个类中internal成员可能会造成的坏味道，并且认为如果您的类型中出现了这个情况，可能就值得检查一下设计上是不是有问题了。文章中我提出了三种可能出现internal的情况，其中两种争议不大，不过对于“public类中是否应该出现internal成员”这一点似乎引起了一些争议。从评论中发现，讨论的一部分焦点并不是我的本意，这可能是我前文描述地较为简单而造成的，因此我现在对于这个方面再进行略为详细的探讨。 "
    },
    {
        "Title": "类中的internal成员可能是一种坏味道",
        "Link": "/2009/08/internal-member-is-bad-smell.html",
        "BriefIntro": "最近除了搞ASP.NET MVC之外，也在思考一些编程实践方面的问题。昨天在回家路上，忽然对一个问题产生了较为清晰的认识。或者说，原先只是有一丝细微的感觉，而现在将它和一些其他的方面进行了联系，也显得颇为“完备”。这就是问题便是：如何对待类中internal成员。我现在认为“类中的internal成员可能是一个坏味道”，换句话说，如果您的类中出现了internal的成员，就可能是设计上的问题了。 "
    },
    {
        "Title": "支持DomainRoute的URL构造辅助方法",
        "Link": "/2009/08/url-building-method-for-domainroute.html",
        "BriefIntro": "上一篇文章中我们构造了DomainRoute类，这是一个将URL Routing扩展至域名的Route组件，于是现在我们便可以轻易地从一个URL的Domain部分中捕获数据并在程序中使用。不过作为URL Routing的另一个重要部分，在URL构建方面，我们还需给DomainRoute补充额外的支持。 "
    },
    {
        "Title": "配合域名作URL Routing",
        "Link": "/2009/08/url-routing-with-domain.html",
        "BriefIntro": "经常有朋友问我，如何对域名作URL Routing，他们可能希望根据域名（或自域名）来获得一些值，最终影响Controller，Action或某些参数的选择。之前我只是简单地说“扩展一下ASP.NET Routing吧”，而现在由于自己也正好需要使用这个功能，便实现了一个扩展。使用下来，效果不错。 "
    },
    {
        "Title": "常用辅助方法收集",
        "Link": "/2009/08/common-extensions.html",
        "BriefIntro": "在项目里经常会出现一些常用的，好用的扩展方法，因此也想到把它收集起来。如果您有什么好的辅助方法，也可以告诉我，希望可以成为一套丰富的辅助方法，简化我们的开发生活。 "
    },
    {
        "Title": "基于ParsedRoute的Domain Parser",
        "Link": "/2009/08/domain-parser-based-on-parsedroute.html",
        "BriefIntro": "之前谈了不少关于ASP.NET Routing中ParsedRoute的内容，例如它的设计以及如何调用它的功能，其目的便是为了如今的使用作准备。现在我们就基于它构建一个Domain Parser，而这个Parser也是为今后的功能打基础的。 "
    },
    {
        "Title": "再谈ASP.NET Routing中的ParsedRoute",
        "Link": "/2009/08/more-on-parsedroute.html",
        "BriefIntro": "ParsedRoute是ASP.NET Routing中的内部类，作用是根据既定模式将一段URL解析为一个RouteValueDictionary。上次的文章中我主要谈了如何利用反射使用类库的内部成员，而这次则想分享一些使用ParsedRoute时产生的一些想法。 "
    },
    {
        "Title": "Kent Beck确认参加敏捷中国大会2009，讲述其35年架构设计心得",
        "Link": "/2009/08/kent-beck-is-coming-agile-china-2009.html",
        "BriefIntro": "尘埃落定，Kent Beck终于确定他的行程，将于敏捷中国大会（9月11日~12日）前两天来京参会，并以大讲堂的形式分享其在架构设计方面的心得，在大会当天会做\"实效的理想主义\"的演讲，和另一位敏捷宣传创始人Dave Thomas一同为大会开幕。另外，这也是KB首次来中国，欢迎一起观瞻这个有点传奇色彩的极限编程创始人、敏捷宣言创始人。 "
    },
    {
        "Title": "书籍推荐：国内第一本ASP.NET 3.5 MVC技术专著",
        "Link": "/2009/08/1552389.html",
        "BriefIntro": "周五的时候我知道了国内第一本ASP.NET 3.5 MVC技术专著问世了。当时忙着搬家理东西，写代码，写博客，就没有仔细搭理。现在瞅瞅，不得了，了不得，至少有四大亮点值得推荐。 "
    },
    {
        "Title": "为什么是HttpContextBase而不是IHttpContext",
        "Link": "/2009/08/why-httpcontextbase-instead-of-ihttpcontext.html",
        "BriefIntro": "由于HttpContext很难进行Mock，因此为了提高可测试性，微软随ASP.NET MVC发布了一个“抽象包”，专门用于对HttpContext及其相关组件进行抽象。不过在Preview 1版本中，这些抽象都是一个个接口，如IHttpContext，IHttpRequest等等。而在下一个版本中，立即就成为了一个个抽象类，如HttpContextBase，HttpRequestBase。现在我打算从“使用”角度来谈一下，为什么这里的确应该用抽象类而不是接口。 "
    },
    {
        "Title": "在单元测试时指定HttpContext的各种Path",
        "Link": "/2009/08/set-the-path-in-http-context.html",
        "BriefIntro": "设置HttpContext中各种Path一直是个问题，因为被测试的方法可能用到各种Path中的任何一个，而各种Path之间有一定关联，如果我们完全手动设置Mock对象的话会是一个浩大的工程。还好，这个问题还算容易解决。 "
    },
    {
        "Title": "C#编译器对泛型方法调用作类型推断的奇怪问题",
        "Link": "/2009/08/type-inference-bug-in-csharp.html",
        "BriefIntro": "范型是.NET平台上重要的功能，范型即为一个“不确定”的类型。C# 3.0中加强了对于类型推断的力度。但是C#的代码推断作的相当不完整，刚才我又遇上了一个奇怪的问题。 "
    },
    {
        "Title": "支持Area的ControllerFactory",
        "Link": "/2009/08/controller-factory-with-area-supporting.html",
        "BriefIntro": "由于项目需要，把ASP.NET MVC 2中的Area功能搬到1.0上来吧……其实只是借用个Area名头而已，根本不是那么一回事。有时候，我们就为自己的项目做一点简单的扩展，不是很合适吗？ "
    },
    {
        "Title": "复用类库内部已有功能",
        "Link": "/2009/08/use-the-internal-feature.html",
        "BriefIntro": "经常看我博客的人可能会知道，我是一个喜欢搞点小技巧来实现某个功能的人。例如博客的皮肤，自己花了不少时间定义，也是为了效果丰富一些。当然，搞得最多的是从框架或类库内部取出一点小功能来用用，节省自己开发的时间。 "
    },
    {
        "Title": "再谈抽象类和接口",
        "Link": "/2009/08/more-on-class-and-interface.html",
        "BriefIntro": "昨天我质疑了为什么定义RouteBase抽象类，而不是IRoute接口，我谈到对于一个“没有任何实现”的抽象类来说，开发人员应该使用接口。不过在后面的评论中，有朋友给了我启发，让我忽然想到更多的事情。晚上又再次翻了翻《Framework Design Guidelines》之后，打算再谈一些东西，把这个问题讨论地更加清楚一些。 "
    },
    {
        "Title": "ASP.NET Routing中最令人摸不着头脑的设计",
        "Link": "/2009/08/awful-design-in-asp-net-routing.html",
        "BriefIntro": "您觉得ASP.NET Routing中最令人摸不着头脑的设计是什么？ "
    },
    {
        "Title": "DefaultControllerFactory不是线程安全的",
        "Link": "/2009/08/asp-net-mvc-defaultcontrollerfactory-thread-unsafe.html",
        "BriefIntro": "由于项目需要，刚才打算为ASP.NET MVC应用程序增强ControllerFactory的功能，因此翻出了ASP.NET MVC的源代码开始阅读其DefaultControllerFactory。代码不多，很容易理解，不过读着读着便发现了问题，因为我发现DefaultControllerFactory不是线程安全的。 "
    },
    {
        "Title": "将Windows Live Writer打造为“所见即所得”编辑器",
        "Link": "/2009/08/windows-live-writer-wysiwyg.html",
        "BriefIntro": "Windows Live Writer的最大优势之一，便是可以自动获取目标博客的样式，然后让用户在特定的样式环境下编写文章。我们可以利用它在特定样式环境下编写HTML内容，这篇文章将会提供一个指南，希望可以帮助您打造一个合适的编辑环境。 "
    },
    {
        "Title": "NHibernate中一对一关联的延迟加载",
        "Link": "/2009/08/lazy-load-of-one-to-one-association-in-nhibernate.html",
        "BriefIntro": "这篇文章谈论的其实只是一个小技巧，而且甚至于这个是由于我对NHibernate不够了解而造成的。因此，如果您有更好的做法也请不吝指出。这个问题也就是“如何实现NHibernate中一对一映射的延迟加载”。 "
    },
    {
        "Title": "从.NET中委托写法的演变谈开去（下）：性能相关",
        "Link": "/2009/08/from-delegate-to-others-3.html",
        "BriefIntro": "在上一篇文章中，我们详细讲述了C# 3.0中Lambda表达式（构造委托）的使用方式，它在语义上的优势及对编程的简化――这些内容已经属于委托的“扩展内容”。不如这次谈得更远一些，就来讨论一下上文中“编程方式”的性能相关话题。 "
    },
    {
        "Title": "从.NET中委托写法的演变谈开去（中）：Lambda表达式及其优势",
        "Link": "/2009/08/from-delegate-to-others-2.html",
        "BriefIntro": "在上一篇文章中我们简单探讨了.NET 1.x和.NET 2.0中委托表现形式的变化，以及.NET 2.0中匿名方法的优势、目的及注意事项。那么现在我们来谈一下.NET 3.5（C# 3.0）中，委托的表现形式又演变成了什么样子，还有什么特点和作用。 "
    },
    {
        "Title": "从.NET中委托写法的演变谈开去（上）：委托与匿名方法",
        "Link": "/2009/08/from-delegate-to-others.html",
        "BriefIntro": "在《关于最近面试的一点感想》一文中，Michael同学谈到他在面试时询问对方“delegate在.net framework1.1,2.0,3.5各可以怎么写”这个问题。我也问过，那么我就先单独针对这个问题进行解释，然后谈谈自己为什么会提出这个问题吧。 "
    },
    {
        "Title": "适合C# Actor的消息执行方式（6）：协变与逆变",
        "Link": "/2009/08/message-execution-model-for-c-sharp-actor-6-covariance-and-contravariance.html",
        "BriefIntro": "在上一篇文章中，我们实现了一个简单的爬虫，并指出了这种方式的缺陷。现在，我们就来看一下，如何使用C# 4.0中所引入的“协变和逆变”特性来改进这种消息执行方式，这也是我认为在“普适Actor模型”中最合适的做法。这次，我们动真格的了，我们会一条一条地改进前文提出的缺陷。 "
    },
    {
        "Title": "Agile China 2009大会报名信息",
        "Link": "/2009/08/agile-china-2009.html",
        "BriefIntro": "在敏捷领域最具有影响力的技术社区InfoQ中文站、敏捷方法论的领导厂商ThoughtWorks共同主办的敏捷中国技术大会（Agile China 2009），将于9月11日~12日（周五、周六）在北京举行。届时将有超过400位来自电信、金融、互联网、教育等行业在内的高级软件开发人员、项目管理人员等参加。 "
    },
    {
        "Title": "收到了《博客园精华集Web分册》",
        "Link": "/2009/07/1535646.html",
        "BriefIntro": "我对《精华集》这种形式的书籍也没什么好感（这是实话），认为这代表不了博客园的水平，里面选择的文章也难有太高价值――最多也就值的放在互联网上作为资源“库”的填充吧。不过翻看过后，不觉对我的想法感到羞耻。我太小看这些文章了，这些文章的确是精华――不论其他分册，目前我单指《Web分册》，甚至单指第一第二部分：HTML、CSS与标准。 "
    },
    {
        "Title": "快速计算表达式树",
        "Link": "/2009/07/expression-tree-fast-evaluation.html",
        "BriefIntro": ".NET 3.5中新增的表达式树（Expression Tree）特性，第一次在.NET平台中引入了“逻辑即数据”的概念，它是LINQ to Everything在技术实现上的重要基石之一。对表达式树进行计算，是处理表达式树时中最常见的工作了。根据我的本地测试结果，在一台P4 2.0 GHz的服务器上，单线程连续计算一万个简单的四则运算表达式便要花费超过1秒钟时间。这并非是一个可以忽略的性能开销，引入一种性能更好的表达式树计算方法势在必行。 "
    },
    {
        "Title": "适合C# Actor的消息执行方式（5）：一个简单的网络爬虫",
        "Link": "/2009/07/message-execution-model-for-c-sharp-actor-5-a-simple-web-crawler.html",
        "BriefIntro": "之前的几篇文章大都在摆一些“小道理”，有经验的朋友容易想象出来其中的含义，不过对于那些还不了解Actor模型的朋友来说，这些内容似乎有些太过了。此外，乒乓测试虽然经典，但是不太容易说明问题。因此，今天我们就来看一个简单的有些简陋的网络爬虫，对于Actor模型的使用来说，它至少比乒乓测试能够说明问题。对了，我们先来使用那“中看不中用”的消息执行方式。 "
    },
    {
        "Title": "IT168转载问题解决情况，以及本人博客转载方式",
        "Link": "/2009/07/it168-thief.html",
        "BriefIntro": "与IT168编辑联系之后，他们已经在文章最后添加原文链接，并且答应以后的各类转载都会符合协议。这个结局比较令人满意。此外，我在这里详细谈一下这方面的一些做法。 "
    },
    {
        "Title": "浅谈线程池（中）：独立线程池的作用及IO线程池",
        "Link": "/2009/07/thread-pool-2-dedicate-pool-and-io-pool.html",
        "BriefIntro": "在上一篇文章中，我们简单讨论了线程池的作用，以及CLR线程池的一些特性。不过关于线程池的基本概念还没有结束，这次我们再来补充一些必要的信息，这样有助于我们在程序中选择合适的使用方式。例如，为什么要有独立的线程池，CLR线程池到底有什么不足，IO线程池又是什么呢？有了这些准备之后，最后的试验也就非常自然了。 "
    },
    {
        "Title": "浅谈线程池（上）：线程池的作用及CLR线程池",
        "Link": "/2009/07/thread-pool-1-the-goal-and-the-clr-thread-pool.html",
        "BriefIntro": "线程池是一个重要的概念。不过我发现，关于这个话题的讨论似乎还缺少了点什么。作为资料的补充，以及今后文章所需要的引用，我在这里再完整而又简单地谈一下有关线程池，还有.NET中各种线程池的基础。更详细的内容就不多作展开了，有机会我们再详细讨论这方面的细节。这次，还是一个“概述”性质的，希望可以说明白这方面问题的一些概念。文章分两段，我们先来谈谈线程池的作用，及CLR自带的线程池。 "
    },
    {
        "Title": "适合C# Actor的消息执行方式（4）：阶段性总结",
        "Link": "/2009/07/message-execution-model-for-c-sharp-actor-4-mid-stage-conclusion.html",
        "BriefIntro": "阶段性总结本不在计划之内，不过似乎Actor模型这方面内容还不太受人关注，因此有的朋友也误解这系列文章想要解决的问题是什么。除了这方面的解释之外，我还会对之前提出的几种做法进行综合的对比，可以进一步了解整个演变过程的思路，为接下去的改变做铺垫――因为下次改变就涉及到多个方向，每个方向都是在一定程度上真正可用的方式。 "
    },
    {
        "Title": "适合C# Actor的消息执行方式（3）：中看不中用的解决方案",
        "Link": "/2009/07/message-execution-model-for-c-sharp-actor-3-nice-solution-with-little-use.html",
        "BriefIntro": "在前两篇文章中，我们了解到Erlang中灵活的模式匹配，以及在C#甚至F#中会都遭遇的尴尬局面。那么现在就应该来设计一个解决方案了，我们如何才能在C#这样的语言里顺畅地使用Actor模型呢？不仅如此，最好我们还能获得其它一些优势。但事情总是很难一帆风顺的，最终我们这篇文章只得出一个中看不中用的解决方案。不过……至少方向是正确的吧。 "
    },
    {
        "Title": "老赵书托（2）：计算机程序的构造与解释",
        "Link": "/2009/07/recommended-reading-2-sicp.html",
        "BriefIntro": "老赵要推荐的第一本书便是大名鼎鼎的《Structure and Interpretation of Computer Programs》，在国内可以买到中译版，即机械工业出版社的《计算机程序的构造与解释》。豪不夸张地说，这是一本影响了好几代程序员的书。自从上世纪80年代MIT开始使用这本书作为教材开始，它使用Lisp语言――直到前两年才被Python取代，但是使用哪本教材不得而知，由这个侧面也可见SICP这本书的影响力有多么深远。在技术日新月异的计算机行业，有多少教材可以经得起20年的考验？ "
    },
    {
        "Title": "适合C# Actor的消息执行方式（2）：C# Actor的尴尬",
        "Link": "/2009/07/message-execution-model-for-c-sharp-actor-2-embarrassing-c-sharp-actor.html",
        "BriefIntro": "在上一篇文章中，我们简单解读了Erlang在执行消息时候的方式。而现在，我们就一起来看看，C# Actor究竟出现了什么样的尴尬。此外，我还打算用F#进行补充说明，最终我们会发现，虽然F#看上去很美，但是在实际使用过程中依旧有些遗憾。 "
    },
    {
        "Title": "适合C# Actor的消息执行方式（1）：Erlang中的模式匹配",
        "Link": "/2009/07/message-execution-model-for-c-sharp-actor-1-pattern-matching-in-erlang.html",
        "BriefIntro": "Actor模型为并行而生。由于现在单台机器中独立的计算单元也越来越多，Actor模型的重要性也越来越大。Actor模型的理念是：天下万物皆为Actor，Actor之间通过发送消息进行通信。不同的Actor可以同时处理各自的消息，从而获得了大规模的并发能力。对于.NET平台下的开发人员来说，最常用的语言是C#。不过，无论您使用哪个Actor框架，在消息的执行阶段总是略显尴尬。本文的目的便是提出一种适合C# Actor的消息执行方式，而这种执行方式还会成为我以后公开的C#中“模式匹配”的基础。本文将分为三个部分，您目前正在阅读的第一部分，将会观察Erlang是如何执行消息的。有对比才会有差距，也正是由于Erlang在Actor模型上的示范作用，我们才会意识到C# Actor在使用上有多么的不方便。 "
    },
    {
        "Title": "关于网页*静态化*及SEO问题的一些补充",
        "Link": "/2009/07/more-on-page-statilization-and-seo.html",
        "BriefIntro": "前一篇讨论“静态页”的文章反响不错，不少朋友发表了自己的看法，也给老赵更多的想法。虽然也在前一篇文章后面回复了不少内容，但是就以往经验来看，总结为一篇新的文章会让我想表达的内容更为明确。对于“静态化”这一原本就非常容易让人混淆的概念来说更是如此。在这篇文章里，老赵也会谈谈自己对于SEO这个工作的看法――以及以前遇到过的一个SEO“专家”。欢迎围观。 "
    },
    {
        "Title": "谈*静态页*（或网页*静态化*）的时候，请区分一些概念",
        "Link": "/2009/07/talk-about-page-statilization.html",
        "BriefIntro": "“静态页”，在Web应用程序开发中是很常见的概念。只是我发现目前还是有相当部分的朋友，在这方面的存在一定的误区。不久前有朋友写了一篇题为《提供生成静态页核心代码》的文章，介绍了一种“向硬盘写入页面文件”的方式。这篇文章的内容在此并不多作讨论，只是它的摘要存在一个严重的问题，因为它混淆了两个概念。现在独立写一篇文章，也想把一些问题讲讲清楚，以后在讨论的时候也好有个准。 "
    },
    {
        "Title": "是什么造成了MVP的尴尬现状？我们该怎么办？",
        "Link": "/2009/07/embarrassed-mvp.html",
        "BriefIntro": "MVP项目其实微软的“专家认证”活动之一，不过它并非根据培训或考试而来，而是根据个人在社区表现评选出来的内容。从这一方面来说，MVP应该是广受社区群众爱戴的群体。但是后来等我也评上MVP的时候，发现事实似乎并非如此。微软眼中的“社区英雄”，反而在社区中的评价越来越差。就2009年7月新当选的MVP来看，似乎绝大部分的声音都是“质疑”。我也在想，是什么造成了MVP的尴尬现状？我们又该怎么办？如果您有什么建议，能否说出来一起讨论一下？ "
    },
    {
        "Title": "龙芯一二事（转载）",
        "Link": "/2009/06/1513077.html",
        "BriefIntro": "我不知道龙芯是否真是一个笑话。不过我也从一些在中科院计算所搞龙芯相关的朋友那里获得了一些信息（不是耳闻，而是一手信息）。这年头真假太难辨别，由于大伙儿对于例如gov或某些机构的某些做法的不满，导致即使是真的事情也变假了。龙芯从一开始其实就伴随着负面评价，从一开始的技术上的质疑，在技术上不知如何下手后，到政治方向上的反对等等。有时候我也不明白，对于一个错误的东西，使用错误的方式去反对它，这种做法是否正确。还是回到龙芯上吧，这次我转载的一些东西很显然是在做“解释”。可能某些朋友会说我五毛，但五毛就五毛吧。就当我只是把东西列举出来，大家一起判断。说实话，我也不知道究竟是正确不正确。在一个信息不对称的环境中，作为一个旁观者，我们究竟可以做出什么样的评价？说它好，理由何在？说它坏，难道也只是随口说说就可以了吗？ "
    },
    {
        "Title": "拯救C# 2.0，但是我们真做的到吗？",
        "Link": "/2009/06/try-to-make-a-better-csharp-2.html",
        "BriefIntro": "似乎还有不少项目在用C# 2.0（本文最后我们来做一个调查），但是C# 2.0的生产力实在不如C# 3.0――如果您不信，那么一会儿就会意识到这一点。有朋友认为语言能力不重要，有了好用的框架/类库也可以有很高的生产力。所以这篇文章，我们就设法使用“类库”来弥补C# 2.0的缺陷。但是，我们真做的到吗？ "
    },
    {
        "Title": "天下无处不乒乓",
        "Link": "/2009/06/everything-ping-pong.html",
        "BriefIntro": "在消息传递（Message Passing）领域，PingPong是最常见的测试之一。它的功能简单的有些无聊，一个Ping Actor和一个Pong Actor之间互相传递消息，你Ping过来我Pong过去。也正因为如此简单，PingPong的目标仅仅是测试纯粹的消息传递机制的效率。也正因为如此，各Actor模型往往都将其作为展示自己功能的第一个示例。老赵从互联网上收集了一些最为常见的，不同语言/平台下Actor模型实现PingPong的示例，可作“观赏”之用。 "
    },
    {
        "Title": "编程小练习：拆分自然数",
        "Link": "/2009/06/1507847.html",
        "BriefIntro": "上次的小练习的反响很不错，于是今天我们再来做一道小题目。上次有朋友指出，“反转数组”这种题目非常无聊，“写的再好，又会比框架自带的实现好吗？”。其实做这些小题目的作用是锻炼“编程解决问题”的能力，并非是为了替换框架的实现等等。咱们小学初中高中，不都会做数学题目，几何代数的吗？目的都是为了建立基本解题能力。现在的题目也是这样，请不要误会这些习题的目的。 "
    },
    {
        "Title": "贺计算机成*就业最困难专业*（转载）",
        "Link": "/2009/06/1501834.html",
        "BriefIntro": "从99年开始的扩招，计算机专业是重灾区，全国各大高校，不管是工科的还是文科的，不管自身有没有足够的基础，只要买一批电脑，招几个老师就能开个计算机专业，没用几年，计算机专业成了规模最大的工科专业之一，可谓“计算机教育大跃进”，事实上，这些年来IT业在迅速扩张，对人才的需求一直是很旺盛的，在现在这个计算机无孔不入的信息时代，计算机专业本不应该成“最难就业专业”。 然而，这一现象居然在中国出现，说明了什么？ "
    },
    {
        "Title": ".NET中*延迟*特性的几个陷阱",
        "Link": "/2009/06/laziness-traps.html",
        "BriefIntro": ".NET发展至今，其实各处都有“延迟（Lazy）”的痕迹，一个小小的“Laziness”给我们带来了不少灵活性。“延迟”的关键就在于“只在需要的时候处理数据”，老赵曾经在多篇文章中提到了类似的概念，如《高阶函数、委托与匿名方法》及《您善于使用匿名函数吗？》。不过“延迟”本身也会给您带来一些陷阱，某些陷阱您很有可能也曾经遇到过。这篇文章便是总结了延迟特性的集中常见陷阱，并给出应对方案。 "
    },
    {
        "Title": "老赵谈IL（3）：IL可以看到的东西，其实大都也可以用C#来发现",
        "Link": "/2009/06/my-view-of-il-3-use-c-sharp-instead-of-il.html",
        "BriefIntro": "IL的确比C#等高级语言来的所谓“底层”，但是很明显，IL本身也是一种高级抽象。而即使是机器码，它也可以说是基于CPU的抽象，CPU上如流水线，并行，内存模型，Cache Lock等东西对于汇编/机器码来说也可以说是一种“封装”。从不同层次可以获得不同信息，我们追求“底层”的目的肯定也不是“底层”这两个字，而是一种收获。了解自身需要什么，然后能够选择一个合理的层次进入，并得到更好的收益，这本身也是一种能力。追求IL的做法，本身并没有错，只是追求IL一定是当前情况下的最优选择吗？这是一个值得不断讨论的问题，我的这篇文章也只是表达了我个人对某些问题的看法。 "
    },
    {
        "Title": "自己动手生成评论RSS",
        "Link": "/2009/06/build-your-own-comment-rss.html",
        "BriefIntro": "最近博客园讨论气氛热烈，有价值的评论也层出不穷。有时候我们会很希望订阅某篇文章的评论RSS，只可惜博客园目前没有这个功能。对于注册用户来说，我们可以通过点击评论框下方的“订阅回复”链接，这样就会在出现新评论的时候收到邮件。可惜匿名用户，只得不断刷新才能关注最近讨论到什么地方了。不过我们是什么人？我们是程序员，这点障碍对我们来说应该是在简单不过的小事了。自己搭一个站点，获取页面数据，分析HTML，输出为RSS，就这么简单。 "
    },
    {
        "Title": "老赵谈IL（2）：CLR内部有太多太多IL看不到的东西，包括您平时必须了解的那些",
        "Link": "/2009/06/my-view-of-il-2-il-shows-little-about-clr.html",
        "BriefIntro": "CLR作为承载IL的平台，就像一个溺爱孩子的父母，操办了孩子生活所需要的一切。这个孩子一嚷嚷“我要吃苹果”，则父母就会拿过来一个苹果。您咋看这个孩子，都还是无法了解父母是如何获得苹果的（new一个Apple对象），怎么为孩子收拾残局的（GC）。虽然这些经常是所谓的“成年人（.NET程序员）必知必会”。而您如果盯着孩子看了半天，耐心分析他吃苹果的过程（使用IL编写的逻辑），最后终于看懂了，可惜发现――tmd老子自己也会吃苹果啊（从C#等高级语言中也能看出端倪来）！ "
    },
    {
        "Title": "驳文不看文，实在可怕",
        "Link": "/2009/06/1494216.html",
        "BriefIntro": "一早看到包同学的驳文《批驳小赵之IL无用论（1）》，甚是期待，但看了第一个回复，却让我大失所望。包同学能否看清了老赵以前说过的，自己以前说过的，以及老赵昨天说的东西以后再进行反驳呢？我们很多明明是同样的观点，为什么变成相互驳斥了呢？ "
    },
    {
        "Title": "老赵谈IL（1）：IL是什么，它又不是什么？那么汇编呢？",
        "Link": "/2009/06/my-view-of-il-1-il-and-asm.html",
        "BriefIntro": "我们.NET开发人员必定离不开IL，就算您没有学习，也一定可以在各处看到它的身影。最近在博客园上活跃的IL文章译者包建强同学的一些看法让老赵大为震惊，决定独立开篇，希望可以让大家看到不同的声音。真理越辩越明，也欢迎大家来一起讨论，发表自己意见。老赵也会尽量把朋友们留在老赵博客上的看法汇总起来，并加以回应。《老赵谈IL》也是系列文章，目前的计划有4篇，您现在看到的便是本系列的第1篇：IL是什么，它又不是什么。 "
    },
    {
        "Title": "谈表达式树的缓存（7）：五种缓存方式的总体分析及改进方案",
        "Link": "/2009/05/expression-cache-7-optimization.html",
        "BriefIntro": "终于到了这个系列的最后一篇文章了，这个系列的文章本是许多话题的基础，却拖了那么长时间还没有完结。这篇文章主要讨论五种缓存方式各自的优劣，以及他们的性能关键在什么地方，如果要进行改进又有什么可选方案。在这个问题上，老赵的思考可能会有遗漏，如果您有任何补充，也请不吝指出。 "
    },
    {
        "Title": "从汇编入手，探究泛型的性能问题",
        "Link": "/2009/05/generics-performance-via-asm.html",
        "BriefIntro": "经过了《泛型真的会降低性能吗？》一文中的性能测试，已经从实际入手，从测试数据上证明了泛型不会降低程序效率。只是还是有几位朋友谈到，“普遍认为”泛型的代码性能会略差一些，也有朋友正在进一步寻找泛型性能略差的证据。老赵认为这种探究问题的方式非常值得提倡。不过，老赵忽然想到，如果从能从汇编入手，证明非泛型和泛型的代码之间没有性能差距――好吧，或者说，存在性能差距，那么事情不就到此为止了吗？任何理论说明，都抵不过观察计算机是如何处理这个问题来的“直接”。因此，老赵最终决定通过这种极端的方式来一探究竟，把这个问题彻底解决。 "
    },
    {
        "Title": "泛型真的会降低性能吗？",
        "Link": "/2009/05/generic-performance-test.html",
        "BriefIntro": "在《.NET,你忘记了么？（八）―― 从dynamic到特性误用》一文中，飞林沙同学提到，使用范型会略微降低程序性能，因此在程序中使用List<Ojbect>是不合理的行为，应该使用ArrayList。这一点和老赵平时的观点相悖，老赵一直提倡，在.NET 2.0之后，要尽可能使用List<T>，情愿是List<Object>也不要使用ArrayList。不过个中原因与性能无关，我们稍候再叙述。飞同学的文章让我有了将范型与非范型进行性能比较的想法。这个比较非常容易，不过也得出了一些非常有意思的结论。 "
    },
    {
        "Title": "写程序时该追求什么，什么是次要的？",
        "Link": "/2009/05/1491692.html",
        "BriefIntro": "就我看来，一段程序，最该关注的是“逻辑表现”，不该追求的是“性能”。当然，肯定也会有需要追求性能的场景，不过这并不是“追求”出来的，而是在大量经验累计情况下做出的正确决策。就算在那种情况下，“逻辑表现”还是非常重要的。 "
    },
    {
        "Title": "一道简单的编程题，不过您做对了吗？",
        "Link": "/2009/05/1491052.html",
        "BriefIntro": "CSDN学生中心是个好地方，如果善于利用，应该能够对大众产生正面影响。老赵也去那里安了家，并给出了一个编程问题。题目如下：Reverse方法的作用是将array数组中，从begin下标到end下标之间的元素反序一下，如一个数组初始值是[1, 2, 3, 4, 5, 6]，begin为1，end为4，那么当调用了Reverse之后，array数组中的元素便依次成为[1, 5, 4, 3, 2, 6]，其中从array[1]到array[4]之前的元素被反序了。此外补充一点……其实本不用补充：这个方法需要对传入参数的正确性进行校验，如果用户调用该方法时传入了非法的参数，那么则需要抛出异常，并写清原因。简单，不是吗？只可惜截止到目前，也只有1人给出了正确答案。 "
    },
    {
        "Title": "谈表达式树的缓存（6）：五种缓存方式的性能比较",
        "Link": "/2009/05/expression-cache-6-perf-test.html",
        "BriefIntro": "目前我们已经涉及了五种不同的缓存实现（SimpleKeyCache、PrefixTreeCache、SortedListCache、HashedListCache和DictionaryCache），如果要从一个已经包含n个表达式树的存储中，查找一个有m个节点的表达式树，根据几篇文章的分析，从理论上说除了HashedListCache的时间复杂度是O(m * log(n))之外，其它几种实现的时间复杂度都是O(m)。不过，理论上的结果和实际使用中的效果完全符合吗？那么我们就写一个程序，让数据说话。这是一个控制台应用程序，接受用户参数，并由此生成试验数据，或进行性能比较。 "
    },
    {
        "Title": "在简单控制台程序中获取并使用参数",
        "Link": "/2009/05/simple-arguments-handling-for-console-app.html",
        "BriefIntro": "一个简单的处理控制台参数输入的代码片断，没有技术含量，只是在博客上做一个“备份”，方便以后查询。 "
    },
    {
        "Title": "正在构建一个新的版式",
        "Link": "/2009/05/new-template-minyx2-lite.html",
        "BriefIntro": "老赵对目前博客园中的模板都不太满意：样式单调，元素不够丰富，不容易Hack，不够“标准”，不够充分利用屏幕横向距离等等。因此和dudu商量后，准备为博客园新增一个模板。 "
    },
    {
        "Title": "ActorLite：一个轻量级Actor模型实现（下）",
        "Link": "/2009/05/a-simple-actor-model-implementation-3.html",
        "BriefIntro": "在上一篇文章中，我们实现了一个简单的Actor模型。如果要构建一个Actor，便只是简单地继承Actor类型并实现其Receive方法即可。在上次文章的末尾，我们使用C#演示了该Actor模型的使用。不过现在我们将尝试一下F#。 "
    },
    {
        "Title": "ActorLite：一个轻量级Actor模型实现（中）",
        "Link": "/2009/05/a-simple-actor-model-implementation-2.html",
        "BriefIntro": "从上一篇文章的反响来看，似乎大家对于这一话题并没有太大兴趣。而这篇文章将会为大家带来一个简单但完整的Actor模型实现。此外，在下一篇文章中……可能会出现一些让您觉得有趣的东西。:) "
    },
    {
        "Title": "ActorLite：一个轻量级Actor模型实现（上）",
        "Link": "/2009/05/a-simple-actor-model-implementation.html",
        "BriefIntro": "Actor模型为并行而生，具Wikipedia中的描述，它原本是为大量独立的微型处理器所构建的高性能网络而设计的模型。而目前，单台机器也有了多个独立的计算单元，这就是为什么在并行程序愈演愈烈的今天，Actor模型又重新回到了人们的视线之中了。在这篇文章中，我们会先对Actor Model的相关知识进行简单的介绍。 "
    },
    {
        "Title": "老赵书托（1）：写在前面",
        "Link": "/2009/05/recommended-reading-1.html",
        "BriefIntro": "从现在开始，老赵将推荐一些自认为非常优秀且重要的书籍，并和大家一起交流自己的读书体会。这些书都是老赵认为的“.NET开发人员必读书籍”，但是您会发现，它们不一定是和.NET有关的书籍。基于老赵一贯的风格，我会尽可能地认真对待每一本书，甚至会把它们重新浏览一番，因此无法保证“书托”行动的周期长度，请大家谅解。 "
    },
    {
        "Title": "语言真是不重要的吗？谈语言的*层次*与技术的三六九等",
        "Link": "/2009/05/talk-about-language-arguing.html",
        "BriefIntro": "关注――或“专注”于多语言编程之后，老赵对于语言的关注也越来越多，对于语言在编程中所带来的“美感”也有了越来越深的体会，还在博客的标题中加上“追求编程之美”。关注语言多了，关注纯粹的编程实践多了，自会有所比较，然后写出了引人注目的《为啥老赵不喜欢Java*语言*》。这篇文章所得到的负面评论的确也和想象中差不多，大部分朋友的观点是“语言不是关键”或类似说法，似乎对语言的讨论和比较非常没有必要。有个朋友说的更是直接：“在看到这些文章之前，我还是比较敬重老赵的，不过现在发现你也就这点高度”。老赵认为，这是对这方面的误解，而有这种误解无论是对于社区还是个人的发展都是没有益处的，因此单独开篇，讨论一下这个问题。 "
    },
    {
        "Title": "令人失望的智器Smart Q5",
        "Link": "/2009/05/1447656.html",
        "BriefIntro": "前一段时间看到有人提到了“智器Smart Q5（以下简称Q5）”这个手持上网设备，从网上的介绍来看，几乎可以用“划时代”来形容了：4.3寸屏幕，1600万色，800*480分辨率，内置MS Office兼容的编辑器、电子书阅读器（支持pdf，chm等常用格式）和媒体播放器（支持rmvb，mp3，mp4，ape，flac等各种媒体格式），并且可以使用wifi，兰牙，并可外接edge网卡――而且只要9... "
    },
    {
        "Title": "关于争论中的*专业*，老赵谈一下自己的看法",
        "Link": "/2009/04/be-a-professional-arguer.html",
        "BriefIntro": "又到了一周一次的总结时间，经历了两周前的“Java语言风波”和“图书通病”，可以发现最容易引起大家关注的还是这样的讨论――嗯嗯，或者说是吵架。吵着吵着就会有各种“典型”的声音冒出来，使用各种形式从不同人口中反复出现，每次都看得老赵“心花怒放”，“欲仙欲死”。老赵觉得“争论”是有价值的，但是“我们的争论”至少有一半是没有太多营养价值的。实事求是地说，那篇Java文贴了4个地方，声音最大，但是收获最少的便是博客园（当然，如果贴去CSDN和cnbeta的话，情况自然就可能不一样了）。为什么会产生这个原因呢？老赵认为，关键还是在于“不专业”。 "
    },
    {
        "Title": "为视图自定义辅助方法（下）",
        "Link": "/2009/04/custom-view-helpers-2.html",
        "BriefIntro": "在上一篇文章中，我们把繁冗的客户端脚本变成了可以由Visual Studio提示并轻易输出的服务器端辅助方法。但是，目前的做法还有不少可以改进的地方。我们编写辅助方法的目的便是为了简化开发，因此我们还可以在这条路上走的更远，让开发人员可以在使用我们的API时觉得更流畅，更有快感。 "
    },
    {
        "Title": "为视图自定义辅助方法（上）",
        "Link": "/2009/04/custom-view-helpers-1.html",
        "BriefIntro": "在编写ASP.NET MVC应用程序时，只依赖内置的视图辅助方法很难达到很高的生产力，即使是定义在MvcFutures中的补充类库，也很难满足项目的具体需求。此外，不同的项目有不同的特点，在很多时候也需要定义较为特殊的辅助方法，使开发人员能够更快，更方便地写出更容易维护的代码。这也是自定义视图辅助方法最主要的目的（没有之一）。而这次的文章，便是给出一个这方面的示例，可作为此类问题的一个参考。 "
    },
    {
        "Title": "关于基础与能力，谈一点我的看法",
        "Link": "/2009/04/1443234.html",
        "BriefIntro": "时不时会有朋友写信问老赵学习上的一些迷茫，其中都有一些共性。例如说不知道该如何学习，说不知道朝哪个方向前进。也例如大家虽然基本上都知道“算法”的重要性，但是却总觉平时用不到。说它锻炼能力，但“能力”是看不见摸不着的，学着学着就会“麻木”，感觉就“学不进去”了。当然这方面有几个原因，有主观也有客观的，有需要周围环境的改变，也有需要自己精神上“强壮度”的提高。这里呢，我们有时就不提“算法”这个太具体的... "
    },
    {
        "Title": "使用ASP.NET Abstractions增强ASP.NET应用程序的可测试性",
        "Link": "/2009/04/improve-asp-net-testability-via-abstractions.html",
        "BriefIntro": "关于可测试性的重要性，老赵觉得已经不需要再过多强调了。如果您想要获得高生产力，为代码编写单元测试似乎已经是必经之路了。不过可惜的是，ASP.NET应用程序给人的感觉，始终是对可测试性不太友好，其最重要的原因之一在于对HttpContext对象的高度依赖，而我们很难对HttpContext编写Mock或Stub。而现在，我们可以基于ASP.NET Abstraction来辅助ASP.NET开发，改进代码的可测试性。 "
    },
    {
        "Title": "事理越辩越明，那么就来详细说说为什么我不喜欢Java*语言*",
        "Link": "/2009/04/why-i-do-not-like-java.html",
        "BriefIntro": "最近我对Java语言唱衰似乎凶狠了一点，让有些朋友不是很爽，认为我不负责任凭个人感觉乱说话，影响不好。这讨论事情事小，否认我做事方式就不好了。因此我这里也继续整理一下我对Java语言的观点，这样大家不必四处查看我的说辞，再者也可以控制一下讨论事情的方式，以免大家舞蹈半天尘土飞扬最后停下一看――得，双方在自说自话，这怎能辩明事理，您说呢？ "
    },
    {
        "Title": "高阶函数、委托与匿名方法",
        "Link": "/2009/04/csharp-higher-order-function.html",
        "BriefIntro": "这是几个月前就写的文章，只是一直忙于QCon的各项事宜，最近才发表出来。这篇是对.NET中委托，匿名方法和高阶函数使用的一个介绍，非常简单，目的是强调一下C#中对于高阶函数的使用，体现一下现在C#的高度生产力。 "
    },
    {
        "Title": ".NET平台下Web测试工具横向比较",
        "Link": "/2009/04/1435140.html",
        "BriefIntro": "为InfoQ写的一篇新闻。由于我有三不写原则（不翻译、不介绍、不重复），觉得有些值得介绍并推广的东西，还是放在InfoQ上吧。 "
    },
    {
        "Title": "辅助方法不嫌多",
        "Link": "/2009/04/cannot-have-too-many-helper-methods.html",
        "BriefIntro": "在开发项目过程中，总是会出现大量的辅助方法，例如字符串处理，代码检验，格式输出等等。如果您发现自己在多次编写类似的代码，可能就要想着如何把这些代码进行提取，变成辅助方法（亦或是类库甚至框架，关于这方面粒度问题在此不作讨论）。辅助方法的作用除了遵循DRY原则之外，也能让代码更容易编写，更为清晰，可读性也能更好――而且只要您“去做”，就会发现要得到这些好处并不困难。 "
    },
    {
        "Title": "使用WinDbg获得托管方法的汇编代码",
        "Link": "/2009/04/get-asm-of-managed-method-by-windbg.html",
        "BriefIntro": "有时候，我们需要查看一个.NET方法的汇编指令是怎么样的。记得在大学的时候，我们使用gcc -s和objdump来获得一个c程序代码的汇编指令。但是对于.NET程序来说，我们肯定无法轻松地获得这些内容。因为所有的.NET程序都是编译成IL代码的，而只有在运行时才会被JIT编译成本机代码。老赵这里演示一下如何使用WinDbg来做到这一点。 "
    },
    {
        "Title": "浅谈尾递归的优化方式",
        "Link": "/2009/04/tail-recursion-explanation.html",
        "BriefIntro": "在上文《尾递归与Continuation》里，我们谈到了尾递归的概念和示例，不过有些朋友对于尾递归的功效依然有所怀疑。因此现在，老赵再简单讲解一下尾递归的优化原理，希望能给大家以一定理性认识。 "
    },
    {
        "Title": "尾递归与Continuation",
        "Link": "/2009/03/tail-recursion-and-continuation.html",
        "BriefIntro": "这几天恰好和朋友谈起了递归，忽然发现不少朋友对于“尾递归”的概念比较模糊，网上搜索一番也没有发现讲解地完整详细的资料，于是写了这么一篇文章，权当一次互联网资料的补充。 "
    },
    {
        "Title": "使用IronPython检测ASP.NET程序状况（下）",
        "Link": "/2009/03/ironpython-aspnet-request-sampling.html",
        "BriefIntro": "在上一篇文章中，我们在一个请求中执行了IronPython代码，通过这个方法我们可以轻松地的检查系统运行的状态，或对系统进行一些简单修改。但是这种做法只能检查系统在当前时刻的状态，在很多情况下，我们需要对系统的请求进行一段时间的采样。对于简单的数据（例如每秒执行的请求数量，请求时间），我们可以通过查看Performance Monitor中相关的计数器来获得一些概要的数据。但是，如果我们需要获取一些系统的详细状态，甚至是需要根据需要进行动态改变的自定义需求，则势必要深入到系统内部进行数据采集。那么，我们该怎么做呢？ "
    },
    {
        "Title": "使用IronPython检测ASP.NET程序状况（上）",
        "Link": "/2009/03/ironpython-aspnet-diagnostics.html",
        "BriefIntro": "在维护一些生产环境中的ASP.NET应用程序时，老赵经常会感到“力不从心”。虽然我们可以建立丰富有效的监控或日志等维护机制，但是调试和分析一次程序经常需要耗费大量的脑细胞。因为我们可以使用的工具大都非常抽象，即使是一个非常微小的问题，也要用较多的时间才能发现“哦，原来是这个变量的值进入了一种奇怪的状态”。如果我们有一种机制，可以直观地检查生产环境中正在运行的程序的状态，那么一定可以大大方便我们的工作。 "
    },
    {
        "Title": "老赵看博客园首页",
        "Link": "/2009/03/1418621.html",
        "BriefIntro": "不知道从什么时候开始，争论一篇文章是不是应该上首页成为博客园的一种流行。无论从任何角度出发，一旦谈起“文章质量”必然会有朋友会牵扯到“首页”（见《和谐社区，和谐技术》），然后动辄又抡起一句“你没有资格评论文章能不能上首页”。关于一些吵架的方式，逻辑方面的问题，有机会老赵再慢慢讨论，现在先来谈谈“首页”方面的问题，让老赵也掺和一下。 "
    },
    {
        "Title": "谈表达式树的缓存（5）：引入散列值",
        "Link": "/2009/03/expression-cache-5-hash-based-cache.html",
        "BriefIntro": "到目前为止，我们已经实现了三种缓存方式：首先我们设法构建唯一字符串，但是由于它的代价较高，于是我们使用了前缀树进行存储；又由于前缀树在实际操作中所花的时间和空间都有不令人满意之处，我们又引入了二叉搜索树。那么二叉搜索树又有什么缺点呢？ "
    },
    {
        "Title": "谈表达式树的缓存（4）：使用二叉搜索树（AVL树）",
        "Link": "/2009/03/expression-cache-4-binary-search-tree-cache.html",
        "BriefIntro": "上一篇文章中谈到的前缀树实现方式，时间复杂度从理论上来讲已经达到了最优，而空间复杂度理论上也可以做到较优。但是理论和实际是有差别的，而对于上文前缀树的实现来说，这两方面并不是非常理想。因此，虽然事实上前缀树是老赵第一个真正实现的缓存方法，但是对此并不满意，也想着有什么办法可以进行优化。不如尝试一下使用二叉搜索树？ "
    },
    {
        "Title": "谈表达式树的缓存（3）：使用前缀树",
        "Link": "/2009/03/expression-cache-3-prefix-tree-cache.html",
        "BriefIntro": "在上一篇文章里我们设法将前缀树构造为一个唯一的字符串，然后使用字符串作为key缓存在字典中。这个想法非常直接，做法也不困难（在遍历时记录详细信息便可）。不过事实上，老赵在思考表达式树的缓存问题时，这种字符串拼接的方式只存在于脑海当中，而上文的实现是为了这一系列文章的完整性而特地编写的。这是因为它的缺点较为明显，正如上文所述，字符串拼接操作较为耗时耗资源，且很容易生成一个长度可观的字符串（并非不能优化，不过实现就复杂了）。于是我们现在设法选择另一个解决方案来处理这个问题。 "
    },
    {
        "Title": "谈表达式树的缓存（2）：由表达式树生成字符串",
        "Link": "/2009/03/expression-cache-2-simple-key-cache.html",
        "BriefIntro": "谈到使用表达式树作为key进行缓存，您脑海中最早浮现出来的解决方案是什么？老赵看来，大部分朋友的第一反应自然就是将作为key的表达式树，使用一定规则生成一个字符串。那么我们就先使用这个办法来解决问题。 "
    },
    {
        "Title": "谈表达式树的缓存（1）：引言",
        "Link": "/2009/03/expression-cache-1.html",
        "BriefIntro": "表达式树（Expression Tree）是.NET 3.5中引入的一种表达方式。表达式树的运用十分广泛，可以直观地表现出各种“数据”，甚至“逻辑”和“行为”。老赵现在希望可以找到一种较为通用的，能够根据表达式树进行缓存的解决方案。在这一系列文章中，老赵希望可以重现自己在思考这个问题的时候所形成的完整思考路径。相比最终解决方案，这可能才是更有价值的东西。至少我觉得讨论一下这个问题也是非常有意思的事情。而且从一定程度上说，这些思考能够在一定程度上体现出算法设计与数据结构的美妙之处。 "
    },
    {
        "Title": "警惕匿名方法造成的变量共享",
        "Link": "/2009/03/anonymous-method-false-sharing.html",
        "BriefIntro": "匿名方法是强大的，但是也会造成一些令人难以察觉的陷阱。 "
    },
    {
        "Title": "一个简单的性能计数器：CodeTimer",
        "Link": "/2009/03/codetimer.html",
        "BriefIntro": "有数据，有真相，相信大家在平时的工作或学习过程中，都需要比较几种不同方法或实现之间的性能差距。在这些时候，往往就需要我们不断地创建Stopwatch，打开，关闭，然后打印时间。这种一遍又一遍的重复终有一天会让人忍无可忍，因此如果能有一个“标准”的性能计数器，那应该可以让生活轻松许多。这个性能计数器不用复杂，够用就好；也不需要考虑扩展性，要扩展时直接修改代码就够了；同样不需要考虑输出格式，直接打印在Console就行。 "
    },
    {
        "Title": "尽可能摆脱对HttpContext的依赖",
        "Link": "/2009/03/no-dependency-to-httpcontext.html",
        "BriefIntro": "我们继续《ASP.NET MVC单元测试最佳实践》，今天主要谈论HttpContext的依赖问题。简单说来：虽然已经可以对HttpContext进行Mock（这点增强了可测试性），但是过度依赖HttpContext对于单元测试来说也是一个伤害。这是HttpContext对象的天性所致：它实在太复杂了。因此，我们的代码要尽可能减少对HttpContext的依赖。 "
    },
    {
        "Title": "请别埋没了URL Routing",
        "Link": "/2009/03/fully-leverage-url-routing.html",
        "BriefIntro": "我们现在把数据转化的工作交给URL Routing，它的职责原本就是从URL中提取数据――任意类型的数据，以及把数据转化为URL，我们现在只是充分利用了URL Routing的功能而已。事实上，我建议任何使用URL表示的数据，都把转化的职责转移到URL Routing这一层，因为这是我们基本上无可避免地需要根据数据来生成URL。那么Model Binder难道就没有用了吗？当然不是。URL Routing负责从URL中提取数据，而Model Binder则用于从其他方面来获取参数。打开视野，发挥程序员的敏捷思路，生活就会变得更加美好。 "
    },
    {
        "Title": "老赵减肥记：减肥？跟玩儿似的。",
        "Link": "/2009/03/lose-weight.html",
        "BriefIntro": "老赵成功减肥，各中冷暖自知，与大家共勉。有志者事竟成，不是骗小孩的。 "
    },
    {
        "Title": "所有程序员都应该至少读上两遍的十篇论文",
        "Link": "/2009/03/1401259.html",
        "BriefIntro": "转载自刘江老师的博文《所有程序员都应该至少读上两遍的十篇论文》。关于读论文的重要性我不多作解释，事实上我也解释不清，但是可以确定的是，论文让我感受到技术之美，是一件很惬意的事情。当然，我们不一定要读“前沿”的内容，但是一些经典的论文是不能错过的。 "
    },
    {
        "Title": "Model Binder机制的缺陷",
        "Link": "/2009/03/limitation-of-model-binder.html",
        "BriefIntro": "Model Binder提供了一种机制，将请求中的数据转化成Action方法的参数。但是它是唯一的做法吗？它真是合适的做法吗？本文提出了Model Binder机制的一个缺陷，并且在下一篇文章中提出解决方案。 "
    },
    {
        "Title": "尽可能地使用强类型数据",
        "Link": "/2009/02/mvc-use-strong-type-everywhere.html",
        "BriefIntro": "我们继续来谈《最佳实践》，这次的主题便是“强类型”。强类型的好处有很多，张嘴便可随意举上几例：能够享受代码提示功能、能够获得重构工具的支持、能够在编译期发现更多错误…… "
    },
    {
        "Title": "对ASP.NET MVC项目中的视图做单元测试",
        "Link": "/2009/02/unit-test-views.html",
        "BriefIntro": "说到ASP.NET MVC，我们似乎始终都在关注对于Controller的测试，那么我们该如何对视图进行独立的单元测试呢？ "
    },
    {
        "Title": "简化异步操作（下）：构建AsyncTaskDispatcher简化多个异步操作之间的协作调用",
        "Link": "/2009/02/simplify-async-programming-2-asynctaskdispatcher.html",
        "BriefIntro": "由于CCR和AsyncEnumerator难以“并行”地执行异步代码，因此我们需要提出新的解决方案来满足这方面的需求。本文将构建一个AsyncTaskDispatcher组件，使多个异步操作之间的协作调用得以大大简化。 "
    },
    {
        "Title": "ASP.NET MVC单元测试最佳实践",
        "Link": "/2009/02/mvc-unit-test-best-practices.html",
        "BriefIntro": "我对于微软的一个特点时常呈一种否定态度，那就是因为它往往为了“显摆”自己的技术而向外界展现出一种“飘渺的美好”愿景。例如WebForm推出时铺天盖地的“拖拽”风潮，看似精彩却迷人双眼。这是我在上周“.NET技术大会”上的主题Session。先提供这次Session内容的PPT和演示吧，在接下来的一段时间内，我会陆续分析这次课程的内容。希望大家能够尽可能地把东西给“用好”，而不仅仅是得到表面上的正确结果。 "
    },
    {
        "Title": "简化异步操作（上）：使用CCR和AsyncEnumerator简化异步操作",
        "Link": "/2009/02/simplify-async-programming-1.html",
        "BriefIntro": "在以前的文章中，我曾多次强调应用程序中异步化的重要性。尤其对于IO密集型操作来说，异步执行对于应用程序的响应能力和伸缩性有非常关键的影响。正确使用异步编程能够使用尽可能少的线程来执行大量的IO密集型操作。可惜的是，即使异步编程有避免线程阻塞等诸多好处，但是这种编程方式至今没有被大量采用。其原因有很多，其中最主要的一点可能就是异步模型在编程上较为困难，导致许多开发人员不愿意去做。因此，无论是微软官方还是社区中都出现了一些简化异步编程方式的组件，例如微软的CCR和Wintellect's .NET Power Threading Library中的AsyncEnumerator。但是它们都有同样的局限性，例如操作之间存在依赖，则很难让它们并行执行。对于这样的场景，我们还需要构建额外的解决方案，使多个有依赖关系的异步操作之间的协作调用得以尽可能的简化。 "
    },
    {
        "Title": "QCon北京大会，3月15日前购票享受7.5折优惠",
        "Link": "/2009/02/1393836.html",
        "BriefIntro": "如果有朋友个人或团体需要的话可以联系我。距离QCon全球企业开发大会北京站（4月7~9日）还有2个月的时间，这次的会议包括6大主题和30多位知名讲师，为你提供一场丰富的培训和绝佳的学习机会。现在报名即可享受7.5折优惠，节省700元。 QCon大会的目标是为企业软件开发领域提供技术架构、团队领导和项目管理等深入技术内容的会议。这也意味着会议的内容并不局限在商业和流行技术上，同时它会提供最佳实践和相... "
    },
    {
        "Title": "程序员兄弟们，我们的基本素质怎么样？",
        "Link": "/2009/02/1392664.html",
        "BriefIntro": "我之前没有好好想过一个人的基本素质究竟应该是什么，只能在接触中觉得某个人“这里做的不错”或者“那里有所欠缺”。但是现在我仔细想了想，可能我们都需要扪心自问一下，我们需要具备哪些基本素质――是“人”的基本素质，可能具备这些基本素质之后，成为一个优秀的程序员只是时间问题吧。很不中听，兄弟们姑妄听之吧。 "
    },
    {
        "Title": "老赵很喜欢博士后和小工的故事，于是就编下去了",
        "Link": "/2009/02/1390923.html",
        "BriefIntro": "嗯嗯，朋友们大都很喜欢小工，简单就是美嘛，成本多省，联合利华多笨。不过这个估计应该是编（理由可见各评论）出来的，那么老赵也继续编下去…… "
    },
    {
        "Title": "为ASP.NET MVC扩展异步Action功能（下）",
        "Link": "/2009/02/extend-asp-net-mvc-for-asynchronous-action-2.html",
        "BriefIntro": "续上篇：异步请求处理是ASP.NET 2.0中引入的高级特性，它依托IO Complete Port，对于提高IO密集型应用程序的吞吐量非常重要（详见原理描述和性能测试）。但是目前ASP.NET MVC框架缺少异步Action功能，这也就是老赵经常挂在嘴边的那个“目前ASP.NET MVC所缺少的非常重要的功能”。我在春节休假期间仔细思考了一下这方面的问题，得出了一个相对不错的扩展：完整，方便，并且非常轻巧――核心逻辑代码只有200行左右，这意味着绝大部分功能将会委托给框架中现成的内容，确保了扩展的稳定，高效并且拥有较好的向后兼容性。 "
    },
    {
        "Title": "为ASP.NET MVC扩展异步Action功能（上）",
        "Link": "/2009/02/extend-asp-net-mvc-for-asynchronous-action.html",
        "BriefIntro": "异步请求处理是ASP.NET 2.0中引入的高级特性，它依托IO Complete Port，对于提高IO密集型应用程序的吞吐量非常重要（详见原理描述和性能测试）。但是目前ASP.NET MVC框架缺少异步Action功能，这也就是老赵经常挂在嘴边的那个“目前ASP.NET MVC所缺少的非常重要的功能”。我在春节休假期间仔细思考了一下这方面的问题，得出了一个相对不错的扩展：完整，方便，并且非常轻巧――核心逻辑代码只有200行左右，这意味着绝大部分功能将会委托给框架中现成的内容，确保了扩展的稳定，高效并且拥有较好的向后兼容性。 "
    },
    {
        "Title": "从CSDN的趣味题学C# 3.0",
        "Link": "/2009/02/1381867.html",
        "BriefIntro": "引文参见：从CSDN的趣味题学Python。引文用了Python来解这种趣味题，很有意思，Python也很适合。不过我看了看似乎这篇文章没有真正理解如今的C#可以怎么用，老赵一时兴起，也来设法做了一下。 "
    },
    {
        "Title": "Fast Reflection Library",
        "Link": "/2009/02/fast-reflection-library.html",
        "BriefIntro": "这是我在CodePlex上创建的一个项目，它的网址是http://www.codeplex.com/FastReflectionLib，使用Microsoft Public License (Ms-PL)，您可以随意在自己的产品中使用它的全部或部分代码。这个项目用到了我在《方法的直接调用，反射调用与Lambda表达式调用》和《这下没理由嫌Eval的性能差了吧？》两篇文章里用到的做法，并加以提炼和扩展发布的项目――随便搞搞，留个印记，也供以后参考。 "
    },
    {
        "Title": "媒体的春秋笔法",
        "Link": "/2009/01/1380542.html",
        "BriefIntro": "刚才看了博客园的新闻，发现了一点非常有趣的东西。两篇新闻分别描述分析了微软和谷歌两个公司去年第四季度的财报。老赵仔细对比了两者的内容，稍微做了一点归纳： 微软：季营收166.3亿美元，同比增长2%；净利润41.7亿美元，同比下滑11%。 谷歌：季营收57亿美元，同比增长18%，远不及以往50%的增长率；净利润为3.82亿，净利润同比下降。 从这些数字上看，谁的“效益”比较好？我是看不出来，评价为... "
    },
    {
        "Title": "计算机体系结构与程序性能",
        "Link": "/2009/01/system-architecture-and-program-performance.html",
        "BriefIntro": "老赵现在不谈“数据结构与算法如何有助于改善编程思维有什么改善”，或是“操作系统中线程调度、内存分页机制对于开发大型应用程序的参考价值”等“虚无缥缈”之物。在这篇文章里，我想通过两个直接的例子，来说明了解计算机体系结构对于提高程序性能有什么样的作用。 "
    },
    {
        "Title": "Lab：体会ASP.NET异步处理请求的效果",
        "Link": "/2009/01/lab-async-request.html",
        "BriefIntro": "关注老赵的朋友们一定记得，我不止一次强调过在ASP.NET应用程序中使用异步方式处理请求对于提高吞吐量的作用。不过似乎很多朋友们一直没有理解这样做的原因，亦或是对这样做的效果没有一个实际的“体会”，甚至在质疑这么做的功效。现在老赵将向大家进行一个演示，我们一起来看一下这么做的实际效果如何。 "
    },
    {
        "Title": "这下没理由嫌Eval的性能差了吧？",
        "Link": "/2009/01/dynamicpropertyaccessor-and-fasteval.html",
        "BriefIntro": "写ASP.NET中使用Eval是再常见不过的手段了，好像任何一本ASP.NET书里都会描述如何把一个DataTable绑定到一个控件里去，并且通过Eval来取值的用法。什么，您觉得Eval性能差不堪大用？那么就来看看这篇文章吧。（Updated：提供思考题解答） "
    },
    {
        "Title": "对aspx等页面进行预编译以进行编译期检查",
        "Link": "/2009/01/compile-aspx-file.html",
        "BriefIntro": "话说在开发Web应用程序时能够很轻易地对后台代码进行编译，并获得编译时的错误。可惜有时候我们对后台代码进行重构或Find all references的时候都会忽略aspx，ascx和master等文件里的代码，因为它们只有在打开时（执行期）才能发现错误。这是一个非常惹人厌的问题，但是事实上，我们只需要对一个asp.net目录下的文件进行预编译即可发现哪里出现问题。在项目中我经常会准备一个bat脚... "
    },
    {
        "Title": "一个利用扩展方法的实例：AttachDataExtensions",
        "Link": "/2009/01/attachdataextensions.html",
        "BriefIntro": "扩展方法是C# 3.0（老赵对VB不熟）中最简单，也是最常用的语言特性之一。这是老赵自以为的一个简单却不失经典的实例。 "
    },
    {
        "Title": "一个较完整的关键字过滤解决方案（下）",
        "Link": "/2009/01/filter-forbidden-word-solution-3.html",
        "BriefIntro": "陷阱何在？适用场合是什么？如何控制输入过滤和输出过滤？我们真的需要HttpModule吗？性能如何？在这篇文章里，我们来针对一些问题进行讨论。如果您觉得有哪些您感兴趣但是没有涉及到的问题则请在评论中补充，我会修改文章添加一下内容。 "
    },
    {
        "Title": "一个较完整的关键字过滤解决方案（中）",
        "Link": "/2008/12/filter-forbidden-word-solution-2.html",
        "BriefIntro": "上篇文章提出的问题解决了没有？哦哦，我是指采取命名约定的方式来改变过滤行为。当然有问题，不过我这里提一下比较重要的两个：1. 首先，就是“改名”这种行为――究竟是否方便？2. 再者，命名真是我们可以控制的吗？路漫漫而修远兮…… "
    },
    {
        "Title": "一个较完整的关键字过滤解决方案（上）",
        "Link": "/2008/12/filter-forbidden-word-solution.html",
        "BriefIntro": "关键字过滤功能自然无比重要，但是如果要在代码中对每个输入进行检查和替换则会是一件非常费神费事的事情。尤其是如果网站已经有了一定规模，用户输入功能已经遍及各处，而急需对所有输入进行关键字过滤时，上述做法更可谓“远水解不了近渴”。这时候，如果有一个通用的办法，呼得一下为整站的输入加上了一道屏障，那该是一件多么惬意的事情。这就是本文希望解决的问题。是不是很简单？我一开始也这么认为，不过事实上并非那么一帆风顺，而且在某些特定条件下似乎更是没有太好的解决方法…… "
    },
    {
        "Title": "和谐社区，和谐技术：微软的宠儿们，为什么富人的孩子就不能早当家？",
        "Link": "/2008/12/i-cannot-bear-any-more.html",
        "BriefIntro": "我爱微软。从刚接触计算机开始我就是沉浸在微软的技术中，DOS下开发，VB5/6，Delphi直到现在的.NET，微软让我的技术生涯充满了乐趣。我爱博客园。我是从博客园成长起来的，博客园给了我多于真实能力虚名，让我突然就变成了“赵老师”，“XXX专家”。博客园给了我很多机会，让我的工作路途变得更为通畅。但是，现在却很有唱衰的欲望。 "
    },
    {
        "Title": "方法的直接调用，反射调用与……Lambda表达式调用",
        "Link": "/2008/11/invoke-method-by-lambda-expression.html",
        "BriefIntro": "想调用一个方法很容易，直接代码调用就行，这人人都会。其次呢，还可以使用反射。不过通过反射调用的性能会远远低于直接调用――至少从绝对时间上来看的确是这样。因此，很多框架在必须利用到反射的场景中，都会设法使用一些较高级的替代方案来改善性能。例如，使用CodeDom生成代码并动态编译，或者使用Emit来直接编写IL。不过自从.NET 3.5发布了Expression相关的新特性，我们在以上的情况下又有了更方便并直观的解决方案。 "
    },
    {
        "Title": "在Web应用程序开发过程中利用ASP.NET MVC框架的实战技巧",
        "Link": "/2008/11/teched-2008-cs276.html",
        "BriefIntro": "这是我在TechED 2008北京站讲的一个Community Session，主要内容是在传统的ASP.NET（Web Forms）应用程序中运用ASP.NET MVC中一些优秀特性的方式。这里是PPT和Demo下载，以后我再慢慢细说。 "
    },
    {
        "Title": "概念，依旧是概念……csproj文件是做什么用的？",
        "Link": "/2008/08/the-csproj-file.html",
        "BriefIntro": "本来今天是在写一篇关于LINQ的文章，不过写着写着忽然觉得有些找不着北的感觉，似乎有点过于发散了？于是来博客园逛了一下，正好发现有朋友发了一篇文章《.NET面试题，看看你的水平》，于是就在这篇文章里和目前正红火的小包子同学为某个问题进行了一番争论。而在吵吵闹闹的过程中看到这么一句话“pdb文件需要放在Debug目录下才有效果”，忽然觉得有个话题值得一说：“开发环境与运行环境”。回想起平时被问到的问题，发现有不少朋友对于开发环境和运行环境并不是分的非常清楚。那么就让我们从标题中的问题开始：“csproj文件究竟是做什么用的”。 "
    },
    {
        "Title": "输出缓存与CachePanel",
        "Link": "/2008/07/cachepanel.html",
        "BriefIntro": "缓存的作用自不必说，提高系统性能最重要的手段之一。ASP.NET作为一个成熟、强大的应用程序框架，缓存相关的设计自然是它不可或缺的一部份。ASP.NET中的输出缓存即为所谓的“OutputCache”。不过我们有时候需要更灵活和强大的缓存方式，这就CachePanel诞生的原因。本文将分为以下三个部分：1、缓存的级别2、ASP.NET的Output Cache及其缺陷3、CachePanel的构建及使用 "
    },
    {
        "Title": "方案改进：直接通过User Control生成HTML",
        "Link": "/2008/07/user-control-rendering.html",
        "BriefIntro": "对于使用User Control生成HTML的方式，大家应该已经比较熟悉了，老赵也曾经写过一篇文章（《技巧：使用User Control做HTML生成》）来描述这个做法。在“我的衣橱”中大量使用了这种生成HTML的方法。不过当项目达到一定规模之后，这个方法的不足之处也慢慢地体现了出来。如果能解决这个问题，就无疑是一个锦上添花的举动…… "
    },
    {
        "Title": "觉得有必要来澄清几组重要概念",
        "Link": "/2008/06/ajax-linq-lambda-expression.html",
        "BriefIntro": "在阅读很多朋友问题的过程中，以及平时和别人讨论中，亦或是园子里的文章中经常发现一些误用概念的情况。如果在概念上没有形成共识，那么在工作和交流上就会造成许多问题。因此，老赵已觉得有必要特地来澄清一些概念，解释一下这些概念之间的区别和联系。希望在明确这些概念之后，大家能够把注意力集中在对于具体问题的分析解决上，而不要让沟通成为瓶颈。在这篇文章中，我希望澄清三组概念，它们是：AJAX / AJAX框架 / AJAX.NET (Professional) / ASP.NET AJAXLINQ / LINQ to SQL / LINQ to XXXLambda Expression / Expression Tree / 匿名方法 "
    },
    {
        "Title": "我们到底该怎么做精华集",
        "Link": "/2008/05/1204424.html",
        "BriefIntro": "博客园要做精华集，老赵觉得很有意思。老赵被分配到的工作是ASP.NET AJAX和ASP.NET MVC。不过事实上老赵想搞得东西很多，还有ASP.NET、.NET 3.5也想参一腿等等。不过这篇文章想和大家讨论的并不是计划，因为有些东西老赵还没有确定，所以现在只是来谈谈一些想法。 "
    },
    {
        "Title": "更新：让UpdatePanel支持上传文件",
        "Link": "/2008/05/build-component-to-upload-file-in-updatepanel.html",
        "BriefIntro": "在一年多前我发布了一系列文章（让UpdatePanel支持文件上传（1）、（2）、（3）、（4）、（5）），设法让UpdatePanel支持上传文件。可惜缺陷无数，当时收到了无数bug report但是我都没有时间（和兴趣）去解决，因此只是一个实验品中的实验品。这个组件还有一个问题就在于非常复杂，复杂的原因是为了解决iframe传输数据的问题。当时想了很多办法最终让IE6、7，FireFox 1.5支持了这个组件，但是对于Safari，Opera等浏览器就无能为力了。最近发现jQuery的Form插件能够在一定程度上支持我需要的功能，于是就有了简化并改进该控件的想法。虽然后来发现jQuery在这方面的表现并不如我想象中那么好…… "
    },
    {
        "Title": "不妨来做个尝试：UpdatePanel for ASP.NET MVC",
        "Link": "/2008/04/try-to-build-an-updatepanel-for-asp-dot-net-mvc.html",
        "BriefIntro": "前一段时间尝试为ASP.NET MVC构建了一个类似于UpdatePanel的AJAX解决方案，本文叙述了这个组件的设计思路以及使用方式，并提供了源代码以及示例程序。 "
    },
    {
        "Title": "您善于使用匿名函数吗？",
        "Link": "/2008/04/can-you-use-anonymous-method-properly.html",
        "BriefIntro": "合理使用匿名方法能够大大简化开发，提高代码质量。您善于使用匿名方法吗？ "
    },
    {
        "Title": "推荐一篇文章：火星人的耳机",
        "Link": "/2008/03/martian-headsets.html",
        "BriefIntro": "大名鼎鼎的Joel Spolsky最近写了一篇很有趣的文章《Martian Headsets》。写这篇文章的起因是IE8的推出，这让Joel忽然有兴趣从各个角度讨论Web标准之争的各个方面，比如缘由，现状，以及用户的反应等等。非常值得一看。原文链接：http://www.joelonsoftware.com/items/2008/03/17.html翻译链接：http://luoshengblog... "
    },
    {
        "Title": "扩展LINQ to SQL：使用Lambda Expression批量删除数据",
        "Link": "/2008/03/linq-to-sql-batch-delete-extension.html",
        "BriefIntro": "ORM框架在删除数据方面一直有个尴尬，那就是无法通过指定条件批量删除数据。于是对于一些删除操作，我们不得不写SQL语句或者执行存储过程。幸运的是C# 3.0所拥有的强大特性足以让我们对LINQ to SQL的功能进行扩展。为了更好地进行项目开发，以及周五的一次技术交流，我为LINQ to SQL扩展了批量删除功能。 "
    },
    {
        "Title": "LINQ to SQL异步查询",
        "Link": "/2008/03/async-query-with-linq-to-sql.html",
        "BriefIntro": "异步操作是提高Web应用程序吞吐量的重要手段，关于这方面的话题已经在前文《正确使用异步操作》中解释过了。对于大多数互联网应用来说，性能瓶颈数据库访问。换句话说，一个请求在数据库操作上所花的时间往往是最多的――并且占总时间的90%以上。因此，当Web应用程序的吞吐量因为数据库操作的阻塞而受到影响的话，我们可是尝试使用异步数据库操作来进行优化。那么我们又该如何使用LINQ to SQL进行异步查询呢？ "
    },
    {
        "Title": "正确使用异步操作",
        "Link": "/2008/02/use-async-operation-properly.html",
        "BriefIntro": "本想写一点有关LINQ to SQL异步调用的话题，但是在这之前我想还是先写一篇文章来阐述一下使用异步操作的一些原则，避免有些朋友误用导致程序性能反而降低。这篇文章会讨论一下在.NET中有关异步操作话题，从理论出发结合实际，以澄清概念及避免误用为目标，并且最后提出常见的异步操作场景和使用案例。这样我们就可以知道什么时候该使用异步操作，什么时候会得不偿失。 "
    },
    {
        "Title": "在LINQ to SQL中使用Translate方法以及修改查询用SQL",
        "Link": "/2008/02/using-translate-method-and-modify-command-text-before-query-in-linq-to-sql.html",
        "BriefIntro": "目前LINQ to SQL的资料不多――老赵的意思是，目前能找到的资料都难以摆脱“官方用法”的“阴影”。LINQ to SQL最权威的资料自然是MSDN，但是MSDN中的文档说明和实例总是显得“大开大阖”，依旧有清晰的“官方”烙印――这简直是一定的。不过从按照过往的经验，在某些时候如果不按照微软划定的道道来走，可能就会发现别样的风景。老赵在最近的项目中使用了LINQ to SQL作为数据层的基础，在LINQ to SQL开发方面积累了一定经验，也总结出了一些官方文档上并未提及的有用做法，特此和大家分享。 "
    },
    {
        "Title": "MIX 2008与ASP.NET MVC框架的Road-Map",
        "Link": "/2008/02/mix08-asp-net-mvc-framework-road-map-update.html",
        "BriefIntro": "ScottGu同学最近在Blog上发布了一些有关MIX 2008和ASP.NET MVC框架的消息。 "
    },
    {
        "Title": "随便说说：在ASP.NET应用程序中上传文件",
        "Link": "/2008/02/aspnet-upload.html",
        "BriefIntro": "在Web程序中上传文件是很常见的需求，最近忽然想到了点这方面的内容，就随便谈谈吧，希望对大家有帮助。 "
    },
    {
        "Title": "重提URL Rewrite（4）：不同级别URL Rewrite的一些细节与特点",
        "Link": "/2008/01/url-rewrite-4.html",
        "BriefIntro": "在之前的文章里我们已经谈论了有关URL Rewrite的几个主要的方面。在本系列的最后一篇文章中，我们就来讨论一下有关不同级别URL Rewrite的一些细节与特点。 "
    },
    {
        "Title": "重提URL Rewrite（3）：在URL Rewrite后保持PostBack地址",
        "Link": "/2008/01/url-rewrite-3.html",
        "BriefIntro": "在进行了URL Rewrite之后，经常会遇到的问题就是页面中PostBack的目标地址并非客户端请求的地址，而是URL Rewrite之后的地址，这就将我们服务器端的URL映射规则暴露给了客户端，甚至会引起应用程序错误。这无疑不是我们所希望的，那么我们该如何避免这个情况发生呢？本文就不同层面的URL Rewrite方式分别讨论了这个问题。 "
    },
    {
        "Title": "重提URL Rewrite（2）：使用已有组件进行URL Rewrite",
        "Link": "/2008/01/url-rewrite-2.html",
        "BriefIntro": "可能已经没有人会使用上一篇文章中的方法进行URL Rewrite了，因为提供URL Rewrite的组件早已铺天盖地了。如果要我推荐，我指挥推荐两款组件，那就是Intelligencia的开源组件UrlRewriter.NET和IIRF，它们分别在ASP.NET层面和IIS层面上进行URL重写。 "
    },
    {
        "Title": "重提URL Rewrite（1）：IIS与ASP.NET",
        "Link": "/2008/01/url-rewrite-1.html",
        "BriefIntro": "之前觉得这个话题已经被谈滥了。URL Rewrite早已经被广大开发人员所接受，网上关于URL Rewrite的组件和文章也层出不穷，但是总是让我感觉意犹未尽，于是最终还是忍不住提笔写了这系列文章。这些文章不会谈论URL Rewrite的价值与意义，而只会谈论纯技术的内容。文章中也不会有详尽地实现分析，而是结合了我的经验，从应用角度来讲解这个话题。您已经知道的，您还不知道的，别处已经讲过的，或者还没有讲过的，希望这系列文章的“旧事重提”不会让您觉得沉闷，并且能让您了解ASP.NET中URL Rewrite的方方面面。如果您以后再遇到URL Rewrite方面的问题是能够想到这几篇文章，估计我做梦也会笑出声来。 "
    },
    {
        "Title": "技巧：使用User Control做HTML生成",
        "Link": "/2007/12/usercontrol-as-an-template.html",
        "BriefIntro": "User Control大家肯定不会陌生，在使用ASP.NET的过程中，除了aspx页面，最常见的就莫过于ascx了。ascx是一个有独立逻辑的组件，提供了强大的复用特性，合理使用，能够大大提高开发效率。通过User Control直接生成HTML内容其实已经是一个比较常用的技巧了（尤其在AJAX时代），不过网络上这方面的内容比较少，很多人还是在苦苦地拼接字符串，因此在这里我通过一个实例简单介绍一下这个技巧。 "
    },
    {
        "Title": "为WebForms说几句话，以及一些ASP.NET开发上的经验（3）",
        "Link": "/2007/12/experience-for-asp-dot-net-and-webforms-3.html",
        "BriefIntro": "有人说，客户端ID污染问题使脚本代码很难做到“内聚”。可能他的意思是将脚本代码提取到js文件中吧。但是我认为，这种污染“迫使”我们必须使用内聚性高的方式进行客户端开发。这也算是一种因祸得福吧。 "
    },
    {
        "Title": "为WebForms说几句话，以及一些ASP.NET开发上的经验（2）",
        "Link": "/2007/12/experience-for-asp-dot-net-and-webforms-2.html",
        "BriefIntro": "在ASP.NET的WebForms刚出现时，各种“演示”看上去真的很美。这个特点微软至今还保留着，各微软技术大会上的演示真的让人感到心潮澎湃。在我看来，那些“激素大会”更是一种推广策略，而并没有将目光集中在技术细节的本身。所以微软的东西似乎总是有入门容易提高难的“毛病”。开发人员被“宠坏”了，上一篇文章中有位朋友说这就是“穷人的孩子早当家”，还是有一定道理的。在.NET环境下我们就像是官宦子弟，不过这并不能成为我们习惯于“吃喝嫖赌”的理由。我们要合理利用富裕的环境带给我们的资源，但是要适当地抛弃一些不好的东西。 "
    },
    {
        "Title": "为WebForms说几句话，以及一些ASP.NET开发上的经验（1）",
        "Link": "/2007/12/experience-for-asp-dot-net-and-webforms.html",
        "BriefIntro": "我还是想写这篇文章，我只会WebForms平反，而不会“贬低”MVC框架；我只是想证明WebForms的那些缺点到底真的是缺点，还是开发人员自身没有好好利用起这把利器。因此我将会根据我的经验，一一回应对WebForms比较常见的指责。如果措辞上有任何的不妥，也请大家多多包涵。 "
    },
    {
        "Title": "有些话不知道怎么说才好",
        "Link": "/2007/12/986062.html",
        "BriefIntro": "有些话不知道怎么说才好。在blog上，msn上，或者Email，老赵一直在回答大家提出的各种问题。虽然自知遗漏不少，但是相信其中的大部分我都是给与回复的――可能质量有高有低，投入有多有少，但是相信老赵每次回答都是负责任的。但是老赵目前发现的问题是，我被问到的大部分问题都非常简单，如果之前搜索过，那么相信都能够找到答案。某些初学者朋友对老赵特别关照，经常在msn上问我这个那个，但是总是希望能够直接得... "
    },
    {
        "Title": "在Linq to Sql中管理并发更新时的冲突（3）：使用记录的时间戳进行检测",
        "Link": "/2007/11/solving-concurrent-conflict-problem-in-linq-to-sql-3-using-timestamp.html",
        "BriefIntro": "在《在Linq to Sql中管理并发更新时的冲突（2）：引发更新冲突》一文中，我们描述了Linq to Sql检测在更新时是否产生了冲突的基本方法：将该记录每个字段原来的值和更新时的值进行对比，如果稍有不同则意味着记录被修改过，因此产生了更新冲突。不过您是否有这样的感觉，这种方法实在累赘了一些？因此Linq to Sql提供了另外一种检测并发更新冲突的方式：使用记录的时间戳。这并不是Linq to Sql特有的功能，如果您了解其他的ORM框架的话，就会发现诸如Hibernate也提供了类似的机制――自然，在使用上不会像Linq to Sql那样方便。 "
    },
    {
        "Title": "是否会成为问题――Linq to Sql的执行可能无法复用查询计划",
        "Link": "/2007/11/linq-to-sql-cannot-cache-compiled-plan.html",
        "BriefIntro": "复用查询计划是Sql Server降低CPU开销，提高性能的一个重要手段。但是Linq to Sql可能无法复用查询计划，这是怎么回事儿呢？ "
    },
    {
        "Title": "在Linq to Sql中管理并发更新时的冲突（2）：引发更新冲突",
        "Link": "/2007/11/solving-concurrent-conflict-problem-in-linq-to-sql-2.html",
        "BriefIntro": "在上一讲中，我们提到了一些诸如“乐观并发控制”、“悲观并发控制”的概念，以及察看Linq to Sql自动生成sql语句的方法。从这篇文章起我们将继续来查看Linq to Sql在管理并发更新时是如何发现冲突问题的。 "
    },
    {
        "Title": "在网页里添加Web Live Messenger对话框",
        "Link": "/2007/11/add-web-live-messenger-to-your-page.html",
        "BriefIntro": "为您的页面也添加一个Web Live Messenger吧！ "
    },
    {
        "Title": "编写兼容多浏览器的JavaScript代码――微软JScript团队JScript Deviations from ES3草案",
        "Link": "/2007/11/947511.html",
        "BriefIntro": "实话说，常见的JavaScript在不同浏览器的区别并非那么难以处理，只要有一定JavaScript开发经验就会大体知道该如何“回避”某些问题。不过这份文档还是仔细比对了ECMAScript 3标准以及JavaScript在IE、FireFox、Safari、Opera四款浏览器中的实现，希望能够对JavaScript开发人员有帮助――区别的确很大，之前还真的没有想到这些。http://blogs... "
    },
    {
        "Title": "在Linq to Sql中管理并发更新时的冲突（1）：预备知识",
        "Link": "/2007/10/solving-concurrent-conflict-problem-in-linq-to-sql.html",
        "BriefIntro": "无论与目前的ORM框架相比有没有优势，Linq to Sql在语言和平台的级别上为我们提供了一种新的操作对象和数据的方式，在一定程度上为我们解决了Object != Data的问题。在实际应用中，对于数据库的操作往往有着天生的并发性，因此在更新数据时可能会产生冲突。有些时候，如果没有合理的解决冲突问题，轻则让用户摸不着头脑，重则让系统数据处于一种不一致的状态。Linq to Sql自然考虑到了这一点，本系列讨论的内容，就是在使用Linq to Sql时，如何管理并发更新时产生的冲突。　　本文为这个系列的第一篇，将讨论一些预备知识，它们是进行后续研究的基础。 "
    },
    {
        "Title": "我们到底该怎么学技术？如何成为一个优秀的技术人员？",
        "Link": "/2007/10/how-to-learn.html",
        "BriefIntro": "看了不要迷失在技术的海洋中，深表同意。在后来的评论中大家也表达了自己的看法。让我觉得很有意思的是，大家的观点惊人地一致――几乎没有反对的声音。不过从经验上来看，意见太统一也不一定是一件好事。我有时也会小人之心地想，表示赞同的朋友们是真与LoveCherry的想法一致，还是仅仅因为自己以前对待技术随波逐流不堪所累，现在把这篇文章作为救命稻草看待，追求自身的心理平衡呢？LoveCherry写这篇文章，是基于他对于技术和思想的深度。如果我们没有达到这样的程度，是否会误解他的意思，得到的仅仅是一种心理安慰，却失去了更多东西呢？ "
    },
    {
        "Title": "客户端访问Web Service方法的一个细节",
        "Link": "/2007/07/something-about-calling-web-service-method.html",
        "BriefIntro": "之前遇到一个要求，需要能够取消一个正在进行中的Web Service。这也是我第一次遇到这个功能，不过不难，我想。既然ASP.NET AJAX的客户端与服务器端通信完全通过Microsoft AJAX Library的异步通信层进行，那么我们只要得到正在请求Web Service的Sys.Net.WebRequest对象，调用其abort方法就可以了。但是究竟应该如何得到这个对象呢？其中似乎还有这么一些问题…… "
    },
    {
        "Title": "toString方法无法被继承？",
        "Link": "/2007/07/why-cant-tostring-method-be-inherited.html",
        "BriefIntro": "在我看来，toString方法是一个类最重要的方法之一。在JavaScript中，将一个对象转化为字符串形式的默认方法就是调用其toString方法。因此，为类型实现一个合理的toString方法对于开发和调试都有一定的好处。在面向对象编程中，在父类中定义toString方法，以此为它的各个子类提供相似的字符串表现形式是常用的做法之一，但是如果您使用Microsoft AJAX Library的面向对象机制进行开发时就会遇到一个问题。那就是toString方法无法被继承。说的更明白一些，就是子类无法获得父类的toString方法的实现。除非在子类中直接定义一个toString方法，否则它只能含有JavaScript中默认的toString方法。很显然，这没有任何意义，也失去了面向对象的重要特性。这是为什么？又该如何解决呢？ "
    },
    {
        "Title": "意外得到了一个免费的HttpWatch Professional的License",
        "Link": "/2007/07/815964.html",
        "BriefIntro": "不久前在Code Project上写了一篇文章《Client-side caching for script methods access in ASP.NET AJAX》，提到了HttpWatch Basic Edition的使用。没想到今天HttpWatch开发公司的一个员工写了封邮件给我，说对于我在文章里提到HttpWatch表示感谢，并且如果愿意给我一个免费的HttpWatch Profe... "
    },
    {
        "Title": "Tip：在使用AjaxControlTookit的控件时响应事件",
        "Link": "/2007/07/attach-events-to-behaviors.html",
        "BriefIntro": "AjaxControlTookit中控件的关键在于客户端的Behavior对象，Behavior对象大都有丰富的属性，方法和事件。在目前的版本中，为某些Behavior添加Event Handler并非一件很容易的事情。相信今后的AjaxControlToolkit版本中将会为一些较早的Extender补充对于客户端事件的支持，让我们拭目以待吧，只是眼下我们还需要使用一些较为有技巧的方式来实现功能了。 "
    },
    {
        "Title": "使用ASP.NET AJAX访问Script Method时启用客户端缓存",
        "Link": "/2007/07/client-side-caching-for-script-method-access.html",
        "BriefIntro": "缓存是开发高性能和高可用性Web应用的重要手段之一。作为ASP.NET AJAX的关键功能，从客户端访问Script Method会被大量用于使用ASP.NET开发的AJAX应用。这个功能有一个内置的服务器端缓存机制，不过如果我们能在客户端进行缓存则会得到更好的效果。 "
    },
    {
        "Title": "ScriptPath属性的拙劣设计",
        "Link": "/2007/06/the-awkward-design-of-the-scriptpath-property.html",
        "BriefIntro": "您在为AjaxControlTookit开发Extender控件时使用ScriptPath属性吗？ScriptPath属性的拙劣设计几乎使它成为了ExtenderControlBase类中最没有用的属性了。 "
    },
    {
        "Title": "Scaling a Rails Application from the Bottom Up",
        "Link": "/2007/06/793756.html",
        "BriefIntro": "http://media.joyent.com/JHoffmanRailsConf-May2007.pdf 这是今年Rails大会上的一个报告。虽然讲的是RoR应用程序，但实际该报告里包括了许多其他方面要素的阐述，例如操作系统，硬件配置等等。对于要构造大型网络应用的人来说是一个不可不读的文档。 "
    },
    {
        "Title": "StyledAutoComplete - 支持丰富样式的自动补全",
        "Link": "/2007/06/styleautocomplete.html",
        "BriefIntro": "几个月前，我扩展了Atlas CTP时期的的AutoCompleteBehavior，到了ASP.NET AJAX正式版之后这个扩展自然就不能用了。其实这段时间内有不少朋友问我该如何做到像Google Suggest那样带丰富样式的自动补全功能，但是由于各种原因，我没有深入地研究它，更别提对它的扩展了。最近手头正好有些时间，也就逼迫自己耐着性子读了读AutoCompleteBehavior的代码，并作了这个扩展。 "
    },
    {
        "Title": "BlogEngine 1.0中的编码问题及解决方案",
        "Link": "/2007/06/blogengine-encoding-problem-in-source-code.html",
        "BriefIntro": "似乎有不少朋友在下在BlogEngine 1.0的源代码之后会发现居然无法正确编译，因为{SiteRoot}\\User Controls\\CommentView.cs里的代码遇到了错误。为什么引号没有封闭？作者怎么会把一个无法编译的版本发布出去呢？其实问题并非那么简单…… "
    },
    {
        "Title": "深入JavaScript与.NET Framework中的日期时间（3）：JavaScript中的Date类型（中）",
        "Link": "/2007/06/inside-date-and-time-in-javascript-and-dotnet-framework-3.html",
        "BriefIntro": "本文详细讲解了JavaScript中Date对象的以下几个方面： 浏览器默认格式字符串 解析时间日期字符串 系统设定时间日期字符串 如何在实际开发中使用客户端系统的格式 "
    },
    {
        "Title": "深入JavaScript与.NET Framework中的日期时间（2）：JavaScript中的Date类型（上）",
        "Link": "/2007/06/inside-date-and-time-in-javascript-and-dotnet-framework-2.html",
        "BriefIntro": "在JavaScript中处理时间使用的就是Date原生类型了，这也是在使用JavaScript进行开发时最常用的对象之一。本文讲述了关于JavaScript中Date类型的以下部分内容： 概念 Date函数 Date对象的构造 "
    },
    {
        "Title": "分清ASP.NET AJAX中的Extender和Behavior模型",
        "Link": "/2007/06/extender-model-and-behavior-model.html",
        "BriefIntro": "ASP.NET AJAX提出了多种模型，在客户端有Component、Control和Behavior模型，在服务器端有ScirptControl和Extender模型。这些模型各有各的用途，但是请注意非常重要的一点：客户端模型和服务器端模型是相互独立的。我们必须意识到以下三点，才能灵活地使用Extender和Behavior。 Extender模型和Behavior模型没有必然联系。 Behavior可以独立于Extender执行。 所有效果是由Behavior提供的。 "
    },
    {
        "Title": "深入JavaScript与.NET Framework中的日期时间（1）：基本概念与概述",
        "Link": "/2007/06/inside-date-and-time-in-javascript-and-dotnet-framework-1.html",
        "BriefIntro": "日期时间是开发过程中最尝使用的数据类型之一，但是很多开发人员在使用过程中忽视了时间日期的一些特性。现在的应用越来越讲究“国际化”和“本地化”，它们的重要特征之一就是一些数据类型的格式或换算，日期时间是其中之一（其余还有货币，数字等等）。在进一步讨论开发中的日期时间问题之前，我们需要先理清有关时间的一些基础概念。对于时间日期来说，最重要的可能就是“时差”问题，主流编程语言中表示日期时间对象都对于这个问题有着足够的支持，不过许多开发人员都会忽视这一点。这就是这片文章中最主要会谈论的问题。虽然大部分的应用可能都不涉及到“全球化”，但是我们还是有充分的理由来搞清楚时间方面的问题。 "
    },
    {
        "Title": "有关注册DataItem的一些可能被忽视的事情",
        "Link": "/2007/04/something-you-probably-missed-about-registering-data-items.html",
        "BriefIntro": "在UpdatePanel对页面进行部分刷新时注册一些Data Item是ASP.NET AJAX的特点之一。我们可以在服务器端为某个控件注册一个字符串甚至是一个对象，然后在客户端将将其取回。但是现在我希望向您展示一些您可能会忽视的事情。 "
    },
    {
        "Title": "让UpdatePanel支持文件上传（5）：支持页面重定向的HttpModule",
        "Link": "/2007/04/let-updatepanel-support-file-uploading-the-module-that-support-page-redirection.html",
        "BriefIntro": "在最后，我们还必须编写一个HttpModule来支持异步刷新时页面的重定向。 "
    },
    {
        "Title": "让UpdatePanel支持文件上传（4）：数据传输与解析机制",
        "Link": "/2007/04/let-updatepanel-support-file-uploading-the-mechanism-of-sending-and-parsing-data.html",
        "BriefIntro": "现在就要开始整个项目中最有技巧的部分了。如果我们的组件需要在多种浏览器中正常的运行，我们必须好好考虑一下发送和解析数据的方式。如果我们把这部分的机制完全交给ASP.NET AJAX原有的行为来执行，则会遇到问题。 "
    },
    {
        "Title": "当心异步刷新后的脚本文件加载",
        "Link": "/2007/04/be-careful-with-loading-script-files-after-an-async-postback.html",
        "BriefIntro": "如果第一次异步刷新在加载脚本时发起了另一个异步刷新，第二次异步刷新可能就会不受我们控制地被中断了。 "
    },
    {
        "Title": "让UpdatePanel支持文件上传（3）：客户端组件",
        "Link": "/2007/04/let-updatepanel-support-file-uploading-client-side-component.html",
        "BriefIntro": "我们的UpdatePanelIFrameExecutor继承了WebRequestExecutor，因此需要实现许多方法和属性。但是我们事实上不用完整地实现所有的成员，因为客户端的异步刷信机制只会访问其中的一部分。 "
    },
    {
        "Title": "让UpdatePanel支持文件上传（2）：服务器端组件",
        "Link": "/2007/04/let-updatepanel-support-file-uploading-server-side-component.html",
        "BriefIntro": "我们现在来关注服务器端的组件。目前的主要问题是，我们如何让页面（事实上是ScriptManager控件）认为它接收到的是一个异步的回送？ScriptManager控件会在HTTP请求的Header中查找特定的项，但是我们在向IFrame中POST数据时无法修改Header。所以我们必须使用一个方法来“欺骗”ScriptManager。 "
    },
    {
        "Title": "让UpdatePanel支持文件上传（1）：开始",
        "Link": "/2007/04/let-updatepanel-support-file-uploading-lets-get-started.html",
        "BriefIntro": "UpdatePanel从一开始就无法支持AJAX的文件上传方式。Eilon Lipton写了一篇文章解释了这个问题的原因。文章中提供了两个绕开此问题的方法。不过，我们为什么不使UpdatePanel兼容FileUpload控件（<input type=\"file\" />）呢？如果可以这样，一定能够受需要使用UpdatePanel上传文件的用户欢迎。 "
    },
    {
        "Title": "UpdatePanel的妙用：Incremental Content",
        "Link": "/2007/03/incremental-content.html",
        "BriefIntro": "Incremental Content是我随意取的名字，我有时候会希望，把一些常见的场景，总结出ASP.NET AJAX一些比较固定的使用模式。Incremental Content是我为现在这个“模式”取的名字。这个模式的作用，就是使用UpdatePanel来不断地在页面上增加内容。想到这个使用方式的原因，是因为在中午与Bing对UpdatePanel的一些问题进行了讨论。他谈到，使用UpdatePanel，会造成过多的数据传输上的浪费。例如博客园的回复，事实上要更新的只是新增的内容，而并不需要整个评论区进行刷新。这篇文章谈到的Incremental Content就是为了解决这类问题而产生的。建议dudu在合适的时候修改一下添加评论的代码。:) "
    },
    {
        "Title": "SwitchPartManager：在UpdatePanel中灵活地切换不同用户控件",
        "Link": "/2007/03/switchpartmanager.html",
        "BriefIntro": "这是一个很常见的使用场景，尤其是出现了UpdatePanel之后：页面中有一排菜单，点击菜单中的每一项，都会使某个UpdatePanel中出现不同的控制面板。在开发时，往往会将每个的控制面板写成不同的用户控件，点击菜单时事实上就是在UpdatePanel中放入不同的用户控件。如果要开发这样的功能，从理论上来说并不困难，但是如果要能够在控件之间灵活切换，甚至要从控件A的某个操作中切换到控件B，可能就需要增加控件之间的耦合度了。因此，如何控制这样的切换似乎需要细细考虑一下。 "
    },
    {
        "Title": "UpdatePanel终于可以上传文件了！",
        "Link": "/2007/03/ajaxuploadhelper-prototype.html",
        "BriefIntro": "UpdatePanel终于可以上传文件了！我们要做的，只是在页面上添加一个控件而已。 "
    },
    {
        "Title": "ModalUpdateProgress控件",
        "Link": "/2007/03/modalupdatepanel-control.html",
        "BriefIntro": "在之前的一篇文章中，我谈了如何在页面中“轻量级地”实现了模态的UpdateProgress。这次，我带来了一个“重量级”的实现：ModalUpdateProgress控件。 "
    },
    {
        "Title": "第17届Jolt Award终于出炉了",
        "Link": "/2007/03/jolt-2007.html",
        "BriefIntro": "第17届Jolt Award终于出炉了，再这之前，我们再来回顾一下候选选手们。 "
    },
    {
        "Title": "Tip：Modal UpdateProgress的轻量级解决方案",
        "Link": "/2007/03/lightweight-modalupdateprogress-solution.html",
        "BriefIntro": "又被问了这样一个问题：UpdateProgress如何像ModalPopupExtender那样的效果呢？类似的问题有：如何在UpdatePanel里使用ModalPopupExtender呢？我这次仔细想了想，感觉问题并不那么简单。 "
    },
    {
        "Title": "Tip：自定义UpdatePanelTrigger",
        "Link": "/2007/03/customize-updatepanel-trigger.html",
        "BriefIntro": "如果需要的话，您不妨在开发过程中自定义一个UpdatePanel触发器吧。 "
    },
    {
        "Title": "MSDN Webcast“深入浅出ASP.NET AJAX系列”预告及反馈",
        "Link": "/2007/03/asp-net-ajax-msdn-webcast-feedback.html",
        "BriefIntro": "我为MSDN Webcast准备了一个《深入浅出ASP.NET AJAX系列》，共有十多次课程，希望能够为大家系统的讲解一下如何使用ASP.NET AJAX框架进行开发。在这个系列中，我会尽可能的从“使用”入手，然后对于ASP.NET AJAX框架进行一定程度的深入讲解，使大家能够更自由地使用ASP.NET AJAX框架，并且能够自己着手解决一些使用中的问题。简单地说，这个系列中最着重的就是尽可能的“授人以渔”。希望大家对我的这个系列多提意见和建议，并回复在这篇文章中，我需要您的反馈来改进我的表现。 "
    },
    {
        "Title": "Tip：“Form_Load时添加的AsyncPostBackTrigger失效”问题分析及解决方案",
        "Link": "/2007/03/dynamic-trigger-problem.html",
        "BriefIntro": "最近时间很少，而且总觉得没有什么题材可写。今天无意中看到了Aldebaran's Home提出的一个疑问，为什么在Form_Load方法中动态添加的AsyncPostBackTrigger会在经过一次异步刷新后就失效，导致第二次提交变成了普通的提交。我尝试了一下，果不其然。对ASP.NET AJAX程序集源码的分析之后，我得出了问题原因和解决方案，在这里和大家共享一下。 "
    },
    {
        "Title": "谈我的“先做人，再做技术人员，最后做程序员”",
        "Link": "/2007/02/657307.html",
        "BriefIntro": "谭老大的一片文章中谈到了我的这句话，不过他认为，做人的难度实在比做程序员高很多。其实我说的这句话，原出自傅雷先生至傅聪《家书》中云：“先做艺术家，再作音乐家，最后才是钢琴家”。历来有大成就的艺术家，其高风亮节也为人所称颂，其传世之作也正所谓“书如其人”。我使用把“程序员”作为一种真正的职业来看待，一个只受过半年一年培训的人，在我看来根本不能称之为程序员，我对于这种泛滥的程序员状态深恶痛绝……真正的... "
    },
    {
        "Title": "Sys.StringBuilder里的Bug",
        "Link": "/2007/02/bug-of-sys-stringbuilder.html",
        "BriefIntro": "Sys.StringBuilder出现了这样的Bug，他们一定没有做好Code Review。 "
    },
    {
        "Title": "鸡肋烹制出的美味――真正可调试的ASP.NET AJAX",
        "Link": "/2007/02/asp-net-ajax-debugging-project.html",
        "BriefIntro": "ASP.NET AJAX的源代码的确发布了，并且提供了pdb文件，也就是说，我们现在可以用它来调试了。不知道各位朋友们有没有真的用它跟踪到代码中去，至少我用下来之后非常的不满意。官方给出了源代码，我们为什么不设法把它恢复成C#工程呢？于是我新建了一个C# Class Library，把源代码复制到工程中去。然后通过比较编译错误、运行错误以及使用.NET Reflector查看ASP.NET AJAX程序集，一点点补充丢失的资源和代码，费了九牛二虎之力总算比较完美地恢复了ASP.NET AJAX的程序集。 "
    },
    {
        "Title": "挣脱浏览器的束缚（7） - CrossSubDomainExecutor",
        "Link": "/2007/02/break-the-browsers-restrictions-7.html",
        "BriefIntro": "在上次的文章中，我们已经提到了一种能够跨子域名进行AJAX请求的方法。我们现在就来实现一个对开发人员透明的实现，它会自动判断这个请求是否是跨子域名，如果不是，则使用传统的方法发出AJAX请求，反之则使用我们的方式。 "
    },
    {
        "Title": "UpdatePanel与ASP.NET Page的缓存",
        "Link": "/2007/02/updatepanel-and-asp-net-cache.html",
        "BriefIntro": "UpdatePanel的功能大家一定都非常熟悉了。无论是官方还是社区里热心推广ASP.NET AJAX的朋友，都会对于UpdatePanel的使用进行大量说明与展示。但是在这些简单的的示例似乎都遗漏了一个非常重要的问题，这个问题会直接导致UpdatePanel无法正确使用。　　这个问题就是ASP.NET Page的缓存。 "
    },
    {
        "Title": "挣脱浏览器的束缚（6） - AJAX也跨域名",
        "Link": "/2007/02/break-the-browsers-restrictions-6.html",
        "BriefIntro": "事情的经过是这样的，还是那个个人门户网站。其中有个功能就是RSS订阅，每个订阅作为一个模块出现在页面上。如果一个用户订阅了比较多的RSS，则在打开页面时所有的RSS模块就会开始加载，这时候可能就会需要十几秒甚至更长的时间才能加载完毕。这时，如果用户需要作别的AJAX操作――比如保存页面设置――那么长时间的等待就不可避免了，谁让浏览器对于相同域名只能同时存在两个连接呢？不过这可不是一个好的用户体验，那么我们需要怎么做呢？ "
    },
    {
        "Title": "编写组件，使用JavaScript更新UpdatePanel",
        "Link": "/2007/01/update-the-updatepanels-by-js.html",
        "BriefIntro": "如果需要使用JavaScript更新UpdatePanel，以前往往会使用JavaScript来模拟Trigger的触发。我们往往会将一个按钮设为某个UpdatePanel的Trigger，然后在客户端模拟它的点击，使UpdatePanel进行更新。但是这样的做法实在太麻烦了些，也相当的不优雅。现在我们就来编写一个组件解决这个问题。 "
    },
    {
        "Title": "挣脱浏览器的束缚（5） - 哭笑不得的IE Bug",
        "Link": "/2007/01/break-the-browsers-restrictions-5.html",
        "BriefIntro": "还记得《ASP.NET AJAX Under the Hood Secrets》吗？这是我在自己的Blog上推荐过的唯一一篇文章（不过更可能是一时兴起）。在这片文章里，Omar Al Zabir提出了他在使用ASP.NET AJAX中的一些经验。其中提到的一点就是：Browsers do not respond when more than two calls are in queue。简单的说，就是在IE中，如果同时建立了超过2两个连接在“连接状态”中，但是没有连接成功（连接成功之后就没有问题了，即使在传输数据），浏览器会停止对其他操作的响应，例如点击超级链接进行页面跳转，直到除了正在尝试的两个连接就没有其他连接时，浏览器才会重新响应用户操作。出现这个问题一般需要3个条件： 同时建立太多连接，例如一个门户上有许多个模块，它们在同时请求服务器端数据。 响应比较慢，从浏览器发起连接，到服务器端响应连接，所花的时间比较长。 使用IE浏览器，无论IE6还是IE7都会这个问题，而FireFox则一切正常。 在IE7里居然还有这个bug，真是令 "
    },
    {
        "Title": "挣脱浏览器的束缚（4） - 王道！动态添加script元素",
        "Link": "/2007/01/break-the-browsers-restrictions-4.html",
        "BriefIntro": "我们已经知道，脚本文件的并行下载能够提高页面的加载速度。但是目前还有一个急需解决的问题，那就是对于FireFox浏览器的优化。在我们之前使用的优化方法，无论是简单实用的document.write还是食之无味的defer属性，FireFox浏览器都对此置若罔闻。不过FireFox也不是绝对地“冥顽不灵”，开发人员还是有方法对它进行优化的。 "
    },
    {
        "Title": "ASP.NET AJAX正式版带来的Validator问题及解决方案",
        "Link": "/2007/01/validators-in-asp-net-ajax-finals.html",
        "BriefIntro": "升级到ASP.NET AJAX正式版之后，一般来说重新编译不会有什么问题，不用做什么修改，这是个好消息。不过在执行时就会出现问题了。因为在正式版的程序集中，删除了兼容UpdatePanel的Validator那些类，因此TagMapping时就无法找到需要的类了。 "
    },
    {
        "Title": "ScriptManager的ResolveScriptReference事件的重要作用",
        "Link": "/2007/01/the-importance-of-resolvescriptreference.html",
        "BriefIntro": "合理使用，支撑一个专业的详细的脚本库也不是件困难的事情。 "
    },
    {
        "Title": "Jolt Awards提名已经出来了",
        "Link": "/2007/01/627575.html",
        "BriefIntro": "其实按照Schedule已经出来一周了吧：SCHEDULENominations open October 2006Nominations close December 15, 2006Finalists announced January 15, 2007Winners announced at SD West 2007 on March 21, 2007Jolt Awards年年关注，现在也只... "
    },
    {
        "Title": "挣脱浏览器的束缚（3） - 两个连接还不够“并行”",
        "Link": "/2007/01/break-the-browsers-restrictions-3.html",
        "BriefIntro": "谈谈优化难度：比较document.write与defer、突破两个连接的限制 "
    },
    {
        "Title": "挣脱浏览器的束缚（2） - 别让脚本引入坏了事",
        "Link": "/2007/01/break-the-browsers-restrictions-2.html",
        "BriefIntro": "现在哪里还找得到不引入JavaScript脚本文件的Web应用？使用脚本文件的好处多多，其中最重要的可能就是提供缓存能力了。使用脚本文件之后再加上缓存，可以大大降低数据传输量，提高页面打开的速度。不过脚本文件的引入也不是简单得不值一提，我们完全有能力来优化它。 "
    },
    {
        "Title": "挣脱浏览器的束缚（1） - 前言",
        "Link": "/2007/01/break-the-browsers-restrictions-1.html",
        "BriefIntro": "最近在为某个人门户站点作优化。 　　从传统意义上来说，这个站点的各方面都属中规中矩。不过作为一个以客户端为中心的Web应用，其性能，尤其是它的感知性能（Perceived Performance），经常会严重受制于浏览器本身。一个没有对客户端数据访问模型经过精心设计和优化的应用，其导致的结果往往就是无法充分利用带宽，让用户等待的时间变长。换句话说，其Perceived Performance需要进一步的提高。 　　突破浏览器限制，充分利用带宽，提高性能，尤其是Perceived Performance等等，就是我这次优化的目的。在接下来的几篇文章里，我将以数据说话，探讨浏览器的限制，并从多个方面来谈一下这次优化的各种方式。由于该个人门户使用了ASP.NET AJAX进行开发，因此我也将会给出一些基于ASP.NET AJAX的解决方案，希望会有一定参考价值，对朋友们能有所帮助。 "
    },
    {
        "Title": "在2006年的最后一天，我做出了一个决定",
        "Link": "/2006/12/decision-at-the-last-day-of-2006.html",
        "BriefIntro": "在2006年的最后一天，我做出了一个决定。今天我决定离开现在的单位――Windows Live China――寻求更好的发展。 "
    },
    {
        "Title": "Tip：使用Extender的ResolveControlID事件",
        "Link": "/2006/12/resolvecontrolid-event.html",
        "BriefIntro": "不知道大家在使用ASP.NET AJAX Control Toolkit里的各个Extender控件时，有没有接触过ResolveControlID事件？这个事件在官方也只用了很少的笔墨来描述。的确，这个事件不太常用，看看ASP.NET AJAX的演示站点，根本没有使用过ResolveControlID事件。本文简单描述了ResolveControlID事件的作用以及使用方式。 "
    },
    {
        "Title": "不复杂，但是很有趣的JavaScript代码",
        "Link": "/2006/12/605547.html",
        "BriefIntro": "找个图片比较多的页面，把下面的代码粘贴到地址栏按回车就可以看到效果。:)**************************javascript:R=0; x1=.1; y1=.05; x2=.25; y2=.24; x3=1.6; y3=.24; x4=300; y4=200; x5=300; y5=200; DI=document.images; DIL=DI.length; function... "
    },
    {
        "Title": "可能是最漂亮的非静态Page Method解决方案",
        "Link": "/2006/12/best-nonstatic-page-method-implementation.html",
        "BriefIntro": "在我前一片文章《浅谈实例Page Method到静态Page Method的移植》中，我提到了两种属于work around的解决方案，的确有效，如果可以的话我也建议尽可能地改成那样，尤其是第一种“在客户端获得参数信息”的做法，性能很高，值得推荐。不过从“技术”方面来考虑，这两个做法都不如现在这种来得漂亮。我尝试着实现了一个HttpModule，只要使用了它就能轻松使用原来的“非静态Page Method”了，这几乎完全解决了ASP.NET AJAX中无法使用非静态Page Method的问题，CTP时期程序的移植也变得再容易不过。 "
    },
    {
        "Title": "UpdatePanel与UrlRewrite",
        "Link": "/2006/12/updatepanel-with-url-rewrite.html",
        "BriefIntro": "今天被问及一个UpdatePanel与Url Rewrite结合时的问题，研究之后得出解决方案，在此和大家分享一下。 "
    },
    {
        "Title": "浅谈实例Page Method到静态Page Method的移植",
        "Link": "/2006/12/page-methods.html",
        "BriefIntro": "最近被问及Page Method的问题比较多，主要还是如何从Atlas CTP中的非静态Page Method转向Beta或RC中的静态Page Method时所遇到的问题。现在我来谈一下在这方面的一些看法，也希望大家能和我一起探讨一下。 "
    },
    {
        "Title": "扩展JavaScript的时候，千万要保留其原来的所有功能",
        "Link": "/2006/12/601901.html",
        "BriefIntro": "扩展JavaScript的时候，千万要保留其原来的所有功能，因为不知道别人的代码是否会用到这些。而且一般来说，为了写出兼容更多JS框架的代码，最保险的方法就是用JS的原生功能。然而在这个问题上，这次ASP.NET AJAX RC栽跟头了。 "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第十一部分：示例控件（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-11.html",
        "BriefIntro": "这片文档包含了几个例子，演示了如何使用WPF/E来创建交互式的控件。这篇文档包含了如下部分：“超级链接”示例 “按钮”示例 “滚动条”示例 下面该做什么呢？ "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第十部分：脚本和鼠标事件（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-10.html",
        "BriefIntro": "WPF/E支持使用JavaScript进行编程，能够使您为WPF/E内容增加交互性。这篇文档包含了如下部分：脚本与事件 设置属性 设置附加属性 公有鼠标事件 为对象命名并重新获取它们 动态创建WPF/E对象 交互地控制动画 下面该做什么呢？ "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第九部分：动画（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-9.html",
        "BriefIntro": "WPF/E能够让您使用标记来定义动画。这篇QuickStart介绍了WPF/E的动画特性，并且带领您创建您的第一个WPF/E动画。这篇QuickStart包含了如下部分：演练：为一个对象添加动画效果其它类型的动画 Timeline的属性 指定动画变换的值 在同一个对象上添加多个动画 下面该做什么呢？ "
    },
    {
        "Title": "讲座展示：TechEd Europe DEV 411 - AJAX Patterns with ASP.NET AJAX（3）",
        "Link": "/2006/12/lecture--teched-europe-dev411-3.html",
        "BriefIntro": "这次我选择的讲座内容，是最近在TechEd 2006 Europe中Andre Snanbria和Jeff Prosise的讲座“AJAX Pattern with ASP.NET AJAX”。Jeff Prosise是Wintellect的Co-Founder，Andre Sanabria是ASP.NET AJAX Team的Lead Program Manager。这次讲座的主要内容是讲述了使用ASP.NET AJAX开发AJAX应用的最佳实践，在这次讲座里，会对建立轻量级的客户端控件的方法进行深入，讲述了如何优化脚本代码，并提出了如何避免AJAX开发中常见的问题。本篇文章是这次讲座展示的第三篇，使用了一个例子来观察UpdatePanel的工作方式，并通过几个步骤对这个例子进行优化。 "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第八部分：媒体（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-8.html",
        "BriefIntro": "WPF/E提供了MediaElement对象，可以让您在页面中播放WMV（Windows Media Video）和WMA（Windows Media Audio）文件。这篇文档包含了以下部分：在页面中添加媒体信息 有用的MediaElement属性 交互式地控制媒体的播放 下面该做什么呢？ "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第七部分：文本（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-7.html",
        "BriefIntro": "TextBlock元素能使您在WPF/E内容中添加文本。这篇文档描述了使用TextBlock元素的方式。这篇文档包含了以下部分：TextBlock元素 常用TextBlock属性 Run元素 指定多种字体 下面该做什么呢？ "
    },
    {
        "Title": "The Problem with Programming（翻译）",
        "Link": "/2006/12/the-problem-with-programming.html",
        "BriefIntro": "这是一次访谈。访谈的对象是大名鼎鼎的Bjarne Stroustrup，“C++之父”的称号注定他永远是大师。这次他在接受了Technology Review的采访，对于软件开发的目前状况谈了他的看法，指出了不少问题。那么这些问题是否真的如他所述？按照我个人的习惯，我始终把对于大师的“尊敬”和对于其言论的“吸收”相分离，我们不妨围绕着这次Bjarne Stroustrup的谈话内容，展开我们的讨论吧。 "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第六部分：图像（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-6.html",
        "BriefIntro": "Image元素能使您在WPF/E中显示位图信息。这篇文档包含了以下部分：Image元素 Stretch属性 使用位图的其它方法 下面该做什么呢？ "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第五部分：公有图形属性（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-5.html",
        "BriefIntro": "一些属性能够被应用在所有的WPF/E的UIElement对象上：Canvas，shapes和TextBlock。这篇文档描述了这些对象所具有的公有图形属性。这篇文档包含了以下部分：Opacity属性 OpacityMask属性 Clip属性 RenderTransform属性 下面该做什么呢？ "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第四部分：绘图与填充（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-4.html",
        "BriefIntro": "WPF/E通过提供Ellipse，Rectangle，Line，Polyline，Polygon和Path元素以支持矢量图。同样的，这些元素也被称之为“形状（Shape）”元素。这片文档包含了以下部分基础形状 其他形状元素 使用画刷填充形状 形状转换 下面该做什么呢？ "
    },
    {
        "Title": "讲座展示：TechEd Europe DEV 411 - AJAX Patterns with ASP.NET AJAX（2）",
        "Link": "/2006/12/lecture--teched-europe-dev411-2.html",
        "BriefIntro": "这次我选择的讲座内容，是最近在TechEd 2006 Europe中Andre Snanbria和Jeff Prosise的讲座“AJAX Pattern with ASP.NET AJAX”。Jeff Prosise是Wintellect的Co-Founder，Andre Sanabria是ASP.NET AJAX Team的Lead Program Manager。这次讲座的主要内容是讲述了使用ASP.NET AJAX开发AJAX应用的最佳实践，在这次讲座里，会对建立轻量级的客户端控件的方法进行深入，讲述了如何优化脚本代码，并提出了如何避免AJAX开发中常见的问题。本篇文章是这次讲座展示的第二篇，讲述了UpdatePanel的工作方式。 "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第三部分：Canvas对象（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-3.html",
        "BriefIntro": "Canvas对象是一个设计用来存放和定位各种图形和控件的对象。每一个WPF/E XAML文件都至少有一个Canvas。这篇文当介绍了Canvas对象，并且描述了应该如何添加，定位子对象以及改变其大小。这篇文档包含以下部分。向您的Canvas里添加一个对象 定位一个对象 控制宽度和高度 嵌套的Canvas对象 下面该做什么呢？ "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第二部分：创建一个XAML文件（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-2.html",
        "BriefIntro": "在前一篇文档中“创建一个WPF/E项目”中，我们向HTML页面里添加了一个WPF/E控件，并且创建了一个空的XAML文件。这篇文档会向您展示如何在您的XAML文件里创建WPF/E内容。第一步：创建一个Canvas和命名空间的声明 第二步：画些东西吧！ 第三步：查看您的XAML内容 下面该做什么呢？ "
    },
    {
        "Title": "WPF/E CTP Quick Start - 第一部分：创建一个WPF/E项目（翻译）",
        "Link": "/2006/12/wpfe-ctp-quick-start-part-1.html",
        "BriefIntro": "您该如何在您的页面中添加WPF/E呢？一个典型的WPF/E项目有4个文件：一个用于存放和显示内容的HTML文件，一个aghost.js文件，一个XAML文件和一个JavaScript文件。这篇文当描述了创建一个WPF/E工程，以及向HTML添加WPF/E内容的三个步骤。这份指导包括了一下部分： * 在您开始之前…… * 第一步：建立一个aghost.js文件 * 第二步：在您的HTML文件中创建一个ActiveX控件 * 第三步：创建一个表示WPF/E内容的文件 * 添加额外的WPF/E内容 * 一个示例工程 * 下面该做什么呢？ "
    },
    {
        "Title": "AJAX培训第三讲：开发一个简单的AJAX聊天室",
        "Link": "/2006/12/ajax-lesson-03.html",
        "BriefIntro": "这次的内容是开发一个AJAX聊天室，目的是让大家略为巩固一下前两次所讲的AJAX常用的基础知识。 "
    },
    {
        "Title": "讲座展示：TechEd Europe DEV 411 - AJAX Patterns with ASP.NET AJAX（1）",
        "Link": "/2006/12/lecture--teched-europe-dev411-1.html",
        "BriefIntro": "这次我选择的讲座内容，是最近在TechEd 2006 Europe中Andre Snanbria和Jeff Prosise的讲座“AJAX Pattern with ASP.NET AJAX”。这次讲座的主要内容是讲述了使用ASP.NET AJAX开发AJAX应用的最佳实践，在这次讲座里，会对建立轻量级的客户端控件的方法进行深入，讲述了如何优化脚本代码，并提出了如何避免AJAX开发中常见的问题。本篇文章是这次讲座展示的第一篇，讲述了这次讲座的内容概要，并浏览了第一个示例的各个功能。 "
    },
    {
        "Title": "文章推荐：ASP.NET AJAX Under the Hood Secrets及其他",
        "Link": "/2006/12/article-suggestion--aspnet-ajax-under-the-hood-secrets-and-others.html",
        "BriefIntro": "ScottGu今天在他的Blog上发了一篇新的文章，提到了PageFlakes.com网站，以及它的核心架构师Omar Al Zabir。当然最重要的还是Omar的文章：《ASP.NET AJAX Under the Hood Secrets》，虽然可能一些已经深入了解ASP.NET AJAX以及Web开发的朋友们会对这篇文章里提到的内容已经比较多的了解，但是我想对于大多数的朋友来说，这篇文章会给我们的ASP.NET AJAX使用，以及Web开发带来一些启示。不过，我产生推荐这篇文章“冲动”其实还有别的原因…… "
    },
    {
        "Title": "讲座展示：Live From Redmond: Microsoft AJAX Patterns - Implementing Predictive Fetch with Microsoft ASP.NET 2.0 AJAX Extensions",
        "Link": "/2006/12/lecture-lfr-microsoft-ajax-pattern-prediction-fetch.html",
        "BriefIntro": "在AJAX形式的Web开发中存在着一些常用的编程模式。在这个讲座里，Joe会讲述并且使用ASP.NET 2.0 AJAX Extensions做一个简单的演示，用来说明“Predictive Fetch”模式。 "
    },
    {
        "Title": "我的一些看法：关于AJAX框架的比较",
        "Link": "/2006/11/about-ajax-framework-comparation.html",
        "BriefIntro": "Dflying兄最近在对于ASP.NET的AJAX实现进行一基于数据传输大小的比较，图文并茂，颇能够在体现某些方面的问题。这不禁使我我对于这方面也进行了一些思索，这里就说一下我的看法。 "
    },
    {
        "Title": "AJAX培训第二讲：使用AJAX框架（下）",
        "Link": "/2006/11/ajax-lesson-02-2.html",
        "BriefIntro": "“AJAX培训第二讲：使用AJAX框架”现在拆成了两部分，现在发布是第一部分，探讨了AJAX框架相关内容，并给出了一些最简单的例子。 "
    },
    {
        "Title": "AJAX培训第二讲：使用AJAX框架（上）",
        "Link": "/2006/11/ajax-lesson-02-1.html",
        "BriefIntro": "“AJAX培训第二讲：使用AJAX框架”现在拆成了两部分，现在发布是第一部分，探讨了ASP.NET 2.0中的AJAX能力。而第二部分我还在重新修补和录制，大概会在周一发布。 "
    },
    {
        "Title": "FAQ - 什么是软件工厂？（翻译）",
        "Link": "/2006/11/faq--what-is-software-factory.html",
        "BriefIntro": "Microsoft Patterns & Practices已经提供了不少“软件工厂（Software Factory）”，例如Smart Client Software Factory，Web Service Software Factory和Mobile Client Software Factory。而在CodePlex上也已经有了Microsoft P & P Team正在开发的下一代产品：Web Client Software Factory。这是一个非常有价值，非常值得关注的项目，目前正在以Weekly Drop的形式发布，按照计划将会在年底发布。在Terry Lee和我都曾经对它进行过介绍。　　那么什么是“软件工厂”呢？它的作用又是什么呢？Jezz Santos在写了数篇有关这方面非常精彩的文章，他本人已经同意我将其文章进行翻译。我将陆续将它们翻译成中文，帮助大家和我自己理解一些概念。 "
    },
    {
        "Title": "讲座展示：TechEd Europe DEV344 - ASP.NET AJAX Control Toolkit（下）",
        "Link": "/2006/11/lecture-teched-europe-dev344-3.html",
        "BriefIntro": "此次讲座分为两部分：“ASP.NET AJAX Control Toolkit介绍和使用”以及“开发一个Extender控件”。本文将对于该讲座的第二部分进行讲述，并且对其第二个演示的剩余部分进行分析。 "
    },
    {
        "Title": "讲座展示：TechEd Europe DEV344 - ASP.NET AJAX Control Toolkit（中）",
        "Link": "/2006/11/lecture-teched-europe-dev344-2.html",
        "BriefIntro": "此次讲座分为两部分：“ASP.NET AJAX Control Toolkit介绍和使用”以及“开发一个Extender控件”。本文将对于该讲座的第二部分进行讲述，并且对其第二个演示的第一个部分进行分析。 "
    },
    {
        "Title": "讲座展示：TechEd Europe DEV344 - ASP.NET AJAX Control Toolkit（上）",
        "Link": "/2006/11/lecture-teched-europe-dev344-1.html",
        "BriefIntro": "这次我选择的讲座内容是最近在TechEd 2006 Europe中Shawn Burke的讲座“ASP.NET AJAX Control Toolkit Unleashed: Creating Rich Client-Side Controls and Components”。Shawn Burke是微软.NET Developer Platform总监。　　此次讲座的内容主要是对于ASP.NET AJAX Control Toolkit进行简单的介绍，展示了Extender控件是如何帮助ASP.NET开发人员简单地将丰富的用户体验集成到他们的Web应用程序中。在这次讲座里将看到应该如何在您的应用中使用ASP.NET AJAX Control Toolkit中的组件，并且了解开发人员是如何方便地开发一个APS.NET AJAX Extender的。　　此次讲座分为两部分：“ASP.NET AJAX Control Toolkit介绍和使用”以及“开发一个Extender控件”。本文将对于该讲座的第一部分进行讲述，并且对其第一个演示进行分析。 "
    },
    {
        "Title": "推荐：体验TechEd 2006 Europe Edition",
        "Link": "/2006/11/teched-2006-europe-edition.html",
        "BriefIntro": "TechEd 2006 China不久刚落下帷幕，TechEd 2006 Europe Edition又在西班牙巴塞罗那风风火火地开始了。微软为这次盛会专门准备一个网站来介绍它的一切。在这个站点里您能够看到此次盛会的大量相关信息，当然也有Virtual Side，不过最重要的就是其中有部分讲座的视频！这些都是优秀的资源。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas示例（7） - 编写JavaScriptConverter处理含有循环引用的类型",
        "Link": "/2006/11/inside-atlas-series--web-services-access-in-atlas--sample-7.html",
        "BriefIntro": "有时候在Web Service中会需要使用到比较复杂的类型，它们的特征往往都是含用循环引用，这样的对象如果交给ASP.NET AJAX中默认的序列化方式来处理则会抛出异常，大家经常遇到的“DataTable”问题正是由此引起的。关于这一点，ASP.NET AJAX自然提供了解决方法，在这里“官方”的解决方案就是JavaScriptConverter，它可以让开发人员自定义特定类型的序列化能力。 "
    },
    {
        "Title": "深入Atlas系列：综合示例（1） - 调用服务器端方法时直接获得客户端具体类型",
        "Link": "/2006/11/inside-atlas-series--sample-1.html",
        "BriefIntro": "在使用ASP.NET AJAX时，大家对于返回服务器端的复杂类型的情况经常会遇到问题。Dflying兄写了一篇文章来说明在如何在客户端得到Sys.Preview.Data.DataTable对象的文章，但是这种方法需要在客户端进行Sys.Preview.Data.DataTable的构造，那么我们该如何直接获得这个对象呢？再进一步，我们该如何直接获得客户端某种特定格式的对象呢？本篇文章给出了一个解决方案，事实上，这个扩展的能力还不止如此…… "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas示例（6） - 在客户端隐藏服务器端类型信息",
        "Link": "/2006/11/inside-atlas-series--web-services-access-in-atlas--sample-6.html",
        "BriefIntro": "如果要在客户端指定服务器端Web Service方法所接收的参数类型，就必须在客户端通过“__type”来指定，但是这就暴露了服务器端的具体类型了，这可不太好。现在我们就来看一下应该如何解决这个问题。 "
    },
    {
        "Title": "深入Atlas系列：探究序列化与反序列化能力（下） - JavaScriptSerializer",
        "Link": "/2006/11/inside-atlas-series--investigate-the-serialization-and-deserialization-ability-2.html",
        "BriefIntro": "在ASP.NET AJAX中，客户端的序列化与反序列能力由Sys.Serialization.JavaScriptSerializer类的serialize和deserialize两个静态方法提供。在服务器端，所有的序列化与反序列化能力，包括类型之间的转换，对于开发人员来说都是由JavaScriptSerializer类的几个方法实现的。从前一片文章里我们已经知道了两个辅助的类：JavaScriptTypeResolver和JavaScriptConverter，他们的作用分别是“映射类与类标识”，以及“提供特定类的序列化与反序列化能力”。在某些情况下，我们还是需要使用JavaScriptSerializer类的方法来操作一个类型，例如使用JavaScriptConverter来自定义特定类的序列化或者反序列化，就需要使用JavaScriptSerializer类的方法，因此我们这次就详细看一下这个类的能力。 "
    },
    {
        "Title": "深入Atlas系列 - 浅析ASP.NET Beta 2中令人疑惑的脚本引入方式",
        "Link": "/2006/11/inside-atlas-series--skim-the-confusing-script-loading-mechanism-in-beta2.html",
        "BriefIntro": "似乎已经有不少朋友在作了ASP.NET AJAX Beta 1到Beta 2的转移之后遇到了这样的问题：如果使用了ScriptManager引入了自定义的JavaScript脚本文件后会发生JavaScript错误。本文简单讨论了引发这个问题的原因，解决方案以及注意事项。 "
    },
    {
        "Title": "AJAX培训第一讲：AJAX基础",
        "Link": "/2006/11/ajax-lesson-01.html",
        "BriefIntro": "经过了5个小时的准备，10多个小时的录制和剪辑，我终于将第一次AJAX培训的内容做完了。录一次讲座真的是一件费神费时的事情，我也深切感受到了天轰穿兄录了数十次讲座有多么不容易。这是我第一次录制讲座，所以经验有些不足，而且对着屏幕一个人傻傻地说话总是不如对着观众说话，在语气上也略显单调。虽然我已经极力yy正在为数十人作讲座的情形，但是似乎效果不甚理想。另外不知道是什么原因，录下来的声音总是不像我的原声，听上去也有些沉闷，请大家多多包涵了。如果大家对于讲座的方式上有什么意见或者建议的话，请回复在这里，您的支持能够让我们的工作越做越好。如果大家对于讲座的内容有任何疑问，请在Q & A专用文章里进行提问，当然如果您有其它任何疑问的话，也能在那里提出，我会尽快为您解答。 "
    },
    {
        "Title": "深入Atlas系列：探究序列化与反序列化能力（上） - 客户端支持，JavaScriptTypeResolver与JavaScriptConverter",
        "Link": "/2006/11/inside-atlas-series--investigate-the-serialization-and-deserialization-ability-1.html",
        "BriefIntro": "在ASP.NET AJAX中是使用了JSON作为客户端与服务器端传递对象信息的方式。因此，在ASP.NET AJAX的客户端与服务器端均提供了序列化与反序列化的能力。了解这些内容的使用方法，可以说是使用与扩展ASP.NET AJAX所必须的能力。在这两篇文章里，我们就来看一下ASP.NET AJAX中的序列化与反序列化的能力。 "
    },
    {
        "Title": "深入Atlas系列：探究Application Services（3） - 自定义客户端Profile Service支持",
        "Link": "/2006/11/inside-atlas-series--investigate-the-application-services-3.html",
        "BriefIntro": "如果不能在客户端进行自定义的话，Profile Service的自定义能力还是远远不够的。虽然Profile Service没有提供一种“官方”的客户端自定义支持，不过事实上“自定义”能力“天然”地存在与客户端里。为什么？因为整个客户端是由JavaScript实现的，这种灵活的语言使得我们能够在一定程度上自由地修改客户端的行为。 "
    },
    {
        "Title": "深入Atlas系列：探究Application Services（2） - 自定义服务器端Profile Service支持",
        "Link": "/2006/11/inside-atlas-series--investigate-the-application-services-2.html",
        "BriefIntro": "在上一篇文章中，我们讨论了使用ASP.NET AJAX默认的Profile Service。一般来说，它已经能够迎合大多数应用的需要了。不过除此之外，ASP.NET AJAX还提供了让我们自定义Profile Service的机制。 "
    },
    {
        "Title": "深入Atlas系列：探究Application Services（1） - Profile Service分析与使用",
        "Link": "/2006/11/inside-atlas-series--investigate-the-application-services-1.html",
        "BriefIntro": "ASP.NET AJAX提供了Profile Service，允许开发人员异步地从服务器端访问Profile信息。从RTM开始，客户端的Profile Service还提供了对于Profile Group的支持，因此可以说已经相当成熟了。那么对于Profile Service的细节，是否大家都了解了呢？从ScriptManager的使用上来看，ProfileService是能够扩展的，那么应该如何扩展呢？细心的朋友们应该也发现了，在web.config中也增加了对于Profile Service的配置，那么这些配置应该如何使用呢？ "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（8） - RTM中可叹的Web Service Proxy",
        "Link": "/2006/11/inside-atlas-series--web-services-access-in-atlas-8.html",
        "BriefIntro": "使用Web Service Proxy应该是使用ASP.NET AJAX访问Web Service最常用的方法了。服务器端会根据ScriptManager中添加的Service引用而对于Web Service类进行分析，并生成相应的客户端脚本。这样开发人员就能在客户端方便而且直观地访问Web Services方法了。这是ASP.NET中很重要的功能。从官方文档上看来，CTP和RTM似乎在脚本使用这方面没有很大的改变，只要在服务器端将一些CustomAttribute改变一下就可以了。的确没错，在使用方式上只有这点细微改变，但是事实上，从生成脚本本身来说，CTP和RTM的做法大相径庭。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（7） - RTM中的客户端支持",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas-7.html",
        "BriefIntro": "在RTM版本中，客户端访问Web Services的基础类库发生了一些改变，并直接影响到了它们的使用方式。对于自己写ASP.NET AJAX组件（例如ExtenderControl）的朋友们来说，了解这部分改变是非常重要的。 "
    },
    {
        "Title": "深入Atlas系列：客户端网络访问基础结构示例（1） - 编写并使用自定义的WebRequestExecutor",
        "Link": "/2006/10/inside-atlas-series--client-communication-architecture--sample-1.html",
        "BriefIntro": "WebRequestExecutor是ASP.NET AJAX网络访问基础结构的唯一修改点。理论上，我们可以使用自定义的WebRequestExecutor来取代默认的XMLHttpExecutor。我们要做的，其实只是开发一个继承于Sys.Net.WebRequestExecutor类。不过事实上，在实际使用中，Sys.Net.XMLHttpExecutor已经足够用了，真的要自定义，也只需继承这个类即可。就像接下去的例子一样。 "
    },
    {
        "Title": "深入Atlas系列：客户端网络访问基础结构（下） - WebRequestExecutor和XMLHttpExecutor",
        "Link": "/2006/10/inside-atlas-series--client-communication-architecture-2.html",
        "BriefIntro": "正如前一篇文章所说的那样，WebRequestExecutor是客户端网络访问的基础结构的唯一扩展点，而XMLHttpExecutor是其默认实现。在ASP.NET AJAX中，开发人员能够将自定义的WebRequestExecutor子类设为默认的Executor，也可以为某一个WebRequest指定一个特定的Executor。虽然一般来说XMLHttpExecutor已经足够大多数应用，但是既然ASP.NET AJAX提供了这个功能，我们也根据默认的类进行一下这方面的学习。 "
    },
    {
        "Title": "深入Atlas系列：客户端网络访问基础结构（上） - WebRequest的工作流程与生命周期",
        "Link": "/2006/10/inside-atlas-series--client-communication-architecture-1.html",
        "BriefIntro": "ASP.NET AJAX的许多功能会要求异步地访问服务器端，例如访问Web Services，Authentication/Profile Services（事实上和访问Web Services是相同的机制）和Partial Rendering。在ASP.NET AJAX中，所有的这些访问都是通过一个网络访问的基础结构来完成的，无一例外。 "
    },
    {
        "Title": "深入Atlas系列：客户端代码编写规则分析与指南",
        "Link": "/2006/10/inside-atlas-series--rtm-script-style-analyse-and-coding-guidelines.html",
        "BriefIntro": "在RTM版本中，我们可以发现ASP.NET AJAX的客户端脚本引入了许多规则：有方法注释规则，有参数验证规则，而且对于Debug和Release模式下的脚本代码，甚至添加在程序集里的方式，也有相当严禁的规则。如果我们想要编写真正规范和严谨的代码或组件，了解这些规则是非常必要的。有了这些规则，用户在使用Debug模式进行开发和调试时可以得到更好的提示（比如Call Stack），下一版本的Visual Studio“Orcas”也会根据这些规则提供良好的IntelliSense功能。另外，了解这些规则也有利于帮助开发人员阅读和理解客户端代码，这不也是我写“深入Atlas系列”的目的吗？在这片文章里，我将使用ASP.NET AJAX的脚本代码为范例，对开发规则进行一番描述。在某些时候也会对客户端和服务器端的部分代码进行简单的分析。 "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（9） - Using the Value-add Scripts",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-9.html",
        "BriefIntro": "Discussed the usage of the Value-add Scripts "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（8） - UpdatePanel Control",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-8.html",
        "BriefIntro": "对于UpdatePanel控件的使用是ASP.NET AJAX Extentions的重要部分。我们收到了关于它和UpdateProgress控件的大量用户反馈。为了增强部分刷新的功能我们作了多处修改，并加强了UpdatePanel对于控件的兼容性。我们也为异步PoskBack实现了一个丰富的事件模型，这样您就可以在客户端响应它们并对页面更新提供额外操作了。 "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（7） - ScriptManager and ScriptManagerProxy Controls, Extender Controls",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-7.html",
        "BriefIntro": "Discussed ScriptManager, ScriptManagerProxy and Extender Controls "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（6） - Networking, Application Services",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-6.html",
        "BriefIntro": "为了简化Web Services方法调用，客户端代理的设计被改变了，它在方法调用和回调函数设置方面提供了强大的灵活性。另外，在RTM版本中，客户端的Authentication服务和Profile服务使用了一个简化的并且更为灵活的设计。这个设计与客户端访问Web Services方法保持了统一。 "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（5） - Higher-level Component Framework",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-5.html",
        "BriefIntro": "高级组件的功能已经根据客户反馈，性能等诸多因素进行了修改。 "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（4） - Browser Compatibility, Building Debug and Release Scripts, Defining Type Descriptors",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-4.html",
        "BriefIntro": "Discussed the differences of the following aspects between CTP and RTM release of Microsoft ASP.NET AJAX:1、Browser Compatibility2、Building Debug and Release Scripts3、Defining Type Descriptors "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（3） - Class and Type Definition, Reflection APIs",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-3.html",
        "BriefIntro": "在CTP版本中，您能创建各种各样的类型，例如类，接口，枚举和标记（flag）。这些功能在RTM版本中被改变了。 "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（2） - Class、JavaScript Extensions (Client BCL)",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-2.html",
        "BriefIntro": "在CTP release中，“类”和类型是使用closure定义的，在类的构造函数中生效（尽管这些类不能以.NET Framework中的类的方式理解，为了方便，我们在这里还是将它们称之为类）。在RTM中，我们使用了prototype模型。另外，CTP版本包括了对于JavaScript内置对象的一系列扩展，这些会继续保留在RTM版本中。然而，它们被重新设计以避免与其它AJAX框架的潜在冲突。 "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX（1） - Overview of Major Changes",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-1.html",
        "BriefIntro": "ASP.NET 2.0 AJAX Extensions对于Atlas来说，不仅仅是一个名称上的改变，它从基础结构实现，到客户端与服务器端的应用，都发生了翻天覆地的变化。相对于Atlas来说，似乎ASP.NET 2.0 AJAX Extentions在各个方面都有了长足的进步。一些原有的诟病与硬伤得到了改善，可以说，相比于以前的Atlas，它成熟了。 "
    },
    {
        "Title": "从Atlas到Microsoft ASP.NET AJAX - 序",
        "Link": "/2006/10/from-atlas-to-microsoft-asp-net-ajax-lets-begin.html",
        "BriefIntro": "从现在开始，我们来“从Atlas到Microsoft ASP.NET AJAX”！ "
    },
    {
        "Title": "Microsoft ASP.NET AJAX的RTM Release在一定程度上更像是一个晴天霹雳",
        "Link": "/2006/10/what-the-hell-the-change-is.html",
        "BriefIntro": "即使我已经将Atlas的代码看了大半，即使我已经准备好了后面几片“深入Atlas系列”的文章，但是不得不承认，它们几乎没有什么用了。粗粗看了一遍客户端代码和一半左右的文档，它已经不是我所认识的Atlas了。它对于我来说又成了一个陌生的东西。这次的Release，我认为，从一个根本的角度改变了原来的Atlas，从客户端的对象构造的基础（closure变成了prototype）... "
    },
    {
        "Title": "Atlas中有趣且无用的功能：Sys.UI.Window类",
        "Link": "/2006/10/sys-ui-window.html",
        "BriefIntro": "Atlas的客户端代码中有着一个有趣的类，就是Sys.UI.Window。这个类的功能非常简单，只是对于Javascript功能的封装，用于提供各种提示框。 "
    },
    {
        "Title": "出于对Atlas自带AutoCompleteBehavior的不满，自定义了一个支持模版的AutoCompleteBehavior",
        "Link": "/2006/10/jeffz-ui-autocompletebehavior.html",
        "BriefIntro": "AutoCompleteBehavior只能作出最简单的提示，其它什么功能也没有。无法设置样式，无法自定义信息，这就是我们想要的功能吗？这就是所谓的“桌面级”体验吗？很显然，这远远不够。豪不夸张地说，我是怀着对于AutoCompleteBehavior的强烈不满（其实这是前几天我在向别人介绍Atlas时被人Challenge的结果），决定自定义一个加强的AutoCompleteBehavior，不过其实唯一的增强也就是提供了用户自定义模版的能力。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas示例（5） - 自定义TypeConverter把基础类型转换为复杂类型",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas--sample-5.html",
        "BriefIntro": "在上一个示例中我们了解到如何通过HTTP GET来访问Web Services方法。很显然，使用HTTP GET依靠Query String传递参数，于是在客户端拿到的总是基本数据类型String。幸好，在Atlas中，对于基础类型的参数，如果遇到了一个字符串，则会设法将其转换成一个合适的类型。因此，在使用HTTP GET方法传递参数时，在Web Services方法里能够使用个中各样的基础类型。但是，这显然远远不够，Atlas也不会将这个问题置之不理。在Atlas中，自提供了一套自定义机制可以将基础类型转换为复杂类型。本文通过示例演示了如何通过自定义TypeConverter来提供简单类型到复杂类型的转换。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas示例（4） - 使用HTTP GET调用Web Services方法",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas--sample-4.html",
        "BriefIntro": "在之前的例子里，由于Atlas客户端在调用Web Services方法时总是使用了Sys.Net.ServiceMethod类，因此始终使用了HTTP POST方法与服务器端进行交互。POST方法有其好处，不过GET方法也自有其价值。本文通过示例解释了如何使一个Web Services方法能够通过HTTP GET调用，并且如何调用它。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas示例（3） - 在Web Services方法中使用多态",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas--sample-3.html",
        "BriefIntro": "在Web Services方法中，我们往往使用的都是一个具体类型的参数。这个参数一般就是一个数据对象，所有的功能基本上只是为了存放数据。虽然这对于应用来说一般已经足够，我们大量使用了这样的Web Services，不也过得好好的吗？但是，在这一点上实在太不够面向对象了。本文提供了示例演示如何在客户端选择传递给Web Service参数的具体类型，以达到一定程度上多态的效果。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas示例（2） - 自定义JavaScriptConverter处理循环引用对象",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas--sample-2.html",
        "BriefIntro": "在以前的文章中我曾经举了一个简单例子，如果一个对象存在着循环引用，那么无论在客户端还是服务器端都会出现异常状况。这篇文章将通过示例来解释如何使用自定义JavaScriptConverter来解决这个问题。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（6） - 对于复杂数据类型的支持（下）",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas-6.html",
        "BriefIntro": "将Atlas访问Web Services方法对于复杂类型的支持讨论完毕，在之后的文章中将通过示例着重讲解一些有用的功能和在文章中提到的扩展。　　本文分析了Web Services方法寻找自身所支持的复杂类型的方式，以及将对象序列化输出的实现和注意点。 "
    },
    {
        "Title": "“深入Atlas系列”文章导读",
        "Link": "/2006/10/inside-atlas-series-index.html",
        "BriefIntro": "“深入Atlas系列”的路还很长，还有许许多多的东西可以分析与挖掘。这个“文章导读”既是对这个系列文章的一种整理，也是对我坚持完成这一系列的一个自我鼓励与鞭策。　　从现在开始，我决定从现在开始将“深入Atlas系列”的文章分为“分析”与“示例”两部分。“分析”部分文章可能会相对比较“枯燥”，因为它几乎完全就是从实现角度对Atlas的原理进行剖析，附带一些说明性的简单示例。但是这才是我精力花费最大的地方。这部分文章都是“示例”部分的实现依据。“示例”部分文章使用了“分析”部分所得到的结论，然后设计出来的Atlas使用示例。它们用一种比较直观的方式对一些复杂或高级的问题提供解决方案。　　既然是“深入Atlas系列”，我会尽可能保持这个系列内容的“深入”性，讨论的内容也尽可能地避免流于表面或者已有的文档和示例，因此这对我的要求也会相当的高。请朋友们有也不要吝啬您的意见、建议和疑问。你们的支持是对我最大的鼓励。如果希望深入了解Atlas的哪个部分，也请尽管告诉我。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（5） - 对于复杂数据类型的支持（中）",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas-5.html",
        "BriefIntro": "这篇文章继续讨论了Atlas访问Web Services方法时对于复杂类型的支持，并从实现角度分析了可以说是此中最重要的那部分代码。这部分内容是扩展Atlas对于复杂类型支持的依据，由此可以得出Atlas的一些强大之处。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（4） - 对于复杂数据类型的支持（上）",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas-4.html",
        "BriefIntro": "Atlas访问Web Serivces方法对于复杂数据类型的支持并不如前几片文章所描述的那么简单。从这篇文章开始，我将从实现角度详细分析Atlas访问Web Services方法是如何支持复杂数据类型的，并最终对于一些常见的情况给出解决方案。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas示例（1） - 特别的访问方式",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas--sample-1.html",
        "BriefIntro": "本文从实现角度讨论了使用Sys.Net.ServiceMethod.invoke以及Declarative Syntax调用Web Services的方法。并通过示例指出了Atlas现有的组件的不足并提供了改进办法、源文件以及示例。本文提供了三个示例：1、使用Sys.Net.ServiceMethod.invoke静态方法访问Web Services2、使用Declarative Syntax访问Web Services方法3、使用改进的Declarative Syntax访问Web Services方法 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（3） - 服务器端支持（下）",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas-3.html",
        "BriefIntro": "在上一篇文章里，我们分析了一部分服务器端的代码。在这篇文章里，我将完成服务器端代码分析之外，另外提供了两个范例让大家参考：1、在Web Services方法中使用复杂的数据类型2、使用Web Services将对象序列化成XML并使用客户端XSLTView空间输出信息 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（2） - 服务器端支持（上）",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas-2.html",
        "BriefIntro": "在上一片文章里，我们分析讨论了使用Atlas在进行AJAX访问Web Services所用的客户端代码。但是如果要实现这一功能，很显然还离不开服务器端的支持。在这篇文章里，我们就来讨论这一点。 "
    },
    {
        "Title": "深入Atlas系列：Web Sevices Access in Atlas（1） - 客户端支持",
        "Link": "/2006/10/inside-atlas-series--web-services-access-in-atlas-1.html",
        "BriefIntro": "Atlas提供了强大而灵活的服务器端Web Services访问能力。这对于客户端AJAX开发提供了绝好的条件，这几乎也是任何AJAX框架必备的功能。因为只要有了它，就能轻松地以AJAX方式与服务器端进行交互，而其他多样的页面操作自然可以由开发人员尽情开发。对于部分喜欢自己动手的开发人员来说，这甚至是他们仅仅需要的支持。　　从这篇文章开始，我会从实现角度剖析Atlas对于Web Services的支持，希望能够帮助大家更深入地理解，更灵活地使用Atlas提供的这一功能。 "
    },
    {
        "Title": "Gadget，又见Gadget - 浅尝Windows Live Contacts Gadget",
        "Link": "/2006/10/windows-live-contacts-gadget.html",
        "BriefIntro": "近日在Windows Live Dev里发现了一个新的Feature（其实已经出现一个多月了）：Windows Live Contacts Gadget (Beta)，一试之下，颇为有趣。Windows Live Contacts Gadget可能是一个创举，它能够将Windows Live Account上的联系人信息提供给任意第三方使用。任意第三方的产品可以轻易地结合这些联系人信息进行开发（后面将会看到它与Windows Live Local结合的范例）。 "
    },
    {
        "Title": "使用Atlas创建自己的Client Control",
        "Link": "/2006/10/use-atlas-to-build-custom-client-control.html",
        "BriefIntro": "Atlas客户端脚本提供了数个继承于Sys.UI.Control的类，从简单如Sys.UI.Button，到复杂如Sys.UI.Data.ListView，在一定程度上方便了开发人员，另外可以使用Declarative Syntax也可谓一大进步。但是一般仅仅使用Atlas提供的那些类是远远不够的，开发人员必须自行使用Atlas进行扩展，并且将自己的扩展融入到Atlas模型中去。 "
    },
    {
        "Title": "Sys.UI.Data.DataNavigator与Sys.UI.Data.SortBehavior",
        "Link": "/2006/09/sys-ui-data-datanavigator-and-sys-ui-data-sortbehavior.html",
        "BriefIntro": "阅读了Atlas代码之后，出现了很多想法。现在对于Sys.UI.Data.DataNavigator进行简单分析，并对它的设计产生了质疑，并提出了Sys.UI.Data.DataNavigator的一个bug，即使在功能上并无体现。 "
    },
    {
        "Title": "本地化与Atlas对于本地化的支持",
        "Link": "/2006/09/localization-and-localization-support-in-atlas.html",
        "BriefIntro": "周三我参与的项目的Beta版终于发布了，这个项目是对今年2月已经在美国上线的产品进行本地化工作。很奇怪，在Production环境中使用下来感觉比想象中要好很多，忐忑的心情放轻松了不少。虽然我那个项目没有用到Atlas，不过也就趁这个机会，简单讲一下本地化和Atlas对于本地化的支持吧。本文分以下四部分：一、什么是本地化二、Atlas对于本地化的支持三、为Atlas的本地化的支持自定义Culture Detection规则四、更好地控制Atlas本地化支持 "
    },
    {
        "Title": "一个我在研究Atlas Control Toolkit时做的尝试：ImageGalleryExtender",
        "Link": "/2006/09/atlascontroltoolkit-demo-imagegalleryextender.html",
        "BriefIntro": "ImageGalleryExtender是我在研究Atlas Control Toolkit代码时的一个尝试。这个Extender的作用是能够轻松地制作一个相册浏览的功能。 "
    },
    {
        "Title": "修补AJAX应用中Back/Forward Button和Bookmark失效的问题",
        "Link": "/2006/09/support-back-forward-and-bookmark-in-ajax-app.html",
        "BriefIntro": "从AJAX诞生至今，就存在着Back/Forward Button和bookmark失效的问题，我以前一般提倡，一个好的AJAX应用应该不让用户有点击“Back/Forward”的想法，并且使用某种方式提供给用户一个能够记录直接产生页面的Bookmark。Windows Live Local应该是这种应用最好的典范之一，其灵活的交互，良好的界面让我在初遇时不得不眼前一亮。　　另外，我也曾经见过把后退按钮禁用的做法（其实这样对于解决问题的确不错），不过这些都似乎只是一个workaround，设法避开这个AJAX应用普遍存在的问题。似乎Gmail能够支持Back按钮，但是我惊奇的发现，在点击Back后，却不能使用Forward，所以这还不算成功的解决这个问题。那么能否解决？似乎已经有了一定的实现。 "
    },
    {
        "Title": "Sys.ScriptLoader与JS加载进度条的实现",
        "Link": "/2006/09/sysscriptloader-and-implementation-of-script-loading-progress-bar.html",
        "BriefIntro": "Sys.ScriptLoader与JS加载进度条的实现　　今天有人问我，163邮箱那样的Javascript加载进度条是如何实现的。　　我不知道，不过实现一个不难，因为<script />有onload事件。还有就是，我们有Atlas。 "
    }
]